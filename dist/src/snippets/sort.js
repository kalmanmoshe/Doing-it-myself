/**
 * creates a copy of a snippets array,
 * sorted by priority, falling back to trigger length if there is a tie.
 */
export function sortSnippets(snippets) {
    // schwartzian transform:
    // trigger length is a factor for sorting,
    // but to get "length" of regex we need to get its source
    // (the debate regarding regex length being treated the same as regular string length is another issue).
    // the idea here is to avoid calling e.g. `RegExp.source()` over and over again when sorting,
    // by precomputing the values to sort by and associating each original element to these values,
    // sorting with this intermediate representation,
    // and retrieving back the original elements.
    return snippets
        // first precompute trigger lengths for each snippet while keeping a reference to the original snippet (via index in `snippets`),
        .map((snippet, i) => [getPriority(snippet), getTriggerLength(snippet), i])
        // sort resultant tuples representing the snippets
        .sort(schwartzianSnippetCompare)
        // and get back the snippets
        .map(([p, t, i]) => snippets[i]);
}
/**
 * Sorts snippets by priority, falling back to trigger length if there is a tie.
 */
export function schwartzianSnippetCompare(a, b) {
    return comparePriority(a[0], b[0]) || compareTriggerLength(a[1], b[1]);
}
/**
 * Sorts snippets by trigger length so longer snippets will have higher priority
 */
function compareTriggerLength(a, b) {
    if (a < b) {
        return 1;
    }
    if (a > b) {
        return -1;
    }
    return 0;
}
/**
 * Sorts snippets in order of priority
 */
function comparePriority(a, b) {
    if (a < b) {
        return 1;
    }
    if (a > b) {
        return -1;
    }
    return 0;
}
function getPriority(snippet) {
    return snippet.priority || 0;
}
function getTriggerLength(snippet) {
    return typeof snippet.trigger === "string"
        ? snippet.trigger.length
        : snippet.trigger.source.length;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zbmlwcGV0cy9zb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBOzs7R0FHRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUMsUUFBbUI7SUFDL0MseUJBQXlCO0lBQ3pCLDBDQUEwQztJQUMxQyx5REFBeUQ7SUFDekQsd0dBQXdHO0lBQ3hHLDZGQUE2RjtJQUM3RiwrRkFBK0Y7SUFDL0YsaURBQWlEO0lBQ2pELDZDQUE2QztJQUM3QyxPQUFPLFFBQVE7UUFDZCxpSUFBaUk7U0FDaEksR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUUsa0RBQWtEO1NBQ2pELElBQUksQ0FBQyx5QkFBeUIsQ0FBQztRQUNoQyw0QkFBNEI7U0FDM0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBSUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUseUJBQXlCLENBQUMsQ0FBK0IsRUFBRSxDQUErQjtJQUN6RyxPQUFPLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hFLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsb0JBQW9CLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFBQyxPQUFPLENBQUMsQ0FBQztJQUFDLENBQUM7SUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQUMsQ0FBQztJQUN6QixPQUFPLENBQUMsQ0FBQztBQUNWLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsZUFBZSxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQzVDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQUMsT0FBTyxDQUFDLENBQUM7SUFBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUFDLENBQUM7SUFDekIsT0FBTyxDQUFDLENBQUM7QUFDVixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsT0FBZ0I7SUFDcEMsT0FBTyxPQUFPLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQztBQUM5QixDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxPQUFnQjtJQUN6QyxPQUFPLE9BQU8sT0FBTyxDQUFDLE9BQU8sS0FBSyxRQUFRO1FBQ3pDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU07UUFDeEIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNsQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTbmlwcGV0IH0gZnJvbSBcIi4vc25pcHBldHNcIjtcclxuXHJcbi8qKlxyXG4gKiBjcmVhdGVzIGEgY29weSBvZiBhIHNuaXBwZXRzIGFycmF5LFxyXG4gKiBzb3J0ZWQgYnkgcHJpb3JpdHksIGZhbGxpbmcgYmFjayB0byB0cmlnZ2VyIGxlbmd0aCBpZiB0aGVyZSBpcyBhIHRpZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzb3J0U25pcHBldHMoc25pcHBldHM6IFNuaXBwZXRbXSk6IFNuaXBwZXRbXSB7XHJcblx0Ly8gc2Nod2FydHppYW4gdHJhbnNmb3JtOlxyXG5cdC8vIHRyaWdnZXIgbGVuZ3RoIGlzIGEgZmFjdG9yIGZvciBzb3J0aW5nLFxyXG5cdC8vIGJ1dCB0byBnZXQgXCJsZW5ndGhcIiBvZiByZWdleCB3ZSBuZWVkIHRvIGdldCBpdHMgc291cmNlXHJcblx0Ly8gKHRoZSBkZWJhdGUgcmVnYXJkaW5nIHJlZ2V4IGxlbmd0aCBiZWluZyB0cmVhdGVkIHRoZSBzYW1lIGFzIHJlZ3VsYXIgc3RyaW5nIGxlbmd0aCBpcyBhbm90aGVyIGlzc3VlKS5cclxuXHQvLyB0aGUgaWRlYSBoZXJlIGlzIHRvIGF2b2lkIGNhbGxpbmcgZS5nLiBgUmVnRXhwLnNvdXJjZSgpYCBvdmVyIGFuZCBvdmVyIGFnYWluIHdoZW4gc29ydGluZyxcclxuXHQvLyBieSBwcmVjb21wdXRpbmcgdGhlIHZhbHVlcyB0byBzb3J0IGJ5IGFuZCBhc3NvY2lhdGluZyBlYWNoIG9yaWdpbmFsIGVsZW1lbnQgdG8gdGhlc2UgdmFsdWVzLFxyXG5cdC8vIHNvcnRpbmcgd2l0aCB0aGlzIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvbixcclxuXHQvLyBhbmQgcmV0cmlldmluZyBiYWNrIHRoZSBvcmlnaW5hbCBlbGVtZW50cy5cclxuXHRyZXR1cm4gc25pcHBldHNcclxuXHRcdC8vIGZpcnN0IHByZWNvbXB1dGUgdHJpZ2dlciBsZW5ndGhzIGZvciBlYWNoIHNuaXBwZXQgd2hpbGUga2VlcGluZyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgc25pcHBldCAodmlhIGluZGV4IGluIGBzbmlwcGV0c2ApLFxyXG5cdFx0Lm1hcCgoc25pcHBldCwgaSkgPT4gW2dldFByaW9yaXR5KHNuaXBwZXQpLCBnZXRUcmlnZ2VyTGVuZ3RoKHNuaXBwZXQpLCBpXSlcclxuXHRcdC8vIHNvcnQgcmVzdWx0YW50IHR1cGxlcyByZXByZXNlbnRpbmcgdGhlIHNuaXBwZXRzXHJcblx0XHQuc29ydChzY2h3YXJ0emlhblNuaXBwZXRDb21wYXJlKVxyXG5cdFx0Ly8gYW5kIGdldCBiYWNrIHRoZSBzbmlwcGV0c1xyXG5cdFx0Lm1hcCgoW3AsIHQsIGldKSA9PiBzbmlwcGV0c1tpXSk7XHJcbn1cclxuXHJcbnR5cGUgU2Nod2FydHppYW5JbnRlcm1lZGlhdGVWYWx1ZSA9IFtwcmlvcml0eTogbnVtYmVyLCB0cmlnZ2VyTGVuZ3RoOiBudW1iZXIsIGk6IG51bWJlcl07XHJcblxyXG4vKipcclxuICogU29ydHMgc25pcHBldHMgYnkgcHJpb3JpdHksIGZhbGxpbmcgYmFjayB0byB0cmlnZ2VyIGxlbmd0aCBpZiB0aGVyZSBpcyBhIHRpZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2h3YXJ0emlhblNuaXBwZXRDb21wYXJlKGE6IFNjaHdhcnR6aWFuSW50ZXJtZWRpYXRlVmFsdWUsIGI6IFNjaHdhcnR6aWFuSW50ZXJtZWRpYXRlVmFsdWUpIHtcclxuXHRyZXR1cm4gY29tcGFyZVByaW9yaXR5KGFbMF0sIGJbMF0pIHx8IGNvbXBhcmVUcmlnZ2VyTGVuZ3RoKGFbMV0sIGJbMV0pO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydHMgc25pcHBldHMgYnkgdHJpZ2dlciBsZW5ndGggc28gbG9uZ2VyIHNuaXBwZXRzIHdpbGwgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVUcmlnZ2VyTGVuZ3RoKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XHJcblx0aWYgKGEgPCBiKSB7IHJldHVybiAxOyB9XHJcblx0aWYgKGEgPiBiKSB7IHJldHVybiAtMTsgfVxyXG5cdHJldHVybiAwO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydHMgc25pcHBldHMgaW4gb3JkZXIgb2YgcHJpb3JpdHlcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVQcmlvcml0eShhOiBudW1iZXIsIGI6IG51bWJlcikge1xyXG5cdGlmIChhIDwgYikgeyByZXR1cm4gMTsgfVxyXG5cdGlmIChhID4gYikgeyByZXR1cm4gLTE7IH1cclxuXHRyZXR1cm4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UHJpb3JpdHkoc25pcHBldDogU25pcHBldCkge1xyXG5cdHJldHVybiBzbmlwcGV0LnByaW9yaXR5IHx8IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRyaWdnZXJMZW5ndGgoc25pcHBldDogU25pcHBldCkge1xyXG5cdHJldHVybiB0eXBlb2Ygc25pcHBldC50cmlnZ2VyID09PSBcInN0cmluZ1wiXHJcblx0XHQ/IHNuaXBwZXQudHJpZ2dlci5sZW5ndGhcclxuXHRcdDogc25pcHBldC50cmlnZ2VyLnNvdXJjZS5sZW5ndGg7XHJcbn0iXX0=