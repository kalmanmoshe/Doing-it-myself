export class Paren {
    type;
    depth;
    depthID;
    constructor(depth, depthID, type) {
        this.depth = depth;
        this.depthID = depthID;
        this.type = type;
    }
    toString() { this.id = this.depth + "." + this.depthID; }
    compare(paren) {
        if (!(paren instanceof Paren))
            return false;
        return this.depth === paren.depth && this.depthID === paren.depthID;
    }
    addDepth(num) { this.depth += num; }
    isOpen() { return open.includes(this.type); }
    adddepthID(num) { this.depthID += num; }
    clone() { return new Paren(this.depth, this.depthID, this.type); }
}
const open = ['Parentheses_open', 'Curly_brackets_open', 'Square_brackets_open'];
const close = ['Parentheses_close', 'Curly_brackets_close', 'Square_brackets_close'];
export function idParentheses(tokens) {
    let depth = 0;
    const depthCounts = {};
    for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        if (open.includes(token.value)) {
            if (!depthCounts[depth]) {
                depthCounts[depth] = 0;
            }
            const depthID = depthCounts[depth]++;
            const paren = new Paren(depth, depthID, token.value);
            tokens.splice(i, 1, paren);
            // Increase depth for nested parentheses
            depth++;
            continue;
        }
        if (close.includes(token.value)) {
            depth--;
            if (depth < 0) {
                console.error(token.value, tokens);
                throw new Error("Unmatched closing parenthesis detected.");
            }
            // Assign a unique ID to the closing parenthesis
            const depthID = depthCounts[depth] - 1;
            const paren = new Paren(depth, depthID, token.value);
            tokens.splice(i, 1, paren);
        }
    }
    // Check for unmatched opening parentheses
    if (depth !== 0) {
        console.error(tokens);
        throw new Error(`Unmatched opening parenthesis(es) detected: depth=${depth}`);
    }
    return tokens;
}
export function mapBrackets(type, tokens) {
    return tokens
        .map((token, index) => token.name === type
        ? /*findParenIndex(token.value, undefined, tokens) */ 'errMoshe'
        : null)
        .filter((t) => t !== null);
}
export const isOpenParen = (item) => {
    if (!(item instanceof Paren) || !item.type)
        return false;
    return open.includes(item.type);
};
export const isClosedParen = (item) => {
    if (!(item instanceof Paren) || !item.type)
        return false;
    return close.includes(item.type);
};
export function findModifiedParenIndex(id, index, tokens, depth, depthID, filter) {
    // Initialize `id` as a new instance if not already provided
    id = id
        ? new Paren(id.depth, id.depthID)
        : new Paren(tokens[index].value.depth, tokens[index].value.depthID);
    if (depth !== undefined && depthID !== undefined) {
        id.depth += depth || 0;
        id.depthID += depthID || 0;
    }
    const openIndex = tokens.findIndex(token => {
        if (open.includes(token.name) && token.value?.compare(id)) {
            if (filter && !token.name.startsWith(filter)) {
                id.depth = token.value.depth + (depth || 0);
                id.depthID = token.value.depthID + (depthID || 0);
                return false;
            }
            return true;
        }
        return false;
    });
    const closeIndex = tokens.findLastIndex(token => close.includes(token.name) &&
        token.value?.compare(id));
    return { open: openIndex, close: closeIndex, id };
}
/**
 * Finds the indices of the opening and closing parentheses based on the given ID.
 * @param {Paren|number} id - The identifier to compare tokens. Defaults to the token at the given index if a number is provided.
 * @param {Array} tokens - The array of tokens to search within.
 * @returns {{open: number, close: number, id: Paren}} An object containing the indices of the opening and closing parentheses and the matched ID.
 * - `open`: The index of the first matching opening parenthesis.
 * - `close`: The index of the last matching closing parenthesis.
 * - `id`: The identifier used for comparison.
 */
export function findParenIndex(id, tokens) {
    const index = typeof id === "number" ? id : null;
    id = index !== null ? tokens[index] : id;
    if (!(id instanceof Paren)) {
        throw new TypeError("Invalid ID: Expected a Paren object or a valid index.");
    }
    const openIndex = tokens.findIndex((token) => isOpenParen(token) && id.compare(token));
    const closeIndex = tokens.findLastIndex((token) => isClosedParen(token) && id.compare(token));
    if (openIndex === -1 || closeIndex === -1)
        throw new Error('Parentheses not found');
    return { open: openIndex, close: closeIndex, id };
}
export function findDeepestParenthesesScope(tokens) {
    let begin = 0, end = tokens.length;
    let deepestScope = null;
    let currentScope = null; // Define currentScope in the outer scope of the loop
    for (let i = 0; i < tokens.length; i++) {
        if (isOpenParen(tokens[i])) {
            currentScope = findParenIndex(tokens[i], tokens);
        }
        if (currentScope !== null && i === currentScope.close) {
            [begin, end] = [currentScope.open, currentScope.close];
            deepestScope = currentScope.id;
            break;
        }
    }
    return { begin, end, deepestParenthesesScope: deepestScope ?? null };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5VdGVuc2lscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy90b2tlblV0ZW5zaWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sT0FBTyxLQUFLO0lBQ2QsSUFBSSxDQUFDO0lBQ0wsS0FBSyxDQUFDO0lBQ04sT0FBTyxDQUFDO0lBRVIsWUFBWSxLQUFLLEVBQUMsT0FBTyxFQUFDLElBQUk7UUFDMUIsSUFBSSxDQUFDLEtBQUssR0FBQyxLQUFLLENBQUM7UUFDakIsSUFBSSxDQUFDLE9BQU8sR0FBQyxPQUFPLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBQyxJQUFJLENBQUE7SUFDbEIsQ0FBQztJQUNELFFBQVEsS0FBRyxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUEsQ0FBQSxDQUFDO0lBQ25ELE9BQU8sQ0FBQyxLQUFLO1FBQ1QsSUFBRyxDQUFDLENBQUMsS0FBSyxZQUFZLEtBQUssQ0FBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1FBQzNDLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBRyxLQUFLLENBQUMsS0FBSyxJQUFFLElBQUksQ0FBQyxPQUFPLEtBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQTtJQUNqRSxDQUFDO0lBQ0QsUUFBUSxDQUFDLEdBQUcsSUFBRSxJQUFJLENBQUMsS0FBSyxJQUFFLEdBQUcsQ0FBQSxDQUFBLENBQUM7SUFDOUIsTUFBTSxLQUFHLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBQSxDQUFDO0lBQ3pDLFVBQVUsQ0FBQyxHQUFHLElBQUUsSUFBSSxDQUFDLE9BQU8sSUFBRSxHQUFHLENBQUEsQ0FBQSxDQUFDO0lBQ2xDLEtBQUssS0FBRyxPQUFPLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUMsSUFBSSxDQUFDLE9B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QUMsRUFBQyxNQUFNLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBQ0QsSUFBSSxZQUFZLEtBQUcsSUFBSSxJQUFFLENBQUMsS0FBRyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDOUMsQ0FBQyxLQUFLLEVBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUNsRCxZQUFZLEdBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQTtZQUM1QixNQUFNO1FBQ1YsQ0FBQztJQUNMLENBQUM7SUFFRCxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSx1QkFBdUIsRUFBRSxZQUFZLElBQUksSUFBSSxFQUFFLENBQUM7QUFDekUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBQYXJlbntcclxuICAgIHR5cGU7XHJcbiAgICBkZXB0aDtcclxuICAgIGRlcHRoSUQ7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGRlcHRoLGRlcHRoSUQsdHlwZSl7XHJcbiAgICAgICAgdGhpcy5kZXB0aD1kZXB0aDtcclxuICAgICAgICB0aGlzLmRlcHRoSUQ9ZGVwdGhJRDtcclxuICAgICAgICB0aGlzLnR5cGU9dHlwZVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKXt0aGlzLmlkPXRoaXMuZGVwdGggKyBcIi5cIiArIHRoaXMuZGVwdGhJRH1cclxuICAgIGNvbXBhcmUocGFyZW4pe1xyXG4gICAgICAgIGlmKCEocGFyZW4gaW5zdGFuY2VvZiBQYXJlbikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aD09PXBhcmVuLmRlcHRoJiZ0aGlzLmRlcHRoSUQ9PT1wYXJlbi5kZXB0aElEXHJcbiAgICB9XHJcbiAgICBhZGREZXB0aChudW0pe3RoaXMuZGVwdGgrPW51bX1cclxuICAgIGlzT3Blbigpe3JldHVybiBvcGVuLmluY2x1ZGVzKHRoaXMudHlwZSl9XHJcbiAgICBhZGRkZXB0aElEKG51bSl7dGhpcy5kZXB0aElEKz1udW19XHJcbiAgICBjbG9uZSgpe3JldHVybiBuZXcgUGFyZW4odGhpcy5kZXB0aCx0aGlzLmRlcHRoSUQsdGhpcy50eXBlKX1cclxufVxyXG5jb25zdCBvcGVuPVsnUGFyZW50aGVzZXNfb3BlbicsJ0N1cmx5X2JyYWNrZXRzX29wZW4nLCdTcXVhcmVfYnJhY2tldHNfb3BlbiddO1xyXG5jb25zdCBjbG9zZT1bJ1BhcmVudGhlc2VzX2Nsb3NlJywnQ3VybHlfYnJhY2tldHNfY2xvc2UnLCdTcXVhcmVfYnJhY2tldHNfY2xvc2UnXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpZFBhcmVudGhlc2VzKHRva2Vucykge1xyXG4gICAgbGV0IGRlcHRoID0gMDtcclxuICAgIGNvbnN0IGRlcHRoQ291bnRzID0ge307XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIGlmIChvcGVuLmluY2x1ZGVzKHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlcHRoQ291bnRzW2RlcHRoXSkge1xyXG4gICAgICAgICAgICAgICAgZGVwdGhDb3VudHNbZGVwdGhdID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZGVwdGhJRCA9IGRlcHRoQ291bnRzW2RlcHRoXSsrO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbiA9IG5ldyBQYXJlbihkZXB0aCwgZGVwdGhJRCx0b2tlbi52YWx1ZSk7XHJcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwxLHBhcmVuKVxyXG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBkZXB0aCBmb3IgbmVzdGVkIHBhcmVudGhlc2VzXHJcbiAgICAgICAgICAgIGRlcHRoKys7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNsb3NlLmluY2x1ZGVzKHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBkZXB0aC0tO1xyXG4gICAgICAgICAgICBpZiAoZGVwdGggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHRva2VuLnZhbHVlLHRva2VucylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVubWF0Y2hlZCBjbG9zaW5nIHBhcmVudGhlc2lzIGRldGVjdGVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduIGEgdW5pcXVlIElEIHRvIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzXHJcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoSUQgPSBkZXB0aENvdW50c1tkZXB0aF0gLSAxO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbiA9IG5ldyBQYXJlbihkZXB0aCwgZGVwdGhJRCx0b2tlbi52YWx1ZSk7XHJcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwxLHBhcmVuKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgdW5tYXRjaGVkIG9wZW5pbmcgcGFyZW50aGVzZXNcclxuICAgIGlmIChkZXB0aCAhPT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IodG9rZW5zKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5tYXRjaGVkIG9wZW5pbmcgcGFyZW50aGVzaXMoZXMpIGRldGVjdGVkOiBkZXB0aD0ke2RlcHRofWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRva2Vuc1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwQnJhY2tldHModHlwZSx0b2tlbnMpe1xyXG4gICAgcmV0dXJuIHRva2Vuc1xyXG4gICAgICAgIC5tYXAoKHRva2VuLCBpbmRleCkgPT4gXHJcbiAgICAgICAgICAgIHRva2VuLm5hbWUgPT09IHR5cGVcclxuICAgICAgICAgICAgICAgID8gLypmaW5kUGFyZW5JbmRleCh0b2tlbi52YWx1ZSwgdW5kZWZpbmVkLCB0b2tlbnMpICovJ2Vyck1vc2hlJ1xyXG4gICAgICAgICAgICAgICAgOiBudWxsXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5maWx0ZXIoKHQpID0+IHQgIT09IG51bGwpO1xyXG59XHJcbmV4cG9ydCBjb25zdCBpc09wZW5QYXJlbj0oaXRlbSk9PntcclxuICAgIGlmKCEoaXRlbSBpbnN0YW5jZW9mIFBhcmVuKXx8IWl0ZW0udHlwZSlyZXR1cm4gZmFsc2VcclxuICAgIHJldHVybiBvcGVuLmluY2x1ZGVzKGl0ZW0udHlwZSlcclxufVxyXG5leHBvcnQgY29uc3QgaXNDbG9zZWRQYXJlbj0oaXRlbSk9PntcclxuICAgIGlmKCEoaXRlbSBpbnN0YW5jZW9mIFBhcmVuKXx8IWl0ZW0udHlwZSlyZXR1cm4gZmFsc2VcclxuICAgIHJldHVybiBjbG9zZS5pbmNsdWRlcyhpdGVtLnR5cGUpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kTW9kaWZpZWRQYXJlbkluZGV4KGlkLCBpbmRleCwgdG9rZW5zLCBkZXB0aCwgZGVwdGhJRCwgZmlsdGVyKSB7XHJcbiAgICAvLyBJbml0aWFsaXplIGBpZGAgYXMgYSBuZXcgaW5zdGFuY2UgaWYgbm90IGFscmVhZHkgcHJvdmlkZWRcclxuICAgIGlkID0gaWRcclxuICAgICAgICA/IG5ldyBQYXJlbihpZC5kZXB0aCwgaWQuZGVwdGhJRClcclxuICAgICAgICA6IG5ldyBQYXJlbih0b2tlbnNbaW5kZXhdLnZhbHVlLmRlcHRoLCB0b2tlbnNbaW5kZXhdLnZhbHVlLmRlcHRoSUQpO1xyXG5cclxuICAgIGlmIChkZXB0aCAhPT0gdW5kZWZpbmVkICYmIGRlcHRoSUQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlkLmRlcHRoICs9IGRlcHRoIHx8IDA7XHJcbiAgICAgICAgaWQuZGVwdGhJRCArPSBkZXB0aElEIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3BlbkluZGV4ID0gdG9rZW5zLmZpbmRJbmRleCh0b2tlbiA9PiB7XHJcbiAgICAgICAgaWYgKG9wZW4uaW5jbHVkZXModG9rZW4ubmFtZSkgJiYgdG9rZW4udmFsdWU/LmNvbXBhcmUoaWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIXRva2VuLm5hbWUuc3RhcnRzV2l0aChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZC5kZXB0aCA9IHRva2VuLnZhbHVlLmRlcHRoICsgKGRlcHRoIHx8IDApXHJcbiAgICAgICAgICAgICAgICBpZC5kZXB0aElEPXRva2VuLnZhbHVlLmRlcHRoSUQgKyAoZGVwdGhJRCB8fCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gdG9rZW5zLmZpbmRMYXN0SW5kZXgoXHJcbiAgICAgICAgdG9rZW4gPT5cclxuICAgICAgICAgICAgY2xvc2UuaW5jbHVkZXModG9rZW4ubmFtZSkgJiZcclxuICAgICAgICAgICAgdG9rZW4udmFsdWU/LmNvbXBhcmUoaWQpXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IG9wZW46IG9wZW5JbmRleCwgY2xvc2U6IGNsb3NlSW5kZXgsIGlkIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGluZGljZXMgb2YgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgcGFyZW50aGVzZXMgYmFzZWQgb24gdGhlIGdpdmVuIElELlxyXG4gKiBAcGFyYW0ge1BhcmVufG51bWJlcn0gaWQgLSBUaGUgaWRlbnRpZmllciB0byBjb21wYXJlIHRva2Vucy4gRGVmYXVsdHMgdG8gdGhlIHRva2VuIGF0IHRoZSBnaXZlbiBpbmRleCBpZiBhIG51bWJlciBpcyBwcm92aWRlZC5cclxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIC0gVGhlIGFycmF5IG9mIHRva2VucyB0byBzZWFyY2ggd2l0aGluLlxyXG4gKiBAcmV0dXJucyB7e29wZW46IG51bWJlciwgY2xvc2U6IG51bWJlciwgaWQ6IFBhcmVufX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgcGFyZW50aGVzZXMgYW5kIHRoZSBtYXRjaGVkIElELlxyXG4gKiAtIGBvcGVuYDogVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaGluZyBvcGVuaW5nIHBhcmVudGhlc2lzLlxyXG4gKiAtIGBjbG9zZWA6IFRoZSBpbmRleCBvZiB0aGUgbGFzdCBtYXRjaGluZyBjbG9zaW5nIHBhcmVudGhlc2lzLlxyXG4gKiAtIGBpZGA6IFRoZSBpZGVudGlmaWVyIHVzZWQgZm9yIGNvbXBhcmlzb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVuSW5kZXgoaWQsIHRva2Vucykge1xyXG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIgPyBpZCA6IG51bGw7XHJcbiAgICBpZCA9IGluZGV4ICE9PSBudWxsID8gdG9rZW5zW2luZGV4XSA6IGlkO1xyXG5cclxuICAgIGlmICghKGlkIGluc3RhbmNlb2YgUGFyZW4pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgSUQ6IEV4cGVjdGVkIGEgUGFyZW4gb2JqZWN0IG9yIGEgdmFsaWQgaW5kZXguXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3BlbkluZGV4ID0gdG9rZW5zLmZpbmRJbmRleChcclxuICAgICAgICAodG9rZW4pID0+IGlzT3BlblBhcmVuKHRva2VuKSAmJiBpZC5jb21wYXJlKHRva2VuKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gdG9rZW5zLmZpbmRMYXN0SW5kZXgoXHJcbiAgICAgICAgKHRva2VuKSA9PiBpc0Nsb3NlZFBhcmVuKHRva2VuKSAmJiBpZC5jb21wYXJlKHRva2VuKVxyXG4gICAgKTtcclxuICAgIGlmKG9wZW5JbmRleD09PS0xfHxjbG9zZUluZGV4PT09LTEpdGhyb3cgbmV3IEVycm9yKCdQYXJlbnRoZXNlcyBub3QgZm91bmQnKVxyXG4gICAgcmV0dXJuIHsgb3Blbjogb3BlbkluZGV4LCBjbG9zZTogY2xvc2VJbmRleCwgaWQgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREZWVwZXN0UGFyZW50aGVzZXNTY29wZSh0b2tlbnMpIHtcclxuICAgIGxldCBiZWdpbiA9IDAsXHJcbiAgICAgICAgZW5kID0gdG9rZW5zLmxlbmd0aDtcclxuICAgIGxldCBkZWVwZXN0U2NvcGUgPSBudWxsO1xyXG4gICAgbGV0IGN1cnJlbnRTY29wZSA9IG51bGw7IC8vIERlZmluZSBjdXJyZW50U2NvcGUgaW4gdGhlIG91dGVyIHNjb3BlIG9mIHRoZSBsb29wXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNPcGVuUGFyZW4odG9rZW5zW2ldKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBmaW5kUGFyZW5JbmRleCh0b2tlbnNbaV0sdG9rZW5zKTsgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudFNjb3BlIT09bnVsbCYmaT09PWN1cnJlbnRTY29wZS5jbG9zZSkge1xyXG4gICAgICAgICAgICBbYmVnaW4sZW5kXT1bY3VycmVudFNjb3BlLm9wZW4sY3VycmVudFNjb3BlLmNsb3NlXVxyXG4gICAgICAgICAgICBkZWVwZXN0U2NvcGU9Y3VycmVudFNjb3BlLmlkXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBiZWdpbiwgZW5kLCBkZWVwZXN0UGFyZW50aGVzZXNTY29wZTogZGVlcGVzdFNjb3BlID8/IG51bGwgfTtcclxufVxyXG5cclxuIl19