import { Direction, escalateToToken, findMatchingBracket, getCharacterAtPos, getCloseBracket } from "src/utils/editor_utils";
import { Mode } from "../snippets/options";
import { getLatexSuiteConfig } from "../snippets/codemirror/config";
import { syntaxTree } from "@codemirror/language";
export class Context {
    state;
    mode;
    pos;
    ranges;
    codeblockLanguage;
    boundsCache;
    static fromState(state) {
        const ctx = new Context();
        const sel = state.selection;
        ctx.state = state;
        ctx.pos = sel.main.to;
        ctx.ranges = Array.from(sel.ranges).reverse(); // Last to first
        ctx.mode = new Mode();
        ctx.boundsCache = new Map();
        const codeblockLanguage = langIfWithinCodeblock(state) || '';
        const inCode = codeblockLanguage !== null;
        const settings = getLatexSuiteConfig(state);
        const forceMath = settings.forceMathLanguages.contains(codeblockLanguage);
        ctx.mode.codeMath = forceMath;
        ctx.mode.code = inCode && !forceMath;
        if (ctx.mode.code)
            ctx.codeblockLanguage = codeblockLanguage;
        // first, check if math mode should be "generally" on
        const inMath = forceMath || isWithinEquation(state);
        if (inMath && !forceMath) {
            const inInlineEquation = isWithinInlineEquation(state);
            ctx.mode.blockMath = !inInlineEquation;
            ctx.mode.inlineMath = inInlineEquation;
        }
        if (inMath) {
            ctx.mode.textEnv = ctx.inTextEnvironment();
        }
        ctx.mode.text = !inCode && !inMath;
        return ctx;
    }
    static fromView(view) {
        return Context.fromState(view.state);
    }
    isWithinEnvironment(pos, env) {
        if (!this.mode.inMath())
            return false;
        const bounds = this.getInnerBounds();
        if (!bounds)
            return false;
        const { start, end } = bounds;
        const text = this.state.sliceDoc(start, end);
        // pos referred to the absolute position in the whole document, but we just sliced the text
        // so now pos must be relative to the start in order to be any useful
        pos -= start;
        const openBracket = env.openSymbol.slice(-1);
        const closeBracket = getCloseBracket(openBracket);
        // Take care when the open symbol ends with a bracket {, [, or (
        // as then the closing symbol, }, ] or ), is not unique to this open symbol
        let offset;
        let openSearchSymbol;
        if (["{", "[", "("].contains(openBracket) && env.closeSymbol === closeBracket) {
            offset = env.openSymbol.length - 1;
            openSearchSymbol = openBracket;
        }
        else {
            offset = 0;
            openSearchSymbol = env.openSymbol;
        }
        let left = text.lastIndexOf(env.openSymbol, pos - 1);
        while (left != -1) {
            const right = findMatchingBracket(text, left + offset, openSearchSymbol, env.closeSymbol, false);
            if (right === -1)
                return false;
            // Check whether the cursor lies inside the environment symbols
            if ((right >= pos) && (pos >= left + env.openSymbol.length)) {
                return true;
            }
            if (left <= 0)
                return false;
            // Find the next open symbol
            left = text.lastIndexOf(env.openSymbol, left - 1);
        }
        return false;
    }
    inTextEnvironment() {
        return (this.isWithinEnvironment(this.pos, { openSymbol: "\\text{", closeSymbol: "}" }) ||
            this.isWithinEnvironment(this.pos, { openSymbol: "\\tag{", closeSymbol: "}" }) ||
            this.isWithinEnvironment(this.pos, { openSymbol: "\\begin{", closeSymbol: "}" }) ||
            this.isWithinEnvironment(this.pos, { openSymbol: "\\end{", closeSymbol: "}" }));
    }
    getBounds(pos = this.pos) {
        // yes, I also want the cache to work over the produced range instead of just that one through
        // a BTree or the like, but that'd be probably overkill
        if (this.boundsCache.has(pos)) {
            return this.boundsCache.get(pos) || null;
        }
        let bounds;
        if (this.mode.codeMath) {
            // means a codeblock language triggered the math mode -> use the codeblock bounds instead
            bounds = getCodeblockBounds(this.state, pos);
        }
        else {
            bounds = getEquationBounds(this.state);
        }
        if (bounds)
            this.boundsCache.set(pos, bounds);
        return bounds;
    }
    // Accounts for equations within text environments, e.g. $$\text{... $...$}$$
    getInnerBounds(pos = this.pos) {
        let bounds;
        if (this.mode.codeMath) {
            // means a codeblock language triggered the math mode -> use the codeblock bounds instead
            bounds = getCodeblockBounds(this.state, pos);
        }
        else {
            bounds = getInnerEquationBounds(this.state);
        }
        return bounds;
    }
}
const isWithinEquation = (state) => {
    const pos = state.selection.main.to;
    const tree = syntaxTree(state);
    let syntaxNode = tree.resolveInner(pos, -1);
    if (syntaxNode.name.contains("math-end"))
        return false;
    if (!syntaxNode.parent) {
        syntaxNode = tree.resolveInner(pos, 1);
        if (syntaxNode.name.contains("math-begin"))
            return false;
    }
    // Account/allow for being on an empty line in a equation
    if (!syntaxNode.parent) {
        const left = tree.resolveInner(pos - 1, -1);
        const right = tree.resolveInner(pos + 1, 1);
        return (left.name.contains("math") && right.name.contains("math") && !(left.name.contains("math-end")));
    }
    return (syntaxNode.name.contains("math"));
};
const isWithinInlineEquation = (state) => {
    const pos = state.selection.main.to;
    const tree = syntaxTree(state);
    let syntaxNode = tree.resolveInner(pos, -1);
    if (syntaxNode.name.contains("math-end"))
        return false;
    if (!syntaxNode.parent) {
        syntaxNode = tree.resolveInner(pos, 1);
        if (syntaxNode.name.contains("math-begin"))
            return false;
    }
    // Account/allow for being on an empty line in a equation
    if (!syntaxNode.parent)
        syntaxNode = tree.resolveInner(pos - 1, -1);
    const cursor = syntaxNode.cursor();
    const res = escalateToToken(cursor, Direction.Backward, "math-begin");
    return !res?.name.contains("math-block");
};
/**
 * Figures out where this equation starts and where it ends.
 *
 * **Note:** If you intend to use this directly, check out Context.getBounds instead, which caches and also takes care of codeblock languages which should behave like math mode.
 */
export const getEquationBounds = (state, pos) => {
    if (!pos)
        pos = state.selection.main.to;
    const tree = syntaxTree(state);
    let syntaxNode = tree.resolveInner(pos, -1);
    if (!syntaxNode.parent) {
        syntaxNode = tree.resolveInner(pos, 1);
    }
    // Account/allow for being on an empty line in a equation
    if (!syntaxNode.parent)
        syntaxNode = tree.resolveInner(pos - 1, -1);
    const cursor = syntaxNode.cursor();
    const begin = escalateToToken(cursor, Direction.Backward, "math-begin");
    const end = escalateToToken(cursor, Direction.Forward, "math-end");
    if (begin && end) {
        return { start: begin.to, end: end.from };
    }
    else {
        return null;
    }
};
// Accounts for equations within text environments, e.g. $$\text{... $...$}$$
const getInnerEquationBounds = (state, pos) => {
    if (!pos)
        pos = state.selection.main.to;
    let text = state.doc.toString();
    // ignore \$
    text = text.replaceAll("\\$", "\\R");
    const left = text.lastIndexOf("$", pos - 1);
    const right = text.indexOf("$", pos);
    if (left === -1 || right === -1)
        return null;
    return { start: left + 1, end: right };
};
/**
 * Figures out where this codeblock starts and where it ends.
 *
 * **Note:** If you intend to use this directly, check out Context.getBounds instead, which caches and also takes care of codeblock languages which should behave like math mode.
 */
const getCodeblockBounds = (state, pos = state.selection.main.from) => {
    const tree = syntaxTree(state);
    let cursor = tree.cursorAt(pos, -1);
    const blockBegin = escalateToToken(cursor, Direction.Backward, "HyperMD-codeblock-begin");
    cursor = tree.cursorAt(pos, -1);
    const blockEnd = escalateToToken(cursor, Direction.Forward, "HyperMD-codeblock-end");
    if (blockBegin && blockEnd)
        return { start: blockBegin.to + 1, end: blockEnd.from - 1 };
    return null;
};
const langIfWithinCodeblock = (state) => {
    const tree = syntaxTree(state);
    const pos = state.selection.ranges[0].from;
    /*
    * get a tree cursor at the position
    *
    * A newline does not belong to any syntax nodes except for the Document,
    * which corresponds to the whole document. So, we change the `mode` of the
    * `cursorAt` depending on whether the character just before the cursor is a
    * newline.
    */
    const cursor = pos === 0 || getCharacterAtPos(state, pos - 1) === "\n"
        ? tree.cursorAt(pos, 1)
        : tree.cursorAt(pos, -1);
    // check if we're in a codeblock atm at all
    const inCodeblock = cursor.name.contains("codeblock");
    if (!inCodeblock) {
        return null;
    }
    // locate the start of the block
    const codeblockBegin = escalateToToken(cursor, Direction.Backward, "HyperMD-codeblock_HyperMD-codeblock-begin");
    if (codeblockBegin == null) {
        console.warn("unable to locate start of the codeblock even though inside one");
        return "";
    }
    // extract the language
    // codeblocks may start and end with an arbitrary number of backticks
    const language = state.sliceDoc(codeblockBegin.from, codeblockBegin.to).replace(/`+/, "");
    return language;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9jb250ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzdILE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUUzQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFPbEQsTUFBTSxPQUFPLE9BQU87SUFDbkIsS0FBSyxDQUFjO0lBQ25CLElBQUksQ0FBUTtJQUNaLEdBQUcsQ0FBUztJQUNaLE1BQU0sQ0FBbUI7SUFDekIsaUJBQWlCLENBQVM7SUFDMUIsV0FBVyxDQUFzQjtJQUVqQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQWtCO1FBQ2xDLE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFDMUIsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUM1QixHQUFHLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNsQixHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ3RCLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxnQkFBZ0I7UUFDL0QsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ3RCLEdBQUcsQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUU1QixNQUFNLGlCQUFpQixHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxJQUFFLEVB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QUFJLEVBQUUsQ0FBQztRQUM1QixPQUFPLENBQUMsSUFBSSxDQUFDLGdFQUFnRSxDQUFDLENBQUM7UUFDL0UsT0FBTyxFQUFFLENBQUM7SUFDWCxDQUFDO0lBRUQsdUJBQXVCO0lBQ3ZCLHFFQUFxRTtJQUNyRSxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFMUYsT0FBTyxRQUFRLENBQUM7QUFDakIsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFNlbGVjdGlvblJhbmdlIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XHJcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb24sIGVzY2FsYXRlVG9Ub2tlbiwgZmluZE1hdGNoaW5nQnJhY2tldCwgZ2V0Q2hhcmFjdGVyQXRQb3MsIGdldENsb3NlQnJhY2tldCB9IGZyb20gXCJzcmMvdXRpbHMvZWRpdG9yX3V0aWxzXCI7XHJcbmltcG9ydCB7IE1vZGUgfSBmcm9tIFwiLi4vc25pcHBldHMvb3B0aW9uc1wiO1xyXG5pbXBvcnQgeyBFbnZpcm9ubWVudCB9IGZyb20gXCIuLi9zbmlwcGV0cy9lbnZpcm9ubWVudFwiO1xyXG5pbXBvcnQgeyBnZXRMYXRleFN1aXRlQ29uZmlnIH0gZnJvbSBcIi4uL3NuaXBwZXRzL2NvZGVtaXJyb3IvY29uZmlnXCI7XHJcbmltcG9ydCB7IHN5bnRheFRyZWUgfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQm91bmRzIHtcclxuXHRzdGFydDogbnVtYmVyO1xyXG5cdGVuZDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQ29udGV4dCB7XHJcblx0c3RhdGU6IEVkaXRvclN0YXRlO1xyXG5cdG1vZGUhOiBNb2RlO1xyXG5cdHBvczogbnVtYmVyO1xyXG5cdHJhbmdlczogU2VsZWN0aW9uUmFuZ2VbXTtcclxuXHRjb2RlYmxvY2tMYW5ndWFnZTogc3RyaW5nO1xyXG5cdGJvdW5kc0NhY2hlOiBNYXA8bnVtYmVyLCBCb3VuZHM+O1xyXG5cclxuXHRzdGF0aWMgZnJvbVN0YXRlKHN0YXRlOiBFZGl0b3JTdGF0ZSk6Q29udGV4dCB7XHJcblx0XHRjb25zdCBjdHggPSBuZXcgQ29udGV4dCgpO1xyXG5cdFx0Y29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xyXG5cdFx0Y3R4LnN0YXRlID0gc3RhdGU7XHJcblx0XHRjdHgucG9zID0gc2VsLm1haW4udG87XHJcblx0XHRjdHgucmFuZ2VzID0gQXJyYXkuZnJvbShzZWwucmFuZ2VzKS5yZXZlcnNlKCk7IC8vIExhc3QgdG8gZmlyc3RcclxuXHRcdGN0eC5tb2RlID0gbmV3IE1vZGUoKTtcclxuXHRcdGN0eC5ib3VuZHNDYWNoZSA9IG5ldyBNYXAoKTtcclxuXHJcblx0XHRjb25zdCBjb2RlYmxvY2tMYW5ndWFnZSA9IGxhbmdJZldpdGhpbkNvZGVibG9jayhzdGF0ZSl8fCcnO1xyXG5cdFx0Y29uc3QgaW5Db2RlID0gY29kZWJsb2NrTGFuZ3VhZ2UgIT09IG51bGw7XHJcblxyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSBnZXRMYXRleFN1aXRlQ29uZmlnKHN0YXRlKTtcclxuXHRcdGNvbnN0IGZvcmNlTWF0aCA9IHNldHRpbmdzLmZvcmNlTWF0aExhbmd1YWdlcy5jb250YWlucyhjb2RlYmxvY2tMYW5ndWFnZSk7XHJcblx0XHRjdHgubW9kZS5jb2RlTWF0aCA9IGZvcmNlTWF0aDtcclxuXHRcdGN0eC5tb2RlLmNvZGUgPSBpbkNvZGUgJiYgIWZvcmNlTWF0aDtcclxuXHRcdGlmIChjdHgubW9kZS5jb2RlKSBjdHguY29kZWJsb2NrTGFuZ3VhZ2UgPSBjb2RlYmxvY2tMYW5ndWFnZTtcclxuXHJcblx0XHQvLyBmaXJzdCwgY2hlY2sgaWYgbWF0aCBtb2RlIHNob3VsZCBiZSBcImdlbmVyYWxseVwiIG9uXHJcblx0XHRjb25zdCBpbk1hdGggPSBmb3JjZU1hdGggfHwgaXNXaXRoaW5FcXVhdGlvbihzdGF0ZSk7XHJcblxyXG5cdFx0aWYgKGluTWF0aCAmJiAhZm9yY2VNYXRoKSB7XHJcblx0XHRcdGNvbnN0IGluSW5saW5lRXF1YXRpb24gPSBpc1dpdGhpbklubGluZUVxdWF0aW9uKHN0YXRlKTtcclxuXHJcblx0XHRcdGN0eC5tb2RlLmJsb2NrTWF0aCA9ICFpbklubGluZUVxdWF0aW9uO1xyXG5cdFx0XHRjdHgubW9kZS5pbmxpbmVNYXRoID0gaW5JbmxpbmVFcXVhdGlvbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW5NYXRoKSB7XHJcblx0XHRcdGN0eC5tb2RlLnRleHRFbnYgPSBjdHguaW5UZXh0RW52aXJvbm1lbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjdHgubW9kZS50ZXh0ID0gIWluQ29kZSAmJiAhaW5NYXRoO1xyXG5cclxuXHRcdHJldHVybiBjdHg7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbVZpZXcodmlldzogRWRpdG9yVmlldyk6Q29udGV4dCB7XHJcblx0XHRyZXR1cm4gQ29udGV4dC5mcm9tU3RhdGUodmlldy5zdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRpc1dpdGhpbkVudmlyb25tZW50KHBvczogbnVtYmVyLCBlbnY6IEVudmlyb25tZW50KTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXRoaXMubW9kZS5pbk1hdGgoKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0SW5uZXJCb3VuZHMoKTtcclxuXHRcdGlmICghYm91bmRzKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3Qge3N0YXJ0LCBlbmR9ID0gYm91bmRzO1xyXG5cdFx0Y29uc3QgdGV4dCA9IHRoaXMuc3RhdGUuc2xpY2VEb2Moc3RhcnQsIGVuZCk7XHJcblx0XHQvLyBwb3MgcmVmZXJyZWQgdG8gdGhlIGFic29sdXRlIHBvc2l0aW9uIGluIHRoZSB3aG9sZSBkb2N1bWVudCwgYnV0IHdlIGp1c3Qgc2xpY2VkIHRoZSB0ZXh0XHJcblx0XHQvLyBzbyBub3cgcG9zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IGluIG9yZGVyIHRvIGJlIGFueSB1c2VmdWxcclxuXHRcdHBvcyAtPSBzdGFydDtcclxuXHJcblx0XHRjb25zdCBvcGVuQnJhY2tldCA9IGVudi5vcGVuU3ltYm9sLnNsaWNlKC0xKTtcclxuXHRcdGNvbnN0IGNsb3NlQnJhY2tldCA9IGdldENsb3NlQnJhY2tldChvcGVuQnJhY2tldCk7XHJcblxyXG5cdFx0Ly8gVGFrZSBjYXJlIHdoZW4gdGhlIG9wZW4gc3ltYm9sIGVuZHMgd2l0aCBhIGJyYWNrZXQgeywgWywgb3IgKFxyXG5cdFx0Ly8gYXMgdGhlbiB0aGUgY2xvc2luZyBzeW1ib2wsIH0sIF0gb3IgKSwgaXMgbm90IHVuaXF1ZSB0byB0aGlzIG9wZW4gc3ltYm9sXHJcblx0XHRsZXQgb2Zmc2V0O1xyXG5cdFx0bGV0IG9wZW5TZWFyY2hTeW1ib2w7XHJcblxyXG5cdFx0aWYgKFtcIntcIiwgXCJbXCIsIFwiKFwiXS5jb250YWlucyhvcGVuQnJhY2tldCkgJiYgZW52LmNsb3NlU3ltYm9sID09PSBjbG9zZUJyYWNrZXQpIHtcclxuXHRcdFx0b2Zmc2V0ID0gZW52Lm9wZW5TeW1ib2wubGVuZ3RoIC0gMTtcclxuXHRcdFx0b3BlblNlYXJjaFN5bWJvbCA9IG9wZW5CcmFja2V0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0b3BlblNlYXJjaFN5bWJvbCA9IGVudi5vcGVuU3ltYm9sO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0ID0gdGV4dC5sYXN0SW5kZXhPZihlbnYub3BlblN5bWJvbCwgcG9zIC0gMSk7XHJcblxyXG5cdFx0d2hpbGUgKGxlZnQgIT0gLTEpIHtcclxuXHRcdFx0Y29uc3QgcmlnaHQgPSBmaW5kTWF0Y2hpbmdCcmFja2V0KHRleHQsIGxlZnQgKyBvZmZzZXQsIG9wZW5TZWFyY2hTeW1ib2wsIGVudi5jbG9zZVN5bWJvbCwgZmFsc2UpO1xyXG5cclxuXHRcdFx0aWYgKHJpZ2h0ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGxpZXMgaW5zaWRlIHRoZSBlbnZpcm9ubWVudCBzeW1ib2xzXHJcblx0XHRcdGlmICgocmlnaHQgPj0gcG9zKSAmJiAocG9zID49IGxlZnQgKyBlbnYub3BlblN5bWJvbC5sZW5ndGgpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsZWZ0IDw9IDApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdC8vIEZpbmQgdGhlIG5leHQgb3BlbiBzeW1ib2xcclxuXHRcdFx0bGVmdCA9IHRleHQubGFzdEluZGV4T2YoZW52Lm9wZW5TeW1ib2wsIGxlZnQgLSAxKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRpblRleHRFbnZpcm9ubWVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdHRoaXMuaXNXaXRoaW5FbnZpcm9ubWVudCh0aGlzLnBvcywge29wZW5TeW1ib2w6IFwiXFxcXHRleHR7XCIsIGNsb3NlU3ltYm9sOiBcIn1cIn0pIHx8XHJcblx0XHRcdHRoaXMuaXNXaXRoaW5FbnZpcm9ubWVudCh0aGlzLnBvcywge29wZW5TeW1ib2w6IFwiXFxcXHRhZ3tcIiwgY2xvc2VTeW1ib2w6IFwifVwifSkgfHxcclxuXHRcdFx0dGhpcy5pc1dpdGhpbkVudmlyb25tZW50KHRoaXMucG9zLCB7b3BlblN5bWJvbDogXCJcXFxcYmVnaW57XCIsIGNsb3NlU3ltYm9sOiBcIn1cIn0pIHx8XHJcblx0XHRcdHRoaXMuaXNXaXRoaW5FbnZpcm9ubWVudCh0aGlzLnBvcywge29wZW5TeW1ib2w6IFwiXFxcXGVuZHtcIiwgY2xvc2VTeW1ib2w6IFwifVwifSlcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRnZXRCb3VuZHMocG9zOiBudW1iZXIgPSB0aGlzLnBvcyk6IEJvdW5kc3xudWxsIHtcclxuXHRcdC8vIHllcywgSSBhbHNvIHdhbnQgdGhlIGNhY2hlIHRvIHdvcmsgb3ZlciB0aGUgcHJvZHVjZWQgcmFuZ2UgaW5zdGVhZCBvZiBqdXN0IHRoYXQgb25lIHRocm91Z2hcclxuXHRcdC8vIGEgQlRyZWUgb3IgdGhlIGxpa2UsIGJ1dCB0aGF0J2QgYmUgcHJvYmFibHkgb3ZlcmtpbGxcclxuXHRcdGlmICh0aGlzLmJvdW5kc0NhY2hlLmhhcyhwb3MpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmJvdW5kc0NhY2hlLmdldChwb3MpfHxudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBib3VuZHM7XHJcblx0XHRpZiAodGhpcy5tb2RlLmNvZGVNYXRoKSB7XHJcblx0XHRcdC8vIG1lYW5zIGEgY29kZWJsb2NrIGxhbmd1YWdlIHRyaWdnZXJlZCB0aGUgbWF0aCBtb2RlIC0+IHVzZSB0aGUgY29kZWJsb2NrIGJvdW5kcyBpbnN0ZWFkXHJcblx0XHRcdGJvdW5kcyA9IGdldENvZGVibG9ja0JvdW5kcyh0aGlzLnN0YXRlLCBwb3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ym91bmRzID0gZ2V0RXF1YXRpb25Cb3VuZHModGhpcy5zdGF0ZSk7XHJcblx0XHR9XHJcblx0XHRpZihib3VuZHMpXHJcblx0XHR0aGlzLmJvdW5kc0NhY2hlLnNldChwb3MsIGJvdW5kcyk7XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxuXHJcblx0Ly8gQWNjb3VudHMgZm9yIGVxdWF0aW9ucyB3aXRoaW4gdGV4dCBlbnZpcm9ubWVudHMsIGUuZy4gJCRcXHRleHR7Li4uICQuLi4kfSQkXHJcblx0Z2V0SW5uZXJCb3VuZHMocG9zOiBudW1iZXIgPSB0aGlzLnBvcyk6IEJvdW5kc3xudWxsIHtcclxuXHRcdGxldCBib3VuZHM7XHJcblx0XHRpZiAodGhpcy5tb2RlLmNvZGVNYXRoKSB7XHJcblx0XHRcdC8vIG1lYW5zIGEgY29kZWJsb2NrIGxhbmd1YWdlIHRyaWdnZXJlZCB0aGUgbWF0aCBtb2RlIC0+IHVzZSB0aGUgY29kZWJsb2NrIGJvdW5kcyBpbnN0ZWFkXHJcblx0XHRcdGJvdW5kcyA9IGdldENvZGVibG9ja0JvdW5kcyh0aGlzLnN0YXRlLCBwb3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ym91bmRzID0gZ2V0SW5uZXJFcXVhdGlvbkJvdW5kcyh0aGlzLnN0YXRlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IGlzV2l0aGluRXF1YXRpb24gPSAoc3RhdGU6IEVkaXRvclN0YXRlKTpib29sZWFuID0+IHtcclxuXHRjb25zdCBwb3MgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi50bztcclxuXHRjb25zdCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSk7XHJcblxyXG5cdGxldCBzeW50YXhOb2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XHJcblx0aWYgKHN5bnRheE5vZGUubmFtZS5jb250YWlucyhcIm1hdGgtZW5kXCIpKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdGlmICghc3ludGF4Tm9kZS5wYXJlbnQpIHtcclxuXHRcdHN5bnRheE5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIDEpO1xyXG5cdFx0aWYgKHN5bnRheE5vZGUubmFtZS5jb250YWlucyhcIm1hdGgtYmVnaW5cIikpIHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8vIEFjY291bnQvYWxsb3cgZm9yIGJlaW5nIG9uIGFuIGVtcHR5IGxpbmUgaW4gYSBlcXVhdGlvblxyXG5cdGlmICghc3ludGF4Tm9kZS5wYXJlbnQpIHtcclxuXHRcdGNvbnN0IGxlZnQgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MgLSAxLCAtMSk7XHJcblx0XHRjb25zdCByaWdodCA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcyArIDEsIDEpO1xyXG5cclxuXHRcdHJldHVybiAobGVmdC5uYW1lLmNvbnRhaW5zKFwibWF0aFwiKSAmJiByaWdodC5uYW1lLmNvbnRhaW5zKFwibWF0aFwiKSAmJiAhKGxlZnQubmFtZS5jb250YWlucyhcIm1hdGgtZW5kXCIpKSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gKHN5bnRheE5vZGUubmFtZS5jb250YWlucyhcIm1hdGhcIikpO1xyXG59XHJcblxyXG5jb25zdCBpc1dpdGhpbklubGluZUVxdWF0aW9uID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSk6Ym9vbGVhbiA9PiB7XHJcblx0Y29uc3QgcG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4udG87XHJcblx0Y29uc3QgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xyXG5cclxuXHRsZXQgc3ludGF4Tm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xyXG5cdGlmIChzeW50YXhOb2RlLm5hbWUuY29udGFpbnMoXCJtYXRoLWVuZFwiKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRpZiAoIXN5bnRheE5vZGUucGFyZW50KSB7XHJcblx0XHRzeW50YXhOb2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCAxKTtcclxuXHRcdGlmIChzeW50YXhOb2RlLm5hbWUuY29udGFpbnMoXCJtYXRoLWJlZ2luXCIpKSByZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBBY2NvdW50L2FsbG93IGZvciBiZWluZyBvbiBhbiBlbXB0eSBsaW5lIGluIGEgZXF1YXRpb25cclxuXHRpZiAoIXN5bnRheE5vZGUucGFyZW50KSBzeW50YXhOb2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zIC0gMSwgLTEpO1xyXG5cclxuXHRjb25zdCBjdXJzb3IgPSBzeW50YXhOb2RlLmN1cnNvcigpO1xyXG5cdGNvbnN0IHJlcyA9IGVzY2FsYXRlVG9Ub2tlbihjdXJzb3IsIERpcmVjdGlvbi5CYWNrd2FyZCwgXCJtYXRoLWJlZ2luXCIpO1xyXG5cclxuXHRyZXR1cm4gIXJlcz8ubmFtZS5jb250YWlucyhcIm1hdGgtYmxvY2tcIik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWd1cmVzIG91dCB3aGVyZSB0aGlzIGVxdWF0aW9uIHN0YXJ0cyBhbmQgd2hlcmUgaXQgZW5kcy5cclxuICpcclxuICogKipOb3RlOioqIElmIHlvdSBpbnRlbmQgdG8gdXNlIHRoaXMgZGlyZWN0bHksIGNoZWNrIG91dCBDb250ZXh0LmdldEJvdW5kcyBpbnN0ZWFkLCB3aGljaCBjYWNoZXMgYW5kIGFsc28gdGFrZXMgY2FyZSBvZiBjb2RlYmxvY2sgbGFuZ3VhZ2VzIHdoaWNoIHNob3VsZCBiZWhhdmUgbGlrZSBtYXRoIG1vZGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RXF1YXRpb25Cb3VuZHMgPSAoc3RhdGU6IEVkaXRvclN0YXRlLCBwb3M/OiBudW1iZXIpOkJvdW5kc3xudWxsID0+IHtcclxuXHRpZiAoIXBvcykgcG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4udG87XHJcblx0Y29uc3QgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xyXG5cclxuXHRsZXQgc3ludGF4Tm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xyXG5cclxuXHRpZiAoIXN5bnRheE5vZGUucGFyZW50KSB7XHJcblx0XHRzeW50YXhOb2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCAxKTtcclxuXHR9XHJcblxyXG5cdC8vIEFjY291bnQvYWxsb3cgZm9yIGJlaW5nIG9uIGFuIGVtcHR5IGxpbmUgaW4gYSBlcXVhdGlvblxyXG5cdGlmICghc3ludGF4Tm9kZS5wYXJlbnQpIHN5bnRheE5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MgLSAxLCAtMSk7XHJcblxyXG5cdGNvbnN0IGN1cnNvciA9IHN5bnRheE5vZGUuY3Vyc29yKCk7XHJcblx0Y29uc3QgYmVnaW4gPSBlc2NhbGF0ZVRvVG9rZW4oY3Vyc29yLCBEaXJlY3Rpb24uQmFja3dhcmQsIFwibWF0aC1iZWdpblwiKTtcclxuXHRjb25zdCBlbmQgPSBlc2NhbGF0ZVRvVG9rZW4oY3Vyc29yLCBEaXJlY3Rpb24uRm9yd2FyZCwgXCJtYXRoLWVuZFwiKTtcclxuXHJcblx0aWYgKGJlZ2luICYmIGVuZCkge1xyXG5cdFx0cmV0dXJuIHtzdGFydDogYmVnaW4udG8sIGVuZDogZW5kLmZyb219O1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQWNjb3VudHMgZm9yIGVxdWF0aW9ucyB3aXRoaW4gdGV4dCBlbnZpcm9ubWVudHMsIGUuZy4gJCRcXHRleHR7Li4uICQuLi4kfSQkXHJcbmNvbnN0IGdldElubmVyRXF1YXRpb25Cb3VuZHMgPSAoc3RhdGU6IEVkaXRvclN0YXRlLCBwb3M/OiBudW1iZXIpOkJvdW5kc3xudWxsID0+IHtcclxuXHRpZiAoIXBvcykgcG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4udG87XHJcblx0bGV0IHRleHQgPSBzdGF0ZS5kb2MudG9TdHJpbmcoKTtcclxuXHJcblx0Ly8gaWdub3JlIFxcJFxyXG5cdHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJcXFxcJFwiLCBcIlxcXFxSXCIpO1xyXG5cclxuXHRjb25zdCBsZWZ0ID0gdGV4dC5sYXN0SW5kZXhPZihcIiRcIiwgcG9zLTEpO1xyXG5cdGNvbnN0IHJpZ2h0ID0gdGV4dC5pbmRleE9mKFwiJFwiLCBwb3MpO1xyXG5cclxuXHRpZiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSByZXR1cm4gbnVsbDtcclxuXHJcblx0cmV0dXJuIHtzdGFydDogbGVmdCArIDEsIGVuZDogcmlnaHR9O1xyXG59XHJcblxyXG4vKipcclxuICogRmlndXJlcyBvdXQgd2hlcmUgdGhpcyBjb2RlYmxvY2sgc3RhcnRzIGFuZCB3aGVyZSBpdCBlbmRzLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogSWYgeW91IGludGVuZCB0byB1c2UgdGhpcyBkaXJlY3RseSwgY2hlY2sgb3V0IENvbnRleHQuZ2V0Qm91bmRzIGluc3RlYWQsIHdoaWNoIGNhY2hlcyBhbmQgYWxzbyB0YWtlcyBjYXJlIG9mIGNvZGVibG9jayBsYW5ndWFnZXMgd2hpY2ggc2hvdWxkIGJlaGF2ZSBsaWtlIG1hdGggbW9kZS5cclxuICovXHJcbmNvbnN0IGdldENvZGVibG9ja0JvdW5kcyA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIHBvczogbnVtYmVyID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSk6Qm91bmRzfG51bGwgPT4ge1xyXG5cdGNvbnN0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcclxuXHJcblx0bGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yQXQocG9zLCAtMSk7XHJcblx0Y29uc3QgYmxvY2tCZWdpbiA9IGVzY2FsYXRlVG9Ub2tlbihjdXJzb3IsIERpcmVjdGlvbi5CYWNrd2FyZCwgXCJIeXBlck1ELWNvZGVibG9jay1iZWdpblwiKTtcclxuXHJcblx0Y3Vyc29yID0gdHJlZS5jdXJzb3JBdChwb3MsIC0xKTtcclxuXHRjb25zdCBibG9ja0VuZCA9IGVzY2FsYXRlVG9Ub2tlbihjdXJzb3IsIERpcmVjdGlvbi5Gb3J3YXJkLCBcIkh5cGVyTUQtY29kZWJsb2NrLWVuZFwiKTtcclxuXHRpZiAoYmxvY2tCZWdpbiYmYmxvY2tFbmQpXHJcblx0cmV0dXJuIHsgc3RhcnQ6IGJsb2NrQmVnaW4udG8gKyAxLCBlbmQ6IGJsb2NrRW5kLmZyb20gLSAxIH07XHJcblx0cmV0dXJuIG51bGxcclxufVxyXG5cclxuY29uc3QgbGFuZ0lmV2l0aGluQ29kZWJsb2NrID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG5cdGNvbnN0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcclxuXHJcblx0Y29uc3QgcG9zID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1swXS5mcm9tO1xyXG5cclxuXHQvKlxyXG5cdCogZ2V0IGEgdHJlZSBjdXJzb3IgYXQgdGhlIHBvc2l0aW9uXHJcblx0KlxyXG5cdCogQSBuZXdsaW5lIGRvZXMgbm90IGJlbG9uZyB0byBhbnkgc3ludGF4IG5vZGVzIGV4Y2VwdCBmb3IgdGhlIERvY3VtZW50LFxyXG5cdCogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIHdob2xlIGRvY3VtZW50LiBTbywgd2UgY2hhbmdlIHRoZSBgbW9kZWAgb2YgdGhlXHJcblx0KiBgY3Vyc29yQXRgIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIganVzdCBiZWZvcmUgdGhlIGN1cnNvciBpcyBhXHJcblx0KiBuZXdsaW5lLlxyXG5cdCovXHJcblx0Y29uc3QgY3Vyc29yID1cclxuXHRcdHBvcyA9PT0gMCB8fCBnZXRDaGFyYWN0ZXJBdFBvcyhzdGF0ZSwgcG9zIC0gMSkgPT09IFwiXFxuXCJcclxuXHRcdD8gdHJlZS5jdXJzb3JBdChwb3MsIDEpXHJcblx0XHQ6IHRyZWUuY3Vyc29yQXQocG9zLCAtMSk7XHJcblxyXG5cdC8vIGNoZWNrIGlmIHdlJ3JlIGluIGEgY29kZWJsb2NrIGF0bSBhdCBhbGxcclxuXHRjb25zdCBpbkNvZGVibG9jayA9IGN1cnNvci5uYW1lLmNvbnRhaW5zKFwiY29kZWJsb2NrXCIpO1xyXG5cdGlmICghaW5Db2RlYmxvY2spIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0Ly8gbG9jYXRlIHRoZSBzdGFydCBvZiB0aGUgYmxvY2tcclxuXHRjb25zdCBjb2RlYmxvY2tCZWdpbiA9IGVzY2FsYXRlVG9Ub2tlbihjdXJzb3IsIERpcmVjdGlvbi5CYWNrd2FyZCwgXCJIeXBlck1ELWNvZGVibG9ja19IeXBlck1ELWNvZGVibG9jay1iZWdpblwiKTtcclxuXHJcblx0aWYgKGNvZGVibG9ja0JlZ2luID09IG51bGwpIHtcclxuXHRcdGNvbnNvbGUud2FybihcInVuYWJsZSB0byBsb2NhdGUgc3RhcnQgb2YgdGhlIGNvZGVibG9jayBldmVuIHRob3VnaCBpbnNpZGUgb25lXCIpO1xyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cclxuXHQvLyBleHRyYWN0IHRoZSBsYW5ndWFnZVxyXG5cdC8vIGNvZGVibG9ja3MgbWF5IHN0YXJ0IGFuZCBlbmQgd2l0aCBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGJhY2t0aWNrc1xyXG5cdGNvbnN0IGxhbmd1YWdlID0gc3RhdGUuc2xpY2VEb2MoY29kZWJsb2NrQmVnaW4uZnJvbSwgY29kZWJsb2NrQmVnaW4udG8pLnJlcGxhY2UoL2ArLywgXCJcIik7XHJcblxyXG5cdHJldHVybiBsYW5ndWFnZTtcclxufVxyXG4iXX0=