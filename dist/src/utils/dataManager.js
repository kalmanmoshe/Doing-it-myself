import { regExp } from "src/tikzjax/tikzjax";
import { brackets, mathJaxOperators, operatorsWithImplicitMultiplication, tikzComponents } from "./staticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return tikzComponents
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return tikzComponents.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperators, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchMathJaxOperators(query) {
    return mathJaxOperators.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
export function getAllMathJaxReferences() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function getAllMathJaxOperators() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((operator) => operator.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperators
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Retrieves operators by associativity (side).
 * @param {string} side - The associativity to filter by (e.g., 'left', 'right', 'both').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    return mathJaxOperators
        .filter((operator) => operator.associativity === side)
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {string} bracket - The bracket type to filter by (e.g., 'none', 'left', 'right').
 * @returns {string[]} - Array of operator names matching the specified bracket type.
 */
export function getOperatorsByBracket(bracket) {
    return mathJaxOperators
        .filter((operator) => operator.bracket === bracket)
        .map((operator) => operator.name);
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperators.find((op) => op.name === operatorName);
    return operator ? operatorsWithImplicitMultiplication.includes(operator.type) : false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZGF0YU1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsbUNBQW1DLEVBQUUsY0FBYyxFQUFTLE1BQU0sY0FBYyxDQUFDO0FBRXRIOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUNsRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQjtJQUNoQyxPQUFPLGNBQWM7U0FDaEIsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNsRCxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBYTtJQUM5QyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQzNDLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssS0FBSyxDQUMvQyxDQUNKLENBQUM7QUFDTixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBYTtJQUN2QyxPQUFPLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FB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QyxDQUFDLEtBQUssQ0FBQztBQUMxRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnRXhwIH0gZnJvbSBcInNyYy90aWt6amF4L3Rpa3pqYXhcIjtcclxuaW1wb3J0IHsgYnJhY2tldHMsIG1hdGhKYXhPcGVyYXRvcnMsIG9wZXJhdG9yc1dpdGhJbXBsaWNpdE11bHRpcGxpY2F0aW9uLCB0aWt6Q29tcG9uZW50cywgdW5pdHMgfSBmcm9tIFwiLi9zdGF0aWNEYXRhXCI7XHJcblxyXG4vKipcclxuICogRXNjYXBlcyBhIHN0cmluZyBmb3Igc2FmZSB1c2UgaW4gYSByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZXNjYXBlZCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXNjYXBlRm9yUmVnZXggPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIFRpa1ogY29tcG9uZW50cyBhcyBhbiBhcnJheSBvZiByZWdleC1yZWFkeSBzdHJpbmdzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXNjYXBlZCBUaWtaIGNvbXBvbmVudCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFRpa3pSZWZlcmVuY2VzKCkge1xyXG4gICAgcmV0dXJuIHRpa3pDb21wb25lbnRzXHJcbiAgICAgICAgLmZsYXRNYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnJlZmVyZW5jZXMgfHwgW10pXHJcbiAgICAgICAgLm1hcChlc2NhcGVGb3JSZWdleCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBUaWtaIGNvbXBvbmVudHMgZm9yIGEgc3BlY2lmaWMgcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgdW5kZWZpbmVkfSAtIFRoZSBtYXRjaGVkIFRpa1ogY29tcG9uZW50IG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoVGlrekNvbXBvbmVudHMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRpa3pDb21wb25lbnRzLmZpbmQoKGNvbXBvbmVudCkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKGNvbXBvbmVudCkuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBxdWVyeVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBzeW1ib2xzIChtYXRoIG9wZXJhdG9ycyBhbmQgYnJhY2tldHMpIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBzeW1ib2wgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hTeW1ib2xzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywgLi4uYnJhY2tldHNdLmZpbmQoKHN5bWJvbCkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKHN5bWJvbCkuc29tZSgodmFsdWUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXHJcbiAgICAgICAgKVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIG1hdGggb3BlcmF0b3JzIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBvcGVyYXRvciBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaE1hdGhKYXhPcGVyYXRvcnMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnMuZmluZCgob3BlcmF0b3IpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhvcGVyYXRvcikuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1hdGhKYXhSZWZlcmVuY2VzKCkge1xyXG4gICAgcmV0dXJuIFsuLi5tYXRoSmF4T3BlcmF0b3JzLC4uLmJyYWNrZXRzXVxyXG4gICAgICAgIC5mbGF0TWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC5yZWZlcmVuY2VzIHx8IFtdKVxyXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIE1hdGhKYXggb3BlcmF0b3JzIGFuZCBicmFja2V0cyBhcyByZWdleC1yZWFkeSBzdHJpbmdzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXNjYXBlZCBNYXRoSmF4IG9wZXJhdG9yIGFuZCBicmFja2V0IHJlZmVyZW5jZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWF0aEpheE9wZXJhdG9ycygpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywgLi4uYnJhY2tldHNdXHJcbiAgICAgICAgLmZsYXRNYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5yZWZlcmVuY2VzIHx8IFtdKVxyXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIE1hdGhKYXggb3BlcmF0b3JzIGJ5IHByaW9yaXR5IGxldmVsLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlMZXZlbCAtIFRoZSBwcmlvcml0eSBsZXZlbCB0byBmaWx0ZXIgYnkuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9SZWdleCAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRzIGFzIHJlZ2V4LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW10gfCBSZWdFeHBbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBvciByZWdleCBwYXR0ZXJucy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRoSmF4T3BlcmF0b3JzQnlQcmlvcml0eShwcmlvcml0eUxldmVsOiBudW1iZXIsIHRvUmVnZXggPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJpb3JpdGl6ZWQgPSBtYXRoSmF4T3BlcmF0b3JzXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLnByaW9yaXR5ID09PSBwcmlvcml0eUxldmVsKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxuICAgIHJldHVybiB0b1JlZ2V4ID8gcmVnRXhwKHByaW9yaXRpemVkKSA6IHByaW9yaXRpemVkO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIG9wZXJhdG9ycyBieSBhc3NvY2lhdGl2aXR5IChzaWRlKS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNpZGUgLSBUaGUgYXNzb2NpYXRpdml0eSB0byBmaWx0ZXIgYnkgKGUuZy4sICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdGgnKS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2lkZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvcnNCeUFzc29jaWF0aXZpdHkoc2lkZTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc1xyXG4gICAgICAgIC5maWx0ZXIoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBzaWRlKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBvcGVyYXRvcnMgYnkgYnJhY2tldCB0eXBlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhY2tldCAtIFRoZSBicmFja2V0IHR5cGUgdG8gZmlsdGVyIGJ5IChlLmcuLCAnbm9uZScsICdsZWZ0JywgJ3JpZ2h0JykuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGJyYWNrZXQgdHlwZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvcnNCeUJyYWNrZXQoYnJhY2tldDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc1xyXG4gICAgICAgIC5maWx0ZXIoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5icmFja2V0ID09PSBicmFja2V0KVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBvcGVyYXRvciBoYXMgaW1wbGljaXQgbXVsdGlwbGljYXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIG9wZXJhdG9yIGhhcyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ltcGxpY2l0TXVsdGlwbGljYXRpb24ob3BlcmF0b3JOYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IG9wZXJhdG9yID0gbWF0aEpheE9wZXJhdG9ycy5maW5kKChvcCkgPT4gb3AubmFtZSA9PT0gb3BlcmF0b3JOYW1lKTtcclxuICAgIHJldHVybiBvcGVyYXRvciA/IG9wZXJhdG9yc1dpdGhJbXBsaWNpdE11bHRpcGxpY2F0aW9uLmluY2x1ZGVzKG9wZXJhdG9yLnR5cGUpIDogZmFsc2U7XHJcbn1cclxuIl19