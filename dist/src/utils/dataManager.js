import { regExp } from "src/tikzjax/tikzjax";
import { brackets, mathJaxOperators, operatorsWithImplicitMultiplication, tikzComponents } from "./staticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return tikzComponents
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return tikzComponents.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperators, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchMathJaxOperators(query) {
    return mathJaxOperators.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
export function getAllMathJaxReferences() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function searchAllMathJaxOperatorsAndSymbols(query) {
    return [...mathJaxOperators, ...brackets]
        .find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperators
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Retrieves operators by associativity (side).
 * @param {string} side - The associativity to filter by (e.g., 'left', 'right', 'both').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    return mathJaxOperators
        .filter((operator) => operator.associativity === side)
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {string} bracket - The bracket type to filter by (e.g., 'none', 'left', 'right').
 * @returns {string[]} - Array of operator names matching the specified bracket type.
 */
export function getOperatorsByBracket(bracket) {
    return mathJaxOperators
        .filter((operator) => operator.bracket === bracket)
        .map((operator) => operator.name);
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperators.find((op) => op.name === operatorName);
    return operator ? operatorsWithImplicitMultiplication.includes(operator.type) : false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZGF0YU1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsbUNBQW1DLEVBQUUsY0FBYyxFQUFTLE1BQU0sY0FBYyxDQUFDO0FBRXRIOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUNsRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQjtJQUNoQyxPQUFPLGNBQWM7U0FDaEIsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNsRCxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBYTtJQUM5QyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQzNDLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssS0FBSyxDQUMvQyxDQUNKLENBQUM7QUFDTixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBYTtJQUN2QyxPQUFPLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FB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QUFJLEtBQUssWUFBWSxDQUFDLENBQUM7SUFDekUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUMxRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnRXhwIH0gZnJvbSBcInNyYy90aWt6amF4L3Rpa3pqYXhcIjtcclxuaW1wb3J0IHsgYnJhY2tldHMsIG1hdGhKYXhPcGVyYXRvcnMsIG9wZXJhdG9yc1dpdGhJbXBsaWNpdE11bHRpcGxpY2F0aW9uLCB0aWt6Q29tcG9uZW50cywgdW5pdHMgfSBmcm9tIFwiLi9zdGF0aWNEYXRhXCI7XHJcblxyXG4vKipcclxuICogRXNjYXBlcyBhIHN0cmluZyBmb3Igc2FmZSB1c2UgaW4gYSByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZXNjYXBlZCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXNjYXBlRm9yUmVnZXggPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIFRpa1ogY29tcG9uZW50cyBhcyBhbiBhcnJheSBvZiByZWdleC1yZWFkeSBzdHJpbmdzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXNjYXBlZCBUaWtaIGNvbXBvbmVudCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFRpa3pSZWZlcmVuY2VzKCkge1xyXG4gICAgcmV0dXJuIHRpa3pDb21wb25lbnRzXHJcbiAgICAgICAgLmZsYXRNYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnJlZmVyZW5jZXMgfHwgW10pXHJcbiAgICAgICAgLm1hcChlc2NhcGVGb3JSZWdleCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBUaWtaIGNvbXBvbmVudHMgZm9yIGEgc3BlY2lmaWMgcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgdW5kZWZpbmVkfSAtIFRoZSBtYXRjaGVkIFRpa1ogY29tcG9uZW50IG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoVGlrekNvbXBvbmVudHMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRpa3pDb21wb25lbnRzLmZpbmQoKGNvbXBvbmVudCkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKGNvbXBvbmVudCkuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBxdWVyeVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBzeW1ib2xzIChtYXRoIG9wZXJhdG9ycyBhbmQgYnJhY2tldHMpIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBzeW1ib2wgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hTeW1ib2xzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywgLi4uYnJhY2tldHNdLmZpbmQoKHN5bWJvbCkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKHN5bWJvbCkuc29tZSgodmFsdWUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXHJcbiAgICAgICAgKVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIG1hdGggb3BlcmF0b3JzIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBvcGVyYXRvciBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaE1hdGhKYXhPcGVyYXRvcnMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnMuZmluZCgob3BlcmF0b3IpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhvcGVyYXRvcikuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1hdGhKYXhSZWZlcmVuY2VzKCkge1xyXG4gICAgcmV0dXJuIFsuLi5tYXRoSmF4T3BlcmF0b3JzLCAuLi5icmFja2V0c11cclxuICAgICAgICAuZmxhdE1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQucmVmZXJlbmNlcyB8fCBbXSlcclxuICAgICAgICAubWFwKGVzY2FwZUZvclJlZ2V4KTtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGFsbCBNYXRoSmF4IG9wZXJhdG9ycyBhbmQgYnJhY2tldHMgYXMgcmVnZXgtcmVhZHkgc3RyaW5ncy5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIGVzY2FwZWQgTWF0aEpheCBvcGVyYXRvciBhbmQgYnJhY2tldCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEFsbE1hdGhKYXhPcGVyYXRvcnNBbmRTeW1ib2xzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywgLi4uYnJhY2tldHNdXHJcbiAgICAuZmluZCgob3BlcmF0b3IpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhvcGVyYXRvcikuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgICkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgTWF0aEpheCBvcGVyYXRvcnMgYnkgcHJpb3JpdHkgbGV2ZWwuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmlvcml0eUxldmVsIC0gVGhlIHByaW9yaXR5IGxldmVsIHRvIGZpbHRlciBieS5cclxuICogQHBhcmFtIHtib29sZWFufSB0b1JlZ2V4IC0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdHMgYXMgcmVnZXguXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXSB8IFJlZ0V4cFtdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG9yIHJlZ2V4IHBhdHRlcm5zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGhKYXhPcGVyYXRvcnNCeVByaW9yaXR5KHByaW9yaXR5TGV2ZWw6IG51bWJlciwgdG9SZWdleCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcmlvcml0aXplZCA9IG1hdGhKYXhPcGVyYXRvcnNcclxuICAgICAgICAuZmlsdGVyKChvcGVyYXRvcikgPT4gb3BlcmF0b3IucHJpb3JpdHkgPT09IHByaW9yaXR5TGV2ZWwpXHJcbiAgICAgICAgLm1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLm5hbWUpO1xyXG4gICAgcmV0dXJuIHRvUmVnZXggPyByZWdFeHAocHJpb3JpdGl6ZWQpIDogcHJpb3JpdGl6ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgb3BlcmF0b3JzIGJ5IGFzc29jaWF0aXZpdHkgKHNpZGUpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lkZSAtIFRoZSBhc3NvY2lhdGl2aXR5IHRvIGZpbHRlciBieSAoZS5nLiwgJ2xlZnQnLCAncmlnaHQnLCAnYm90aCcpLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2Ygb3BlcmF0b3IgbmFtZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBzaWRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdG9yc0J5QXNzb2NpYXRpdml0eShzaWRlOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBtYXRoSmF4T3BlcmF0b3JzXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLmFzc29jaWF0aXZpdHkgPT09IHNpZGUpXHJcbiAgICAgICAgLm1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLm5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIG9wZXJhdG9ycyBieSBicmFja2V0IHR5cGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFja2V0IC0gVGhlIGJyYWNrZXQgdHlwZSB0byBmaWx0ZXIgYnkgKGUuZy4sICdub25lJywgJ2xlZnQnLCAncmlnaHQnKS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgYnJhY2tldCB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdG9yc0J5QnJhY2tldChicmFja2V0OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBtYXRoSmF4T3BlcmF0b3JzXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLmJyYWNrZXQgPT09IGJyYWNrZXQpXHJcbiAgICAgICAgLm1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLm5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIG9wZXJhdG9yIGhhcyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRvciB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgb3BlcmF0b3IgaGFzIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzSW1wbGljaXRNdWx0aXBsaWNhdGlvbihvcGVyYXRvck5hbWU6IHN0cmluZykge1xyXG4gICAgY29uc3Qgb3BlcmF0b3IgPSBtYXRoSmF4T3BlcmF0b3JzLmZpbmQoKG9wKSA9PiBvcC5uYW1lID09PSBvcGVyYXRvck5hbWUpO1xyXG4gICAgcmV0dXJuIG9wZXJhdG9yID8gb3BlcmF0b3JzV2l0aEltcGxpY2l0TXVsdGlwbGljYXRpb24uaW5jbHVkZXMob3BlcmF0b3IudHlwZSkgOiBmYWxzZTtcclxufVxyXG4iXX0=