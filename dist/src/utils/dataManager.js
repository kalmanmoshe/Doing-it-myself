import { regExp } from "src/tikzjax/tikzjax";
import { brackets, mathJaxOperators, operatorsWithImplicitMultiplication, tikzComponents } from "./staticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return tikzComponents
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return tikzComponents.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperators, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchMathJaxOperators(query) {
    return mathJaxOperators.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
export function getAllMathJaxReferences() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function getAllMathJaxOperators() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((operator) => operator.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperators
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Retrieves operators by associativity (side).
 * @param {string} side - The associativity to filter by (e.g., 'left', 'right', 'both').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    return mathJaxOperators
        .filter((operator) => operator.associativity === side)
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {string} bracket - The bracket type to filter by (e.g., 'none', 'left', 'right').
 * @returns {string[]} - Array of operator names matching the specified bracket type.
 */
export function getOperatorsByBracket(bracket) {
    return mathJaxOperators
        .filter((operator) => operator.bracket === bracket)
        .map((operator) => operator.name);
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperators.find((op) => op.name === operatorName);
    return operator ? operatorsWithImplicitMultiplication.includes(operator.type) : false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZGF0YU1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsbUNBQW1DLEVBQUUsY0FBYyxFQUFTLE1BQU0sY0FBYyxDQUFDO0FBRXRIOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUNsRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQjtJQUNoQyxPQUFPLGNBQWM7U0FDaEIsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNsRCxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBYTtJQUM5QyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQzNDLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssS0FBSyxDQUMvQyxDQUNKLENBQUM7QUFDTixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBYTtJQUN2QyxPQUFPLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FB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QyxDQUFDLEtBQUssQ0FBQztBQUMxRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnRXhwIH0gZnJvbSBcInNyYy90aWt6amF4L3Rpa3pqYXhcIjtcbmltcG9ydCB7IGJyYWNrZXRzLCBtYXRoSmF4T3BlcmF0b3JzLCBvcGVyYXRvcnNXaXRoSW1wbGljaXRNdWx0aXBsaWNhdGlvbiwgdGlrekNvbXBvbmVudHMsIHVuaXRzIH0gZnJvbSBcIi4vc3RhdGljRGF0YVwiO1xuXG4vKipcbiAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHNhZmUgdXNlIGluIGEgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGVGb3JSZWdleCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBUaWtaIGNvbXBvbmVudHMgYXMgYW4gYXJyYXkgb2YgcmVnZXgtcmVhZHkgc3RyaW5ncy5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBlc2NhcGVkIFRpa1ogY29tcG9uZW50IHJlZmVyZW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxUaWt6UmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGlrekNvbXBvbmVudHNcbiAgICAgICAgLmZsYXRNYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnJlZmVyZW5jZXMgfHwgW10pXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIFRpa1ogY29tcG9uZW50cyBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBUaWtaIGNvbXBvbmVudCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoVGlrekNvbXBvbmVudHMocXVlcnk6IHN0cmluZykge1xuICAgIHJldHVybiB0aWt6Q29tcG9uZW50cy5maW5kKChjb21wb25lbnQpID0+XG4gICAgICAgIE9iamVjdC52YWx1ZXMoY29tcG9uZW50KS5mbGF0KCkuc29tZSgodmFsdWUpID0+XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBxdWVyeVxuICAgICAgICApXG4gICAgKTtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBzeW1ib2xzIChtYXRoIG9wZXJhdG9ycyBhbmQgYnJhY2tldHMpIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgdW5kZWZpbmVkfSAtIFRoZSBtYXRjaGVkIHN5bWJvbCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoU3ltYm9scyhxdWVyeTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIFsuLi5tYXRoSmF4T3BlcmF0b3JzLCAuLi5icmFja2V0c10uZmluZCgoc3ltYm9sKSA9PlxuICAgICAgICBPYmplY3QudmFsdWVzKHN5bWJvbCkuc29tZSgodmFsdWUpID0+XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxuICAgICAgICApXG4gICAgKTtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBtYXRoIG9wZXJhdG9ycyBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBvcGVyYXRvciBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoTWF0aEpheE9wZXJhdG9ycyhxdWVyeTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnMuZmluZCgob3BlcmF0b3IpID0+XG4gICAgICAgIE9iamVjdC52YWx1ZXMob3BlcmF0b3IpLmZsYXQoKS5zb21lKCh2YWx1ZSkgPT5cbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXG4gICAgICAgIClcbiAgICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1hdGhKYXhSZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywuLi5icmFja2V0c11cbiAgICAgICAgLmZsYXRNYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnJlZmVyZW5jZXMgfHwgW10pXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIE1hdGhKYXggb3BlcmF0b3JzIGFuZCBicmFja2V0cyBhcyByZWdleC1yZWFkeSBzdHJpbmdzLlxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIGVzY2FwZWQgTWF0aEpheCBvcGVyYXRvciBhbmQgYnJhY2tldCByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWF0aEpheE9wZXJhdG9ycygpIHtcbiAgICByZXR1cm4gWy4uLm1hdGhKYXhPcGVyYXRvcnMsIC4uLmJyYWNrZXRzXVxuICAgICAgICAuZmxhdE1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLnJlZmVyZW5jZXMgfHwgW10pXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBNYXRoSmF4IG9wZXJhdG9ycyBieSBwcmlvcml0eSBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmlvcml0eUxldmVsIC0gVGhlIHByaW9yaXR5IGxldmVsIHRvIGZpbHRlciBieS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9SZWdleCAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRzIGFzIHJlZ2V4LlxuICogQHJldHVybnMge3N0cmluZ1tdIHwgUmVnRXhwW119IC0gQXJyYXkgb2Ygb3BlcmF0b3IgbmFtZXMgb3IgcmVnZXggcGF0dGVybnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRoSmF4T3BlcmF0b3JzQnlQcmlvcml0eShwcmlvcml0eUxldmVsOiBudW1iZXIsIHRvUmVnZXggPSBmYWxzZSkge1xuICAgIGNvbnN0IHByaW9yaXRpemVkID0gbWF0aEpheE9wZXJhdG9yc1xuICAgICAgICAuZmlsdGVyKChvcGVyYXRvcikgPT4gb3BlcmF0b3IucHJpb3JpdHkgPT09IHByaW9yaXR5TGV2ZWwpXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcbiAgICByZXR1cm4gdG9SZWdleCA/IHJlZ0V4cChwcmlvcml0aXplZCkgOiBwcmlvcml0aXplZDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgb3BlcmF0b3JzIGJ5IGFzc29jaWF0aXZpdHkgKHNpZGUpLlxuICogQHBhcmFtIHtzdHJpbmd9IHNpZGUgLSBUaGUgYXNzb2NpYXRpdml0eSB0byBmaWx0ZXIgYnkgKGUuZy4sICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdGgnKS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHNpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvcnNCeUFzc29jaWF0aXZpdHkoc2lkZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnNcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLmFzc29jaWF0aXZpdHkgPT09IHNpZGUpXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgb3BlcmF0b3JzIGJ5IGJyYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFja2V0IC0gVGhlIGJyYWNrZXQgdHlwZSB0byBmaWx0ZXIgYnkgKGUuZy4sICdub25lJywgJ2xlZnQnLCAncmlnaHQnKS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGJyYWNrZXQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdG9yc0J5QnJhY2tldChicmFja2V0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc1xuICAgICAgICAuZmlsdGVyKChvcGVyYXRvcikgPT4gb3BlcmF0b3IuYnJhY2tldCA9PT0gYnJhY2tldClcbiAgICAgICAgLm1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLm5hbWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBvcGVyYXRvciBoYXMgaW1wbGljaXQgbXVsdGlwbGljYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG9wZXJhdG9yIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgb3BlcmF0b3IgaGFzIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbXBsaWNpdE11bHRpcGxpY2F0aW9uKG9wZXJhdG9yTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBtYXRoSmF4T3BlcmF0b3JzLmZpbmQoKG9wKSA9PiBvcC5uYW1lID09PSBvcGVyYXRvck5hbWUpO1xuICAgIHJldHVybiBvcGVyYXRvciA/IG9wZXJhdG9yc1dpdGhJbXBsaWNpdE11bHRpcGxpY2F0aW9uLmluY2x1ZGVzKG9wZXJhdG9yLnR5cGUpIDogZmFsc2U7XG59XG4iXX0=