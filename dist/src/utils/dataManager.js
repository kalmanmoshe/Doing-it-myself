import { regExp } from "src/tikzjax/tikzjax";
import { brackets, mathJaxOperators, operatorsWithImplicitMultiplication, tikzComponents } from "./staticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return tikzComponents
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return tikzComponents.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperators, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchOperators(query) {
    return mathJaxOperators.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function getAllMathJaxOperators() {
    return [...mathJaxOperators, ...brackets]
        .flatMap((operator) => operator.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperators
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Retrieves operators by associativity (side).
 * @param {string} side - The associativity to filter by (e.g., 'left', 'right', 'both').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    return mathJaxOperators
        .filter((operator) => operator.associativity === side)
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {string} bracket - The bracket type to filter by (e.g., 'none', 'left', 'right').
 * @returns {string[]} - Array of operator names matching the specified bracket type.
 */
export function getOperatorsByBracket(bracket) {
    return mathJaxOperators
        .filter((operator) => operator.bracket === bracket)
        .map((operator) => operator.name);
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperators.find((op) => op.name === operatorName);
    return operator ? operatorsWithImplicitMultiplication.includes(operator.type) : false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZGF0YU1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsbUNBQW1DLEVBQUUsY0FBYyxFQUFTLE1BQU0sY0FBYyxDQUFDO0FBRXRIOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUNsRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQjtJQUNoQyxPQUFPLGNBQWM7U0FDaEIsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNsRCxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBYTtJQUM5QyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQzNDLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssS0FBSyxDQUMvQyxDQUNKLENBQUM7QUFDTixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBYTtJQUN2QyxPQUFPLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ3RELE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDakMsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQ3JELENBQ0osQ0FBQztBQUNOLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FBQyxLQUFhO0lBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FDdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUMxQyxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDckQsQ0FDSixDQUFDO0FBQ04sQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxzQkFBc0I7SUFDbEMsT0FBTyxDQUFDLEdBQUcsZ0JBQWdCLEVBQUUsR0FBRyxRQUFRLENBQUM7U0FDcEMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNoRCxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLDZCQUE2QixDQUFDLGFBQXFCLEVBQUUsT0FBTyxHQUFHLEtBQUs7SUFDaEYsTUFBTSxXQUFXLEdBQUcsZ0JBQWdCO1NBQy9CLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxhQUFhLENBQUM7U0FDekQsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEMsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3ZELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLDJCQUEyQixDQUFDLElBQVk7SUFDcEQsT0FBTyxnQkFBZ0I7U0FDbEIsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsYUFBYSxLQUFLLElBQUksQ0FBQztTQUNyRCxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxPQUFlO0lBQ2pELE9BQU8sZ0JBQWdCO1NBQ2xCLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sS0FBSyxPQUFPLENBQUM7U0FDbEQsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUMsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUseUJBQXlCLENBQUMsWUFBb0I7SUFDMUQsTUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxDQUFDO0lBQ3pFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxtQ0FBbUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDMUYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ0V4cCB9IGZyb20gXCJzcmMvdGlrempheC90aWt6amF4XCI7XHJcbmltcG9ydCB7IGJyYWNrZXRzLCBtYXRoSmF4T3BlcmF0b3JzLCBvcGVyYXRvcnNXaXRoSW1wbGljaXRNdWx0aXBsaWNhdGlvbiwgdGlrekNvbXBvbmVudHMsIHVuaXRzIH0gZnJvbSBcIi4vc3RhdGljRGF0YVwiO1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHNhZmUgdXNlIGluIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlc2NhcGUuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGVzY2FwZWQgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVzY2FwZUZvclJlZ2V4ID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIGFsbCBUaWtaIGNvbXBvbmVudHMgYXMgYW4gYXJyYXkgb2YgcmVnZXgtcmVhZHkgc3RyaW5ncy5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIGVzY2FwZWQgVGlrWiBjb21wb25lbnQgcmVmZXJlbmNlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxUaWt6UmVmZXJlbmNlcygpIHtcclxuICAgIHJldHVybiB0aWt6Q29tcG9uZW50c1xyXG4gICAgICAgIC5mbGF0TWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC5yZWZlcmVuY2VzIHx8IFtdKVxyXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgVGlrWiBjb21wb25lbnRzIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBUaWtaIGNvbXBvbmVudCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFRpa3pDb21wb25lbnRzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aWt6Q29tcG9uZW50cy5maW5kKChjb21wb25lbnQpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjb21wb25lbnQpLmZsYXQoKS5zb21lKCh2YWx1ZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gcXVlcnlcclxuICAgICAgICApXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgc3ltYm9scyAobWF0aCBvcGVyYXRvcnMgYW5kIGJyYWNrZXRzKSBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IC0gVGhlIG1hdGNoZWQgc3ltYm9sIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoU3ltYm9scyhxdWVyeTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gWy4uLm1hdGhKYXhPcGVyYXRvcnMsIC4uLmJyYWNrZXRzXS5maW5kKChzeW1ib2wpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhzeW1ib2wpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBtYXRoIG9wZXJhdG9ycyBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IC0gVGhlIG1hdGNoZWQgb3BlcmF0b3Igb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hPcGVyYXRvcnMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnMuZmluZCgob3BlcmF0b3IpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhvcGVyYXRvcikuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIE1hdGhKYXggb3BlcmF0b3JzIGFuZCBicmFja2V0cyBhcyByZWdleC1yZWFkeSBzdHJpbmdzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXNjYXBlZCBNYXRoSmF4IG9wZXJhdG9yIGFuZCBicmFja2V0IHJlZmVyZW5jZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWF0aEpheE9wZXJhdG9ycygpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9ycywgLi4uYnJhY2tldHNdXHJcbiAgICAgICAgLmZsYXRNYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5yZWZlcmVuY2VzIHx8IFtdKVxyXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIE1hdGhKYXggb3BlcmF0b3JzIGJ5IHByaW9yaXR5IGxldmVsLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlMZXZlbCAtIFRoZSBwcmlvcml0eSBsZXZlbCB0byBmaWx0ZXIgYnkuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9SZWdleCAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRzIGFzIHJlZ2V4LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW10gfCBSZWdFeHBbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBvciByZWdleCBwYXR0ZXJucy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRoSmF4T3BlcmF0b3JzQnlQcmlvcml0eShwcmlvcml0eUxldmVsOiBudW1iZXIsIHRvUmVnZXggPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJpb3JpdGl6ZWQgPSBtYXRoSmF4T3BlcmF0b3JzXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLnByaW9yaXR5ID09PSBwcmlvcml0eUxldmVsKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxuICAgIHJldHVybiB0b1JlZ2V4ID8gcmVnRXhwKHByaW9yaXRpemVkKSA6IHByaW9yaXRpemVkO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIG9wZXJhdG9ycyBieSBhc3NvY2lhdGl2aXR5IChzaWRlKS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNpZGUgLSBUaGUgYXNzb2NpYXRpdml0eSB0byBmaWx0ZXIgYnkgKGUuZy4sICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdGgnKS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2lkZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvcnNCeUFzc29jaWF0aXZpdHkoc2lkZTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc1xyXG4gICAgICAgIC5maWx0ZXIoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBzaWRlKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBvcGVyYXRvcnMgYnkgYnJhY2tldCB0eXBlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhY2tldCAtIFRoZSBicmFja2V0IHR5cGUgdG8gZmlsdGVyIGJ5IChlLmcuLCAnbm9uZScsICdsZWZ0JywgJ3JpZ2h0JykuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGJyYWNrZXQgdHlwZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvcnNCeUJyYWNrZXQoYnJhY2tldDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc1xyXG4gICAgICAgIC5maWx0ZXIoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5icmFja2V0ID09PSBicmFja2V0KVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBvcGVyYXRvciBoYXMgaW1wbGljaXQgbXVsdGlwbGljYXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIG9wZXJhdG9yIGhhcyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ltcGxpY2l0TXVsdGlwbGljYXRpb24ob3BlcmF0b3JOYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IG9wZXJhdG9yID0gbWF0aEpheE9wZXJhdG9ycy5maW5kKChvcCkgPT4gb3AubmFtZSA9PT0gb3BlcmF0b3JOYW1lKTtcclxuICAgIHJldHVybiBvcGVyYXRvciA/IG9wZXJhdG9yc1dpdGhJbXBsaWNpdE11bHRpcGxpY2F0aW9uLmluY2x1ZGVzKG9wZXJhdG9yLnR5cGUpIDogZmFsc2U7XHJcbn1cclxuIl19