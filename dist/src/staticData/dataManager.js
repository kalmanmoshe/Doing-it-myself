import { regExp } from "src/tikzjax/tikzjax";
import { mathJaxOperatorsMetadata, operatorsWithImplicitMultiplication, operatorNames, associativityFormatType } from "./mathParserStaticData";
import { brackets, LatexMetadata } from "./latexStaticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return LatexMetadata
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return LatexMetadata.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperatorsMetadata, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchMathJaxOperators(query) {
    return mathJaxOperatorsMetadata.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
export function getAllMathJaxReferences() {
    return [...mathJaxOperatorsMetadata, ...brackets]
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function searchAllMathJaxOperatorsAndSymbols(query) {
    return [...mathJaxOperatorsMetadata, ...brackets]
        .find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperatorsMetadata
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperatorsMetadata.find((op) => op.name === operatorName);
    return operator ? getOperatorNamesByType(operatorsWithImplicitMultiplication).includes(operator.type) : false;
}
function getOperatorNamesByType(operatorTypes) {
    if (!Array.isArray(operatorTypes)) {
        operatorTypes = [operatorTypes];
    }
    return operatorTypes.map(type => operatorNames.get(type)).flat();
}
/**
 * The following functions.or helper functions to retrieve the static data based on.parentheses.brackets and sidies
 * inside the staticData.ts file.
 */
/**
 * Retrieves operators by associativity (side).
 * @param {Associativity} side - The associativity side to filter by (e.g., 'left', 'right', 'doubleRight').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    if (side instanceof Array) {
        return side.flatMap((s) => getOperatorsByAssociativity(s));
    }
    return mathJaxOperatorsMetadata
        .filter((operator) => mahtjaxAssociativitymetadata(operator).positions.has(side))
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {BracketType} bracket - The bracket type to filter by (e.g., 'parentheses', 'none').
 * @param {Associativity} side - The side to check for the specified bracket type.
 * @returns {string[]} - Array of operator names matching the specified bracket type and side.
 */
export function getOperatorsByBracketType(bracket, side) {
    return mathJaxOperatorsMetadata
        .filter((operator) => { var _a; return ((_a = mahtjaxAssociativitymetadata(operator).positions.get(side)) === null || _a === void 0 ? void 0 : _a.bracketType) === bracket; })
        .map((operator) => operator.name);
}
/**
 * Checks if a value matches any operator with the specified associativities.
 * @param {string} value - The value to check.
 * @param {Associativity[]} sides - The associativity sides to check (e.g., ['left', 'right']).
 * @returns {boolean} - True if the value matches any operator with the specified associativities.
 */
export function isOperatorWithAssociativity(value, sides, absolute) {
    const operators = sides.map((side) => getOperatorsByAssociativity(side).includes(value));
    return absolute ? operators.every((operator) => operator) : operators.some((operator) => operator);
}
/**
 * Checks if a value matches any operator with the specified associativities.
 * @param {string} value - The value to check.
 * @param {Associativity[]} sides - The associativity sides to check (e.g., ['left', 'right']).
 * @returns {boolean} - True if the value matches any operator with the specified associativities.
 */
export function getValuesWithKeysBySide(map, left) {
    return Array.from(map.entries())
        .filter(([key]) => left ? key < 0 : key > 0)
        .map(([, value]) => value);
}
export const mahtjaxAssociativitymetadata = (metadata) => {
    return associativitymetadataByType(metadata, associativityFormatType.MathJax);
};
export const associativitymetadataByType = (metadata, type) => {
    const value = metadata.associativity.get(type);
    if (!value) {
        throw new Error("Associativity value not found");
    }
    return value;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc3RhdGljRGF0YS9kYXRhTWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDN0MsT0FBTyxFQUEyQix3QkFBd0IsRUFBRSxtQ0FBbUMsRUFBZSxhQUFhLEVBQUUsdUJBQXVCLEVBQXNCLE1BQU0sd0JBQXdCLENBQUM7QUFFek0sT0FBTyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc1RDs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7SUFDbEQsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLHdCQUF3QixFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3pELENBQUMsQ0FBQztBQUVGOzs7R0FHRztBQUNILE1BQU0sVUFBVSxvQkFBb0I7SUFDaEMsT0FBTyxhQUFhO1NBQ2YsT0FBTyxDQUFDLENBQUMsU0FBd0IsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7U0FDakUsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUFDLEtBQWE7SUFDOUMsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBd0IsRUFBRSxFQUFFLENBQ25ELE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDM0MsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxLQUFLLENBQy9DLENBQ0osQ0FBQztBQUNOLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBQyxL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Q29udGVudCI6WyJpbXBvcnQgeyByZWdFeHAgfSBmcm9tIFwic3JjL3Rpa3pqYXgvdGlrempheFwiO1xyXG5pbXBvcnQgeyBNYXRoSmF4T3BlcmF0b3JNZXRhZGF0YSwgbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLCBvcGVyYXRvcnNXaXRoSW1wbGljaXRNdWx0aXBsaWNhdGlvbixPcGVyYXRvclR5cGUsIG9wZXJhdG9yTmFtZXMsIGFzc29jaWF0aXZpdHlGb3JtYXRUeXBlLCBBc3NvY2lhdGl2aXR5VmFsdWUgfSBmcm9tIFwiLi9tYXRoUGFyc2VyU3RhdGljRGF0YVwiO1xyXG5pbXBvcnQgeyBCcmFja2V0VHlwZSB9IGZyb20gXCIuL2VuY2FzaW5nc1wiO1xyXG5pbXBvcnQgeyBicmFja2V0cywgTGF0ZXhNZXRhZGF0YSB9IGZyb20gXCIuL2xhdGV4U3RhdGljRGF0YVwiO1xyXG5pbXBvcnQgeyBtZXRhZGF0YSB9IGZyb20gXCJ2YWxpYm90XCI7XHJcblxyXG4vKipcclxuICogRXNjYXBlcyBhIHN0cmluZyBmb3Igc2FmZSB1c2UgaW4gYSByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZXNjYXBlZCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXNjYXBlRm9yUmVnZXggPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIFRpa1ogY29tcG9uZW50cyBhcyBhbiBhcnJheSBvZiByZWdleC1yZWFkeSBzdHJpbmdzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXNjYXBlZCBUaWtaIGNvbXBvbmVudCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFRpa3pSZWZlcmVuY2VzKCkge1xyXG4gICAgcmV0dXJuIExhdGV4TWV0YWRhdGFcclxuICAgICAgICAuZmxhdE1hcCgoY29tcG9uZW50OiBMYXRleE1ldGFkYXRhKSA9PiBjb21wb25lbnQucmVmZXJlbmNlcyB8fCBbXSlcclxuICAgICAgICAubWFwKGVzY2FwZUZvclJlZ2V4KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIFRpa1ogY29tcG9uZW50cyBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IC0gVGhlIG1hdGNoZWQgVGlrWiBjb21wb25lbnQgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hUaWt6Q29tcG9uZW50cyhxdWVyeTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gTGF0ZXhNZXRhZGF0YS5maW5kKChjb21wb25lbnQ6IExhdGV4TWV0YWRhdGEpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjb21wb25lbnQpLmZsYXQoKS5zb21lKCh2YWx1ZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gcXVlcnlcclxuICAgICAgICApXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgc3ltYm9scyAobWF0aCBvcGVyYXRvcnMgYW5kIGJyYWNrZXRzKSBmb3IgYSBzcGVjaWZpYyBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IC0gVGhlIG1hdGNoZWQgc3ltYm9sIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoU3ltYm9scyhxdWVyeTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gWy4uLm1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YSwgLi4uYnJhY2tldHNdLmZpbmQoKHN5bWJvbCkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKHN5bWJvbCkuc29tZSgodmFsdWUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXHJcbiAgICAgICAgKVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIG1hdGggb3BlcmF0b3JzIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBvcGVyYXRvciBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaE1hdGhKYXhPcGVyYXRvcnMocXVlcnk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIG1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YS5maW5kKChvcGVyYXRvcikgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKG9wZXJhdG9yKS5mbGF0KCkuc29tZSgodmFsdWUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXHJcbiAgICAgICAgKVxyXG4gICAgKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWF0aEpheFJlZmVyZW5jZXMoKSB7XHJcbiAgICByZXR1cm4gWy4uLm1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YSwgLi4uYnJhY2tldHNdXHJcbiAgICAgICAgLmZsYXRNYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnJlZmVyZW5jZXMgfHwgW10pXHJcbiAgICAgICAgLm1hcChlc2NhcGVGb3JSZWdleCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhbGwgTWF0aEpheCBvcGVyYXRvcnMgYW5kIGJyYWNrZXRzIGFzIHJlZ2V4LXJlYWR5IHN0cmluZ3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBlc2NhcGVkIE1hdGhKYXggb3BlcmF0b3IgYW5kIGJyYWNrZXQgcmVmZXJlbmNlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbGxNYXRoSmF4T3BlcmF0b3JzQW5kU3ltYm9scyhxdWVyeTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gWy4uLm1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YSwgLi4uYnJhY2tldHNdXHJcbiAgICAuZmluZCgob3BlcmF0b3IpID0+XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhvcGVyYXRvcikuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKHF1ZXJ5KVxyXG4gICAgICAgICkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgTWF0aEpheCBvcGVyYXRvcnMgYnkgcHJpb3JpdHkgbGV2ZWwuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmlvcml0eUxldmVsIC0gVGhlIHByaW9yaXR5IGxldmVsIHRvIGZpbHRlciBieS5cclxuICogQHBhcmFtIHtib29sZWFufSB0b1JlZ2V4IC0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdHMgYXMgcmVnZXguXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXSB8IFJlZ0V4cFtdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG9yIHJlZ2V4IHBhdHRlcm5zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGhKYXhPcGVyYXRvcnNCeVByaW9yaXR5KHByaW9yaXR5TGV2ZWw6IG51bWJlciwgdG9SZWdleCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcmlvcml0aXplZCA9IG1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YVxyXG4gICAgICAgIC5maWx0ZXIoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5wcmlvcml0eSA9PT0gcHJpb3JpdHlMZXZlbClcclxuICAgICAgICAubWFwKChvcGVyYXRvcikgPT4gb3BlcmF0b3IubmFtZSk7XHJcbiAgICByZXR1cm4gdG9SZWdleCA/IHJlZ0V4cChwcmlvcml0aXplZCkgOiBwcmlvcml0aXplZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBvcGVyYXRvciBoYXMgaW1wbGljaXQgbXVsdGlwbGljYXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIG9wZXJhdG9yIGhhcyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNJbXBsaWNpdE11bHRpcGxpY2F0aW9uKG9wZXJhdG9yTmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBvcGVyYXRvciA9IG1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YS5maW5kKChvcCkgPT4gb3AubmFtZSA9PT0gb3BlcmF0b3JOYW1lKTtcclxuICAgIHJldHVybiBvcGVyYXRvciA/IGdldE9wZXJhdG9yTmFtZXNCeVR5cGUob3BlcmF0b3JzV2l0aEltcGxpY2l0TXVsdGlwbGljYXRpb24pLmluY2x1ZGVzKG9wZXJhdG9yLnR5cGUpIDogZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE9wZXJhdG9yTmFtZXNCeVR5cGUob3BlcmF0b3JUeXBlczogT3BlcmF0b3JUeXBlfE9wZXJhdG9yVHlwZVtdKXtcclxuICAgIGlmKCFBcnJheS5pc0FycmF5KG9wZXJhdG9yVHlwZXMpKXtcclxuICAgICAgICBvcGVyYXRvclR5cGVzPVtvcGVyYXRvclR5cGVzXVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wZXJhdG9yVHlwZXMubWFwKHR5cGU9PiBvcGVyYXRvck5hbWVzLmdldCh0eXBlKSkuZmxhdCgpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucy5vciBoZWxwZXIgZnVuY3Rpb25zIHRvIHJldHJpZXZlIHRoZSBzdGF0aWMgZGF0YSBiYXNlZCBvbi5wYXJlbnRoZXNlcy5icmFja2V0cyBhbmQgc2lkaWVzIFxyXG4gKiBpbnNpZGUgdGhlIHN0YXRpY0RhdGEudHMgZmlsZS5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBvcGVyYXRvcnMgYnkgYXNzb2NpYXRpdml0eSAoc2lkZSkuXHJcbiAqIEBwYXJhbSB7QXNzb2NpYXRpdml0eX0gc2lkZSAtIFRoZSBhc3NvY2lhdGl2aXR5IHNpZGUgdG8gZmlsdGVyIGJ5IChlLmcuLCAnbGVmdCcsICdyaWdodCcsICdkb3VibGVSaWdodCcpLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2Ygb3BlcmF0b3IgbmFtZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBzaWRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdG9yc0J5QXNzb2NpYXRpdml0eShzaWRlOiBudW1iZXJ8bnVtYmVyW10pOiBzdHJpbmdbXSB7XHJcbiAgICBpZihzaWRlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG4gICAgICAgIHJldHVybiBzaWRlLmZsYXRNYXAoKHMpID0+IGdldE9wZXJhdG9yc0J5QXNzb2NpYXRpdml0eShzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG1haHRqYXhBc3NvY2lhdGl2aXR5bWV0YWRhdGEob3BlcmF0b3IpLnBvc2l0aW9ucy5oYXMoc2lkZSkpXHJcbiAgICAgICAgLm1hcCgob3BlcmF0b3IpID0+IG9wZXJhdG9yLm5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIG9wZXJhdG9ycyBieSBicmFja2V0IHR5cGUuXHJcbiAqIEBwYXJhbSB7QnJhY2tldFR5cGV9IGJyYWNrZXQgLSBUaGUgYnJhY2tldCB0eXBlIHRvIGZpbHRlciBieSAoZS5nLiwgJ3BhcmVudGhlc2VzJywgJ25vbmUnKS5cclxuICogQHBhcmFtIHtBc3NvY2lhdGl2aXR5fSBzaWRlIC0gVGhlIHNpZGUgdG8gY2hlY2sgZm9yIHRoZSBzcGVjaWZpZWQgYnJhY2tldCB0eXBlLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2Ygb3BlcmF0b3IgbmFtZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBicmFja2V0IHR5cGUgYW5kIHNpZGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0b3JzQnlCcmFja2V0VHlwZShcclxuICAgIGJyYWNrZXQ6IEJyYWNrZXRUeXBlLFxyXG4gICAgc2lkZTogbnVtYmVyXHJcbik6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiBtYXRoSmF4T3BlcmF0b3JzTWV0YWRhdGFcclxuICAgICAgICAuZmlsdGVyKFxyXG4gICAgICAgICAgICAob3BlcmF0b3IpID0+XHJcbiAgICAgICAgICAgICAgICBtYWh0amF4QXNzb2NpYXRpdml0eW1ldGFkYXRhKG9wZXJhdG9yKS5wb3NpdGlvbnMuZ2V0KHNpZGUpPy5icmFja2V0VHlwZSA9PT0gYnJhY2tldFxyXG4gICAgICAgIClcclxuICAgICAgICAubWFwKChvcGVyYXRvcikgPT4gb3BlcmF0b3IubmFtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBtYXRjaGVzIGFueSBvcGVyYXRvciB3aXRoIHRoZSBzcGVjaWZpZWQgYXNzb2NpYXRpdml0aWVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSB7QXNzb2NpYXRpdml0eVtdfSBzaWRlcyAtIFRoZSBhc3NvY2lhdGl2aXR5IHNpZGVzIHRvIGNoZWNrIChlLmcuLCBbJ2xlZnQnLCAncmlnaHQnXSkuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHZhbHVlIG1hdGNoZXMgYW55IG9wZXJhdG9yIHdpdGggdGhlIHNwZWNpZmllZCBhc3NvY2lhdGl2aXRpZXMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmF0b3JXaXRoQXNzb2NpYXRpdml0eSh2YWx1ZTogc3RyaW5nLCBzaWRlczogbnVtYmVyW10sIGFic29sdXRlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3BlcmF0b3JzID0gc2lkZXMubWFwKChzaWRlKSA9PiBnZXRPcGVyYXRvcnNCeUFzc29jaWF0aXZpdHkoc2lkZSkuaW5jbHVkZXModmFsdWUpKTtcclxuICAgIHJldHVybiBhYnNvbHV0ZSA/IG9wZXJhdG9ycy5ldmVyeSgob3BlcmF0b3IpID0+IG9wZXJhdG9yKSA6IG9wZXJhdG9ycy5zb21lKChvcGVyYXRvcikgPT4gb3BlcmF0b3IpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgbWF0Y2hlcyBhbnkgb3BlcmF0b3Igd2l0aCB0aGUgc3BlY2lmaWVkIGFzc29jaWF0aXZpdGllcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0ge0Fzc29jaWF0aXZpdHlbXX0gc2lkZXMgLSBUaGUgYXNzb2NpYXRpdml0eSBzaWRlcyB0byBjaGVjayAoZS5nLiwgWydsZWZ0JywgJ3JpZ2h0J10pLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB2YWx1ZSBtYXRjaGVzIGFueSBvcGVyYXRvciB3aXRoIHRoZSBzcGVjaWZpZWQgYXNzb2NpYXRpdml0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlc1dpdGhLZXlzQnlTaWRlPFQ+KG1hcDogTWFwPG51bWJlciwgVD4sIGxlZnQ6IGJvb2xlYW4pOiBUW10ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20obWFwLmVudHJpZXMoKSlcclxuICAgICAgICAuZmlsdGVyKChba2V5XSkgPT4gbGVmdCA/IGtleSA8IDAgOiBrZXkgPiAwKVxyXG4gICAgICAgIC5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpO1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBtYWh0amF4QXNzb2NpYXRpdml0eW1ldGFkYXRhID0gKG1ldGFkYXRhOiBNYXRoSmF4T3BlcmF0b3JNZXRhZGF0YSk6IEFzc29jaWF0aXZpdHlWYWx1ZSA9PiB7XHJcbiAgICByZXR1cm4gYXNzb2NpYXRpdml0eW1ldGFkYXRhQnlUeXBlKG1ldGFkYXRhLCBhc3NvY2lhdGl2aXR5Rm9ybWF0VHlwZS5NYXRoSmF4KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhc3NvY2lhdGl2aXR5bWV0YWRhdGFCeVR5cGUgPSAobWV0YWRhdGE6IE1hdGhKYXhPcGVyYXRvck1ldGFkYXRhLHR5cGU6IGFzc29jaWF0aXZpdHlGb3JtYXRUeXBlKTogQXNzb2NpYXRpdml0eVZhbHVlID0+IHtcclxuICAgIGNvbnN0IHZhbHVlID0gbWV0YWRhdGEuYXNzb2NpYXRpdml0eS5nZXQodHlwZSk7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzb2NpYXRpdml0eSB2YWx1ZSBub3QgZm91bmRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07Il19