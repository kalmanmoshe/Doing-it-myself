import { regExp } from "src/tikzjax/tikzjax";
import { mathJaxOperatorsMetadata, operatorsWithImplicitMultiplication, operatorNames } from "./mathParserStaticData";
import { brackets, LatexMetadata } from "./latexStaticData";
/**
 * Escapes a string for safe use in a regular expression.
 * @param {string} str - The string to escape.
 * @returns {string} - The escaped string.
 */
export const escapeForRegex = (str) => {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
/**
 * Retrieves all TikZ components as an array of regex-ready strings.
 * @returns {string[]} - Array of escaped TikZ component references.
 */
export function getAllTikzReferences() {
    return LatexMetadata
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Searches TikZ components for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched TikZ component or undefined if not found.
 */
export function searchTikzComponents(query) {
    return LatexMetadata.find((component) => Object.values(component).flat().some((value) => typeof value === 'string' && value === query));
}
/**
 * Searches symbols (math operators and brackets) for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched symbol or undefined if not found.
 */
export function searchSymbols(query) {
    return [...mathJaxOperatorsMetadata, ...brackets].find((symbol) => Object.values(symbol).some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Searches math operators for a specific query.
 * @param {string} query - The query to search for.
 * @returns {object | undefined} - The matched operator or undefined if not found.
 */
export function searchMathJaxOperators(query) {
    return mathJaxOperatorsMetadata.find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
export function getAllMathJaxReferences() {
    return [...mathJaxOperatorsMetadata, ...brackets]
        .flatMap((component) => component.references || [])
        .map(escapeForRegex);
}
/**
 * Retrieves all MathJax operators and brackets as regex-ready strings.
 * @returns {string[]} - Array of escaped MathJax operator and bracket references.
 */
export function searchAllMathJaxOperatorsAndSymbols(query) {
    return [...mathJaxOperatorsMetadata, ...brackets]
        .find((operator) => Object.values(operator).flat().some((value) => typeof value === 'string' && value.includes(query)));
}
/**
 * Retrieves MathJax operators by priority level.
 * @param {number} priorityLevel - The priority level to filter by.
 * @param {boolean} toRegex - Whether to return the results as regex.
 * @returns {string[] | RegExp[]} - Array of operator names or regex patterns.
 */
export function getMathJaxOperatorsByPriority(priorityLevel, toRegex = false) {
    const prioritized = mathJaxOperatorsMetadata
        .filter((operator) => operator.priority === priorityLevel)
        .map((operator) => operator.name);
    return toRegex ? regExp(prioritized) : prioritized;
}
/**
 * Checks if an operator has implicit multiplication.
 * @param {string} operatorName - The name of the operator to check.
 * @returns {boolean} - True if the operator has implicit multiplication, false otherwise.
 */
export function hasImplicitMultiplication(operatorName) {
    const operator = mathJaxOperatorsMetadata.find((op) => op.name === operatorName);
    return operator ? getOperatorNamesByType(operatorsWithImplicitMultiplication).includes(operator.type) : false;
}
function getOperatorNamesByType(operatorTypes) {
    if (!Array.isArray(operatorTypes)) {
        operatorTypes = [operatorTypes];
    }
    return operatorTypes.map(type => operatorNames.get(type)).flat();
}
/**
 * The following functions.or helper functions to retrieve the static data based on.parentheses.brackets and sidies
 * inside the staticData.ts file.
 */
/**
 * Retrieves operators by associativity (side).
 * @param {Associativity} side - The associativity side to filter by (e.g., 'left', 'right', 'doubleRight').
 * @returns {string[]} - Array of operator names matching the specified side.
 */
export function getOperatorsByAssociativity(side) {
    if (side instanceof Array) {
        return side.flatMap((s) => getOperatorsByAssociativity(s));
    }
    return mathJaxOperatorsMetadata
        .filter((operator) => operator.associativity.positions.has(side))
        .map((operator) => operator.name);
}
/**
 * Retrieves operators by bracket type.
 * @param {BracketType} bracket - The bracket type to filter by (e.g., 'parentheses', 'none').
 * @param {Associativity} side - The side to check for the specified bracket type.
 * @returns {string[]} - Array of operator names matching the specified bracket type and side.
 */
export function getOperatorsByBracketType(bracket, side) {
    return mathJaxOperatorsMetadata
        .filter((operator) => operator.associativity.positions.get(side)?.bracketType === bracket)
        .map((operator) => operator.name);
}
/**
 * Checks if a value matches any operator with the specified associativities.
 * @param {string} value - The value to check.
 * @param {Associativity[]} sides - The associativity sides to check (e.g., ['left', 'right']).
 * @returns {boolean} - True if the value matches any operator with the specified associativities.
 */
export function isOperatorWithAssociativity(value, sides, absolute) {
    const operators = sides.map((side) => getOperatorsByAssociativity(side).includes(value));
    return absolute ? operators.every((operator) => operator) : operators.some((operator) => operator);
}
/**
 * Checks if a value matches any operator with the specified associativities.
 * @param {string} value - The value to check.
 * @param {Associativity[]} sides - The associativity sides to check (e.g., ['left', 'right']).
 * @returns {boolean} - True if the value matches any operator with the specified associativities.
 */
export function getValuesWithKeysBySide(map, left) {
    return Array.from(map.entries())
        .filter(([key]) => left ? key < 0 : key > 0)
        .map(([, value]) => value);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc3RhdGljRGF0YS9kYXRhTWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDN0MsT0FBTyxFQUEwQyx3QkFBd0IsRUFBRSxtQ0FBbUMsRUFBZSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUUzSyxPQUFPLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTVEOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUNsRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQjtJQUNoQyxPQUFPLGFBQWE7U0FDZixPQUFPLENBQUMsQ0FBQyxTQUF3QixFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUNqRSxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBYTtJQUM5QyxPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUF3QixFQUFFLEVBQUUsQ0FDbkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUMzQyxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLEtBQUssQ0FDL0MsQ0FDSixDQUFDO0FBQ04sQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUFDLEtBQWE7SUFDdkMsT0FB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U0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3ZHLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FBSSxHQUFtQixFQUFFLElBQWE7SUFDekUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMzQixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDM0MsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnRXhwIH0gZnJvbSBcInNyYy90aWt6amF4L3Rpa3pqYXhcIjtcclxuaW1wb3J0IHsgQXNzb2NpYXRpdml0eSwgTWF0aEpheE9wZXJhdG9yTWV0YWRhdGEsIG1hdGhKYXhPcGVyYXRvcnNNZXRhZGF0YSwgb3BlcmF0b3JzV2l0aEltcGxpY2l0TXVsdGlwbGljYXRpb24sT3BlcmF0b3JUeXBlLCBvcGVyYXRvck5hbWVzIH0gZnJvbSBcIi4vbWF0aFBhcnNlclN0YXRpY0RhdGFcIjtcclxuaW1wb3J0IHsgQnJhY2tldFR5cGUgfSBmcm9tIFwiLi9lbmNhc2luZ3NcIjtcclxuaW1wb3J0IHsgYnJhY2tldHMsIExhdGV4TWV0YWRhdGEgfSBmcm9tIFwiLi9sYXRleFN0YXRpY0RhdGFcIjtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGVzIGEgc3RyaW5nIGZvciBzYWZlIHVzZSBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBlc2NhcGVkIHN0cmluZy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlc2NhcGVGb3JSZWdleCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhbGwgVGlrWiBjb21wb25lbnRzIGFzIGFuIGFycmF5IG9mIHJlZ2V4LXJlYWR5IHN0cmluZ3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBlc2NhcGVkIFRpa1ogY29tcG9uZW50IHJlZmVyZW5jZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVGlrelJlZmVyZW5jZXMoKSB7XHJcbiAgICByZXR1cm4gTGF0ZXhNZXRhZGF0YVxyXG4gICAgICAgIC5mbGF0TWFwKChjb21wb25lbnQ6IExhdGV4TWV0YWRhdGEpID0+IGNvbXBvbmVudC5yZWZlcmVuY2VzIHx8IFtdKVxyXG4gICAgICAgIC5tYXAoZXNjYXBlRm9yUmVnZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgVGlrWiBjb21wb25lbnRzIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBUaWtaIGNvbXBvbmVudCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFRpa3pDb21wb25lbnRzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBMYXRleE1ldGFkYXRhLmZpbmQoKGNvbXBvbmVudDogTGF0ZXhNZXRhZGF0YSkgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKGNvbXBvbmVudCkuZmxhdCgpLnNvbWUoKHZhbHVlKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBxdWVyeVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyBzeW1ib2xzIChtYXRoIG9wZXJhdG9ycyBhbmQgYnJhY2tldHMpIGZvciBhIHNwZWNpZmljIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgcXVlcnkgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH0gLSBUaGUgbWF0Y2hlZCBzeW1ib2wgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hTeW1ib2xzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLCAuLi5icmFja2V0c10uZmluZCgoc3ltYm9sKSA9PlxyXG4gICAgICAgIE9iamVjdC52YWx1ZXMoc3ltYm9sKS5zb21lKCh2YWx1ZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcyhxdWVyeSlcclxuICAgICAgICApXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgbWF0aCBvcGVyYXRvcnMgZm9yIGEgc3BlY2lmaWMgcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgdW5kZWZpbmVkfSAtIFRoZSBtYXRjaGVkIG9wZXJhdG9yIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoTWF0aEpheE9wZXJhdG9ycyhxdWVyeTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLmZpbmQoKG9wZXJhdG9yKSA9PlxyXG4gICAgICAgIE9iamVjdC52YWx1ZXMob3BlcmF0b3IpLmZsYXQoKS5zb21lKCh2YWx1ZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcyhxdWVyeSlcclxuICAgICAgICApXHJcbiAgICApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxNYXRoSmF4UmVmZXJlbmNlcygpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLCAuLi5icmFja2V0c11cclxuICAgICAgICAuZmxhdE1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQucmVmZXJlbmNlcyB8fCBbXSlcclxuICAgICAgICAubWFwKGVzY2FwZUZvclJlZ2V4KTtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGFsbCBNYXRoSmF4IG9wZXJhdG9ycyBhbmQgYnJhY2tldHMgYXMgcmVnZXgtcmVhZHkgc3RyaW5ncy5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIGVzY2FwZWQgTWF0aEpheCBvcGVyYXRvciBhbmQgYnJhY2tldCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEFsbE1hdGhKYXhPcGVyYXRvcnNBbmRTeW1ib2xzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBbLi4ubWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLCAuLi5icmFja2V0c11cclxuICAgIC5maW5kKChvcGVyYXRvcikgPT5cclxuICAgICAgICBPYmplY3QudmFsdWVzKG9wZXJhdG9yKS5mbGF0KCkuc29tZSgodmFsdWUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMocXVlcnkpXHJcbiAgICAgICAgKSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBNYXRoSmF4IG9wZXJhdG9ycyBieSBwcmlvcml0eSBsZXZlbC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5TGV2ZWwgLSBUaGUgcHJpb3JpdHkgbGV2ZWwgdG8gZmlsdGVyIGJ5LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRvUmVnZXggLSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0cyBhcyByZWdleC5cclxuICogQHJldHVybnMge3N0cmluZ1tdIHwgUmVnRXhwW119IC0gQXJyYXkgb2Ygb3BlcmF0b3IgbmFtZXMgb3IgcmVnZXggcGF0dGVybnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF0aEpheE9wZXJhdG9yc0J5UHJpb3JpdHkocHJpb3JpdHlMZXZlbDogbnVtYmVyLCB0b1JlZ2V4ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHByaW9yaXRpemVkID0gbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhXHJcbiAgICAgICAgLmZpbHRlcigob3BlcmF0b3IpID0+IG9wZXJhdG9yLnByaW9yaXR5ID09PSBwcmlvcml0eUxldmVsKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxuICAgIHJldHVybiB0b1JlZ2V4ID8gcmVnRXhwKHByaW9yaXRpemVkKSA6IHByaW9yaXRpemVkO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIG9wZXJhdG9yIGhhcyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRvciB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgb3BlcmF0b3IgaGFzIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ltcGxpY2l0TXVsdGlwbGljYXRpb24ob3BlcmF0b3JOYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IG9wZXJhdG9yID0gbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhLmZpbmQoKG9wKSA9PiBvcC5uYW1lID09PSBvcGVyYXRvck5hbWUpO1xyXG4gICAgcmV0dXJuIG9wZXJhdG9yID8gZ2V0T3BlcmF0b3JOYW1lc0J5VHlwZShvcGVyYXRvcnNXaXRoSW1wbGljaXRNdWx0aXBsaWNhdGlvbikuaW5jbHVkZXMob3BlcmF0b3IudHlwZSkgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0T3BlcmF0b3JOYW1lc0J5VHlwZShvcGVyYXRvclR5cGVzOiBPcGVyYXRvclR5cGV8T3BlcmF0b3JUeXBlW10pe1xyXG4gICAgaWYoIUFycmF5LmlzQXJyYXkob3BlcmF0b3JUeXBlcykpe1xyXG4gICAgICAgIG9wZXJhdG9yVHlwZXM9W29wZXJhdG9yVHlwZXNdXHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3BlcmF0b3JUeXBlcy5tYXAodHlwZT0+IG9wZXJhdG9yTmFtZXMuZ2V0KHR5cGUpKS5mbGF0KCk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLm9yIGhlbHBlciBmdW5jdGlvbnMgdG8gcmV0cmlldmUgdGhlIHN0YXRpYyBkYXRhIGJhc2VkIG9uLnBhcmVudGhlc2VzLmJyYWNrZXRzIGFuZCBzaWRpZXMgXHJcbiAqIGluc2lkZSB0aGUgc3RhdGljRGF0YS50cyBmaWxlLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIG9wZXJhdG9ycyBieSBhc3NvY2lhdGl2aXR5IChzaWRlKS5cclxuICogQHBhcmFtIHtBc3NvY2lhdGl2aXR5fSBzaWRlIC0gVGhlIGFzc29jaWF0aXZpdHkgc2lkZSB0byBmaWx0ZXIgYnkgKGUuZy4sICdsZWZ0JywgJ3JpZ2h0JywgJ2RvdWJsZVJpZ2h0JykuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcGVyYXRvciBuYW1lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHNpZGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0b3JzQnlBc3NvY2lhdGl2aXR5KHNpZGU6IG51bWJlcnxudW1iZXJbXSk6IHN0cmluZ1tdIHtcclxuICAgIGlmKHNpZGUgaW5zdGFuY2VvZiBBcnJheSl7XHJcbiAgICAgICAgcmV0dXJuIHNpZGUuZmxhdE1hcCgocykgPT4gZ2V0T3BlcmF0b3JzQnlBc3NvY2lhdGl2aXR5KHMpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRoSmF4T3BlcmF0b3JzTWV0YWRhdGFcclxuICAgICAgICAuZmlsdGVyKChvcGVyYXRvcikgPT4gb3BlcmF0b3IuYXNzb2NpYXRpdml0eS5wb3NpdGlvbnMuaGFzKHNpZGUpKVxyXG4gICAgICAgIC5tYXAoKG9wZXJhdG9yKSA9PiBvcGVyYXRvci5uYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBvcGVyYXRvcnMgYnkgYnJhY2tldCB0eXBlLlxyXG4gKiBAcGFyYW0ge0JyYWNrZXRUeXBlfSBicmFja2V0IC0gVGhlIGJyYWNrZXQgdHlwZSB0byBmaWx0ZXIgYnkgKGUuZy4sICdwYXJlbnRoZXNlcycsICdub25lJykuXHJcbiAqIEBwYXJhbSB7QXNzb2NpYXRpdml0eX0gc2lkZSAtIFRoZSBzaWRlIHRvIGNoZWNrIGZvciB0aGUgc3BlY2lmaWVkIGJyYWNrZXQgdHlwZS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIG9wZXJhdG9yIG5hbWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgYnJhY2tldCB0eXBlIGFuZCBzaWRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdG9yc0J5QnJhY2tldFR5cGUoXHJcbiAgICBicmFja2V0OiBCcmFja2V0VHlwZSxcclxuICAgIHNpZGU6IG51bWJlclxyXG4pOiBzdHJpbmdbXSB7XHJcbiAgICByZXR1cm4gbWF0aEpheE9wZXJhdG9yc01ldGFkYXRhXHJcbiAgICAgICAgLmZpbHRlcihcclxuICAgICAgICAgICAgKG9wZXJhdG9yKSA9PlxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IuYXNzb2NpYXRpdml0eS5wb3NpdGlvbnMuZ2V0KHNpZGUpPy5icmFja2V0VHlwZSA9PT0gYnJhY2tldFxyXG4gICAgICAgIClcclxuICAgICAgICAubWFwKChvcGVyYXRvcikgPT4gb3BlcmF0b3IubmFtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBtYXRjaGVzIGFueSBvcGVyYXRvciB3aXRoIHRoZSBzcGVjaWZpZWQgYXNzb2NpYXRpdml0aWVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSB7QXNzb2NpYXRpdml0eVtdfSBzaWRlcyAtIFRoZSBhc3NvY2lhdGl2aXR5IHNpZGVzIHRvIGNoZWNrIChlLmcuLCBbJ2xlZnQnLCAncmlnaHQnXSkuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHZhbHVlIG1hdGNoZXMgYW55IG9wZXJhdG9yIHdpdGggdGhlIHNwZWNpZmllZCBhc3NvY2lhdGl2aXRpZXMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmF0b3JXaXRoQXNzb2NpYXRpdml0eSh2YWx1ZTogc3RyaW5nLCBzaWRlczogbnVtYmVyW10sIGFic29sdXRlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3BlcmF0b3JzID0gc2lkZXMubWFwKChzaWRlKSA9PiBnZXRPcGVyYXRvcnNCeUFzc29jaWF0aXZpdHkoc2lkZSkuaW5jbHVkZXModmFsdWUpKTtcclxuICAgIHJldHVybiBhYnNvbHV0ZSA/IG9wZXJhdG9ycy5ldmVyeSgob3BlcmF0b3IpID0+IG9wZXJhdG9yKSA6IG9wZXJhdG9ycy5zb21lKChvcGVyYXRvcikgPT4gb3BlcmF0b3IpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgbWF0Y2hlcyBhbnkgb3BlcmF0b3Igd2l0aCB0aGUgc3BlY2lmaWVkIGFzc29jaWF0aXZpdGllcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0ge0Fzc29jaWF0aXZpdHlbXX0gc2lkZXMgLSBUaGUgYXNzb2NpYXRpdml0eSBzaWRlcyB0byBjaGVjayAoZS5nLiwgWydsZWZ0JywgJ3JpZ2h0J10pLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB2YWx1ZSBtYXRjaGVzIGFueSBvcGVyYXRvciB3aXRoIHRoZSBzcGVjaWZpZWQgYXNzb2NpYXRpdml0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlc1dpdGhLZXlzQnlTaWRlPFQ+KG1hcDogTWFwPG51bWJlciwgVD4sIGxlZnQ6IGJvb2xlYW4pOiBUW10ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20obWFwLmVudHJpZXMoKSlcclxuICAgICAgICAuZmlsdGVyKChba2V5XSkgPT4gbGVmdCA/IGtleSA8IDAgOiBrZXkgPiAwKVxyXG4gICAgICAgIC5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpO1xyXG59XHJcblxyXG5cclxuXHJcbiJdfQ==