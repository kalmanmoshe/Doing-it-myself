/******/ var __webpack_modules__ = ({

/***/ "../../node_modules/trie-prefix-tree/dist/append.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/append.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = append;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function append(trie, letter, index, array) {
  var isEndWordLetter = letter === _config2.default.END_WORD;
  var isLastLetter = index === array.length - 1;

  if (isEndWordLetter && !isLastLetter) {
    trie[_config2.default.END_WORD] = 1;
    trie[_config2.default.END_WORD_REPLACER] = {};
    trie = trie[_config2.default.END_WORD_REPLACER];
  } else {
    trie[letter] = trie[letter] || {};
    trie = trie[letter];
  }

  if (isLastLetter) {
    trie[_config2.default.END_WORD] = 1;
  }

  return trie;
}
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/checkPrefix.js":
/*!***************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/checkPrefix.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkPrefix;

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/trie-prefix-tree/dist/utils.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function checkPrefix(prefixNode, prefix) {
  var input = prefix.toLowerCase().split('');
  var prefixFound = input.every(function (letter, index) {
    if (!prefixNode[letter]) {
      return false;
    }
    return prefixNode = prefixNode[letter];
  });

  return {
    prefixFound: prefixFound,
    prefixNode: prefixNode
  };
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/config.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/config.js ***!
  \**********************************************************/
/***/ ((module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = {
  END_WORD: '$',
  END_WORD_REPLACER: '9a219a89-91cd-42e2-abd5-eb113af08ca8',
  PERMS_MIN_LEN: 2
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/create.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/create.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = create;

var _append = __webpack_require__(/*! ./append */ "../../node_modules/trie-prefix-tree/dist/append.js");

var _append2 = _interopRequireDefault(_append);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function create(input) {
  if (!Array.isArray(input)) {
    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));
  }

  var trie = input.reduce(function (accumulator, item) {
    item.toLowerCase().split('').reduce(_append2.default, accumulator);

    return accumulator;
  }, {});

  return trie;
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/index.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = function (input) {
  if (!Array.isArray(input)) {
    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));
  }

  var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));

  return {
    /**
     * Get the generated raw trie object
    */
    tree: function tree() {
      return trie;
    },


    /**
     * Get a string representation of the trie
    */
    dump: function dump() {
      var spacer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return _utils2.default.stringify(trie, spacer);
    },


    /**
     * Add a new word to the trie
     */
    addWord: function addWord(word) {
      if (typeof word !== 'string' || word === '') {
        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var reducer = function reducer() {
        return _append2.default.apply(undefined, arguments);
      };

      var input = word.toLowerCase().split('');
      input.reduce(reducer, trie);

      return this;
    },


    /**
     * Remove an existing word from the trie
     */
    removeWord: function removeWord(word) {
      if (typeof word !== 'string' || word === '') {
        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var _checkPrefix = (0, _checkPrefix6.default)(trie, word),
          prefixFound = _checkPrefix.prefixFound,
          prefixNode = _checkPrefix.prefixNode;

      if (prefixFound) {
        delete prefixNode[_config2.default.END_WORD];
      }

      return this;
    },


    /**
     * Check a prefix is valid
     * @returns Boolean
    */
    isPrefix: function isPrefix(prefix) {
      if (typeof prefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof prefix === 'undefined' ? 'undefined' : _typeof(prefix));
      }

      var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix),
          prefixFound = _checkPrefix2.prefixFound;

      return prefixFound;
    },


    /**
    * Get a list of all words in the trie with the given prefix
    * @returns Array
    */
    getPrefix: function getPrefix(strPrefix) {
      var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof strPrefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));
      }

      if (typeof sorted !== 'boolean') {
        throw 'Expected sort parameter as boolean, received ' + (typeof sorted === 'undefined' ? 'undefined' : _typeof(sorted));
      }

      if (!this.isPrefix(strPrefix)) {
        return [];
      }

      var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;

      return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
    },


    /**
    * Get a random word in the trie with the given prefix
    * @returns Array
    */
    getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
      if (typeof strPrefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));
      }

      if (!this.isPrefix(strPrefix)) {
        return '';
      }

      var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix),
          prefixNode = _checkPrefix3.prefixNode;

      return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
    },


    /**
    * Count the number of words with the given prefixSearch
    * @returns Number
    */
    countPrefix: function countPrefix(strPrefix) {
      var prefixes = this.getPrefix(strPrefix);

      return prefixes.length;
    },


    /**
    * Get all words in the trie
    * @returns Array
    */
    getWords: function getWords() {
      var sorted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      return this.getPrefix('', sorted);
    },


    /**
    * Check the existence of a word in the trie
    * @returns Boolean
    */
    hasWord: function hasWord(word) {
      if (typeof word !== 'string') {
        throw 'Expected string word, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word),
          prefixFound = _checkPrefix4.prefixFound,
          prefixNode = _checkPrefix4.prefixNode;

      if (prefixFound) {
        return prefixNode[_config2.default.END_WORD] === 1;
      }

      return false;
    },


    /**
    * Get a list of valid anagrams that can be made from the given letters
    * @returns Array
    */
    getAnagrams: function getAnagrams(letters) {
      if (typeof letters !== 'string') {
        throw 'Anagrams expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
      }

      if (letters.length < PERMS_MIN_LEN) {
        throw 'getAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';
      }

      return (0, _permutations2.default)(letters, trie, {
        type: 'anagram'
      });
    },


    /**
    * Get a list of all sub-anagrams that can be made from the given letters
    * @returns Array
    */
    getSubAnagrams: function getSubAnagrams(letters) {
      if (typeof letters !== 'string') {
        throw 'Expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
      }

      if (letters.length < PERMS_MIN_LEN) {
        throw 'getSubAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';
      }

      return (0, _permutations2.default)(letters, trie, {
        type: 'sub-anagram'
      });
    }
  };
};

var _create = __webpack_require__(/*! ./create */ "../../node_modules/trie-prefix-tree/dist/create.js");

var _create2 = _interopRequireDefault(_create);

var _append = __webpack_require__(/*! ./append */ "../../node_modules/trie-prefix-tree/dist/append.js");

var _append2 = _interopRequireDefault(_append);

var _checkPrefix5 = __webpack_require__(/*! ./checkPrefix */ "../../node_modules/trie-prefix-tree/dist/checkPrefix.js");

var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);

var _recursePrefix = __webpack_require__(/*! ./recursePrefix */ "../../node_modules/trie-prefix-tree/dist/recursePrefix.js");

var _recursePrefix2 = _interopRequireDefault(_recursePrefix);

var _recurseRandomWord = __webpack_require__(/*! ./recurseRandomWord */ "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js");

var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/trie-prefix-tree/dist/utils.js");

var _utils2 = _interopRequireDefault(_utils);

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

var _permutations = __webpack_require__(/*! ./permutations */ "../../node_modules/trie-prefix-tree/dist/permutations.js");

var _permutations2 = _interopRequireDefault(_permutations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;

;
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/permutations.js":
/*!****************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/permutations.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = permutations;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function permutations(letters, trie) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    type: 'anagram'
  };

  if (typeof letters !== 'string') {
    throw 'Permutations expects string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
  }

  var words = [];

  var permute = function permute(word, node) {
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    var wordIsEmpty = word.length === 0;
    var wordFound = words.indexOf(prefix) !== -1;
    var endWordFound = node[_config2.default.END_WORD] === 1;

    if (wordIsEmpty && endWordFound && !wordFound) {
      words.push(prefix);
    }

    for (var i = 0, len = word.length; i < len; i++) {
      var letter = word[i];

      if (opts.type === 'sub-anagram') {
        if (endWordFound && !(words.indexOf(prefix) !== -1)) {
          words.push(prefix);
        }
      }

      if (node[letter]) {
        var remaining = word.substring(0, i) + word.substring(i + 1, len);
        permute(remaining, node[letter], prefix + letter, words);
      }
    }

    return words.sort();
  };

  return permute(letters, trie);
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/recursePrefix.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/recursePrefix.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = recursePrefix;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// sort items as they're being found
// to prevent slow .sort() in NodeJs
var pushInOrder = function pushInOrder(word, prefixes) {
  var i = 0;

  while (i < prefixes.length) {
    if (word < prefixes[i]) {
      break;
    }
    i += 1;
  }

  prefixes.splice(i, 0, word);

  return prefixes;
};

function recursePrefix(node, prefix, sorted) {
  var prefixes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var word = prefix;

  for (var branch in node) {
    var currentLetter = branch;
    if (branch === _config2.default.END_WORD && typeof node[branch] === 'number') {
      if (sorted) {
        pushInOrder(word, prefixes);
      } else {
        prefixes.push(word);
      }
      word = '';
    } else if (branch === _config2.default.END_WORD_REPLACER) {
      currentLetter = _config2.default.END_WORD;
    }
    recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
  }

  return prefixes;
}
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = recurseRandomWord;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function recurseRandomWord(node, prefix) {
  var word = prefix;
  var branches = Object.keys(node);
  var branch = branches[Math.floor(Math.random() * branches.length)];

  if (branch === _config2.default.END_WORD) {
    return word;
  }
  return recurseRandomWord(node[branch], prefix + branch);
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/utils.js ***!
  \*********************************************************/
/***/ ((module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = {
  objectCopy: function objectCopy(obj) {
    if (typeof obj === 'undefined') {
      return {};
    }
    return JSON.parse(JSON.stringify(obj));
  },
  stringify: function stringify(obj) {
    var spacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

    if (typeof obj === 'undefined') {
      return '';
    }
    return JSON.stringify(obj, null, spacer);
  }
};
module.exports = exports['default'];

/***/ }),

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-scan/libs/prefix-match.ts":
/*!******************************************************!*\
  !*** ./unified-latex-util-scan/libs/prefix-match.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trie": () => (/* reexport default from dynamic */ trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "prefixMatch": () => (/* binding */ prefixMatch)
/* harmony export */ });
/* harmony import */ var trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trie-prefix-tree */ "../../node_modules/trie-prefix-tree/dist/index.js");
/* harmony import */ var trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");



/**
 * Efficiently search for a large number of strings using a prefix-tree.
 * The longest match is returned.
 *
 * @param options.startIndex the index to start scanning at. Defaults to 0.
 * @param options.matchSubstrings whether to allow matching only part of a substring.
 * @param options.assumeOneCharStrings assume that all strings are one character long (for example, like they are in math mode)
 */
function prefixMatch(nodes, prefixes, options) {
    const { startIndex = 0, matchSubstrings = false, assumeOneCharStrings = false, } = options || {};
    if (typeof prefixes === "string") {
        prefixes = [prefixes];
    }
    if (Array.isArray(prefixes)) {
        prefixes = trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default()(prefixes);
    }
    const prefixTree = prefixes;
    const history = {
        lastPrefix: "",
        lastWord: "",
        index: startIndex,
        partialMatch: "",
    };
    /**
     * Try to match the next character. If it matches,
     * record it properly in the `history` object.
     */
    function tryToMatchNextChar(char, index) {
        let ret = false;
        if (prefixTree.isPrefix(history.lastPrefix + char)) {
            history.lastPrefix += char;
            history.index = index;
            ret = true;
        }
        if (prefixTree.hasWord(history.lastPrefix)) {
            history.lastWord = history.lastPrefix;
        }
        return ret;
    }
    // Loop through the nodes looking for the longest prefix match
    for (let i = 0; startIndex + i < nodes.length; i++) {
        const node = nodes[startIndex + i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.string(node)) {
            break;
        }
        if (assumeOneCharStrings && node.content.length !== 1) {
            break;
        }
        if (matchSubstrings) {
            // We need to test letter-by-letter for substring matches
            let fullMatch = true;
            history.partialMatch = "";
            for (let j = 0; j < node.content.length; j++) {
                const char = node.content[j];
                if (tryToMatchNextChar(char, startIndex + i)) {
                    history.partialMatch += char;
                }
                else {
                    fullMatch = false;
                    break;
                }
            }
            if (fullMatch) {
                history.partialMatch = "";
            }
            else {
                break;
            }
        }
        else {
            if (!tryToMatchNextChar(node.content, startIndex + i)) {
                break;
            }
        }
    }
    return history.lastWord
        ? {
            match: history.lastWord,
            endNodeIndex: history.index,
            endNodePartialMatch: history.partialMatch
                ? history.partialMatch
                : null,
        }
        : null;
}


/***/ }),

/***/ "./unified-latex-util-scan/libs/scan.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-scan/libs/scan.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scan": () => (/* binding */ scan)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");


/**
 * Scan a `nodes` looking for the first occurrence of `token`.
 * If `options.onlySkipWhitespaceAndComments==true`, then the scan
 * will only skip whitespace/comment nodes.
 */
function scan(nodes, token, options) {
    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
    if (typeof token === "string") {
        token = { type: "string", content: token };
    }
    for (let i = startIndex || 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.type === token.type) {
            switch (node.type) {
                case "comment":
                case "displaymath":
                case "inlinemath":
                case "root":
                case "parbreak":
                case "whitespace":
                case "verb":
                case "verbatim":
                case "group":
                    return i;
                case "macro":
                    if (node.content === token.content) {
                        return i;
                    }
                    break;
                case "environment":
                case "mathenv":
                    if ((0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__.printRaw)(node.env) ===
                        (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__.printRaw)(token.env)) {
                        return i;
                    }
                    break;
                case "string":
                    if (node.content === token.content) {
                        return i;
                    }
                    if (allowSubstringMatches &&
                        node.content.indexOf(token.content) >= 0) {
                        return i;
                    }
                    break;
            }
        }
        if (onlySkipWhitespaceAndComments &&
            !_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) &&
            !_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            return null;
        }
    }
    return null;
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************************!*\
  !*** ./unified-latex-util-scan/index.ts ***!
  \******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trie": () => (/* reexport safe */ _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__.Trie),
/* harmony export */   "prefixMatch": () => (/* reexport safe */ _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__.prefixMatch),
/* harmony export */   "scan": () => (/* reexport safe */ _libs_scan__WEBPACK_IMPORTED_MODULE_0__.scan)
/* harmony export */ });
/* harmony import */ var _libs_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/scan */ "./unified-latex-util-scan/libs/scan.ts");
/* harmony import */ var _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/prefix-match */ "./unified-latex-util-scan/libs/prefix-match.ts");


// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to analyze `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to look for particular AST nodes in an array; useful when making plugins.
 */

})();

var __webpack_exports__Trie = __webpack_exports__.Trie;
var __webpack_exports__prefixMatch = __webpack_exports__.prefixMatch;
var __webpack_exports__scan = __webpack_exports__.scan;
export { __webpack_exports__Trie as Trie, __webpack_exports__prefixMatch as prefixMatch, __webpack_exports__scan as scan };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pZmllZC1sYXRleC11dGlsLXNjYW4vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTs7QUFFZixjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2hDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTs7QUFFZixhQUFhLG1CQUFPLENBQUMsa0VBQVM7O0FBRTlCOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMzQmE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDVmE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLHFHQUFxRyxxQkFBcUIsbUJBQW1COztBQUU3SSxrQkFBZTs7QUFFZixjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7O0FBRVA7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDN0JhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFN0ksa0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQzs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBZTs7QUFFM0M7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWlCOztBQUU5Qzs7QUFFQSx5QkFBeUIsbUJBQU8sQ0FBQywwRkFBcUI7O0FBRXREOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxrRUFBUzs7QUFFOUI7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQzs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZ0I7O0FBRTVDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLG1DQUFtQywwQkFBMEIsMENBQTBDLGdCQUFnQixPQUFPLG9CQUFvQixlQUFlLE9BQU87O0FBRXhLOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUMvUGE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLHFHQUFxRyxxQkFBcUIsbUJBQW1COztBQUU3SSxrQkFBZTs7QUFFZixjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDMURhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNwRGE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN2QmE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQnFDO0FBRXBCO0FBRVYsTUFBTSxFQUNULGNBQWMsRUFDZCxRQUFRLEVBQ1IsU0FBUyxFQUNULFFBQVEsRUFDUixhQUFhLEVBQ2IsT0FBTyxFQUNQLFdBQVcsRUFDWCxLQUFLLEVBQ0wsS0FBSyxFQUNMLElBQUksRUFDSixRQUFRLEVBQ1IsTUFBTSxFQUNOLFVBQVUsR0FDYixHQUFHLDhDQUFLLENBQUM7QUFFViwwRUFBMEU7QUFDMUU7Ozs7Ozs7O0dBUUc7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQjJEO0FBRTlEOzs7R0FHRztBQUNILFNBQVMsa0JBQWtCLENBQ3ZCLE1BQXdEO0lBRXhELGdGQUFnRjtJQUNoRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUNwQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDO1lBQ2YsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVE7Z0JBQzNCLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDakIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7d0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztxQkFDbkQ7b0JBQ0QsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQXdCLENBQUM7Z0JBQzlDLENBQUMsQ0FBQyxDQUNMO2dCQUNILENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDakIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7d0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztxQkFDbkQ7b0JBQ0QsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLElBQUksRUFBRTt3QkFDM0IsT0FBTzs0QkFDSCxLQUFLLENBQUMsT0FBTzs0QkFDYixFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFO3lCQUNkLENBQUM7cUJBQzVCO29CQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBd0IsQ0FBQztnQkFDdEQsQ0FBQyxDQUFDLENBQ0w7WUFDUCxDQUFDLENBQUMsRUFBRTtRQUNSLENBQUMsQ0FBQyxNQUFNLENBQUM7SUFFYixPQUFPLFNBQVMsa0JBQWtCLENBQUMsSUFBcUI7UUFDcEQsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ3ZDLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QscUNBQXFDO1FBQ3JDLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLElBQUksYUFBYSxJQUFJLElBQUksRUFBRTtZQUNuRCxPQUFPLENBQ0YsSUFBd0IsQ0FBQyxXQUFXLElBQUksSUFBSTtnQkFDNUMsSUFBd0IsQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FDN0QsQ0FBQztTQUNMO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBNkIsQ0FBQztBQUNsQyxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyx3QkFBd0IsQ0FBQyxNQUEwQztJQUN4RSxnRkFBZ0Y7SUFDaEYsTUFBTSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUMxQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FDZCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBc0IsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FDTDtRQUNILENBQUMsQ0FBQyxNQUFNLENBQUM7SUFFYixPQUFPLFNBQVMsd0JBQXdCLENBQUMsSUFBMkI7UUFDaEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDN0IsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCw0Q0FBNEM7UUFDNUMsTUFBTSxPQUFPLEdBQUcsdUVBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsTUFBTSxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBbUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQ7O0dBRUc7QUFDSSxNQUFNLEtBQUssR0FBRztJQUNqQixLQUFLLENBQUMsSUFBUyxFQUFFLFNBQWtCO1FBQy9CLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNkLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxDQUNILElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTztZQUNyQixDQUFDLFNBQVMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FDcEQsQ0FBQztJQUNOLENBQUM7SUFDRCxRQUFRLENBQUMsSUFBUztRQUNkLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0QsV0FBVyxDQUFDLElBQVMsRUFBRSxPQUFnQjtRQUNuQyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDZCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sQ0FDSCxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssYUFBYSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDO1lBQ3hELENBQUMsT0FBTyxJQUFJLElBQUksSUFBSSx1RUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxPQUFPLENBQUMsQ0FDdEQsQ0FBQztJQUNOLENBQUM7SUFDRCxjQUFjLENBQUMsSUFBUztRQUNwQixPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELE9BQU8sQ0FBQyxJQUFTO1FBQ2IsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2QsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDO0lBQ25DLENBQUM7SUFDRCxRQUFRLENBQUMsSUFBUztRQUNkLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNkLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQztJQUNwQyxDQUFDO0lBQ0QsVUFBVSxDQUFDLElBQVM7UUFDaEIsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2QsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDO0lBQ3RDLENBQUM7SUFDRDs7T0FFRztJQUNILGNBQWMsQ0FDVixJQUFTO1FBRVQsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2QsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLENBQ0gsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZO1lBQzFCLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLElBQUksSUFBSSxDQUFDLGlCQUFpQixLQUFLLElBQUksQ0FBQyxDQUNsRSxDQUFDO0lBQ04sQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFTLEVBQUUsS0FBYztRQUM1QixJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDZCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sQ0FDSCxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLENBQUMsQ0FDdEUsQ0FBQztJQUNOLENBQUM7SUFDRCxTQUFTLENBQUMsSUFBUztRQUNmLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBQ0QsS0FBSyxDQUFDLElBQVM7UUFDWCxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDZCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUM7SUFDakMsQ0FBQztJQUNELFFBQVEsQ0FBQyxJQUFTO1FBQ2QsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2QsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDO0lBQ3BDLENBQUM7SUFDRCxhQUFhLENBQUMsSUFBUztRQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sQ0FDSCxJQUFJLENBQUMsUUFBUSxLQUFLLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FDNUIsQ0FBQztJQUNOLENBQUM7SUFDRCxJQUFJLENBQUMsSUFBUztRQUNWLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNkLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQztJQUNyRSxDQUFDO0lBQ0Qsa0JBQWtCO0lBQ2xCLHdCQUF3QjtDQUMzQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlMK0I7QUFFakMsMEVBQTBFO0FBQzFFOzs7Ozs7OztHQVFHOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkksTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQztBQUVwQjs7Ozs7R0FLRztBQUNILFNBQVMsU0FBUyxDQUFDLElBQTZCO0lBQzVDLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNqQjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNyQixPQUFRLEVBQW1CLENBQUMsTUFBTSxDQUM5QixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFZLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUM5QyxDQUFDO0tBQ0w7SUFDRCxnQkFBZ0I7SUFDaEIsSUFBSSxVQUFVLEVBQUUsTUFBTSxDQUFDO0lBQ3ZCLFFBQVEsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNmLEtBQUssTUFBTTtZQUNQLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQyxLQUFLLFVBQVU7WUFDWCxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZFLEtBQUssU0FBUztZQUNWLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ2xELG1FQUFtRTtZQUNuRSxJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztZQUMzQixJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUN6QyxpQkFBaUIsR0FBRyxHQUFHLENBQUM7YUFDM0I7WUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2YsT0FBTztvQkFDSCxpQkFBaUI7b0JBQ2pCLEdBQUc7b0JBQ0gsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztvQkFDMUIsTUFBTTtpQkFDVCxDQUFDO2FBQ0w7WUFDRCxPQUFPLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDaEUsS0FBSyxhQUFhLENBQUM7UUFDbkIsS0FBSyxTQUFTLENBQUM7UUFDZixLQUFLLFVBQVU7WUFDWCxJQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLElBQUksUUFBUSxHQUFpQixDQUFDLE1BQU0sR0FBRyxRQUFRLEVBQUUsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDOUQsSUFBSSxNQUFNLEdBQWlCLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMxRCxVQUFVO2dCQUNMLElBQVksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBRSxJQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEUsT0FBTztnQkFDSCxHQUFHLFFBQVE7Z0JBQ1gsR0FBRyxVQUFVO2dCQUNiLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQzFCLEdBQUcsTUFBTTthQUNaLENBQUM7UUFDTixLQUFLLGFBQWE7WUFDZCxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3BFLEtBQUssT0FBTztZQUNSLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELEtBQUssWUFBWTtZQUNiLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELEtBQUssT0FBTztZQUNSLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNELE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQzlELE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUM7UUFDL0QsS0FBSyxVQUFVO1lBQ1gsT0FBTyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUNsQyxLQUFLLFFBQVE7WUFDVCxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzFCLEtBQUssTUFBTTtZQUNQLE9BQU87Z0JBQ0gsTUFBTTtnQkFDTixJQUFJLENBQUMsR0FBRztnQkFDUixJQUFJLENBQUMsTUFBTTtnQkFDWCxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO2dCQUMxQixJQUFJLENBQUMsTUFBTTthQUNkLENBQUM7UUFDTixLQUFLLFlBQVk7WUFDYixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFakI7WUFDSSxPQUFPLENBQUMsSUFBSSxDQUNSLDhCQUE4QixFQUM5QixJQUFJLEVBQ0osWUFBWSxPQUFPLElBQUksR0FBRyxDQUM3QixDQUFDO1lBQ0YsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUMxQjtBQUNMLENBQUM7QUFnQk0sU0FBUyxRQUFRLENBQUMsSUFBNkIsRUFBRSxPQUFnQjtJQUNwRSxNQUFNLE9BQU8sR0FBRyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBRSxPQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDbkUsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLElBQUksT0FBTyxFQUFFO1FBQ1QsT0FBTyxhQUFhLENBQUM7S0FDeEI7SUFDRCxPQUFPLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMzRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEhtQztBQUVtQjtBQUV2QztBQUVoQjs7Ozs7OztHQU9HO0FBQ0ksU0FBUyxXQUFXLENBQ3ZCLEtBQWlCLEVBQ2pCLFFBQXFELEVBQ3JELE9BSUM7SUFNRCxNQUFNLEVBQ0YsVUFBVSxHQUFHLENBQUMsRUFDZCxlQUFlLEdBQUcsS0FBSyxFQUN2QixvQkFBb0IsR0FBRyxLQUFLLEdBQy9CLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztJQUVsQixJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUM5QixRQUFRLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN6QjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUN6QixRQUFRLEdBQUcsdURBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3QjtJQUNELE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQztJQUU1QixNQUFNLE9BQU8sR0FBRztRQUNaLFVBQVUsRUFBRSxFQUFFO1FBQ2QsUUFBUSxFQUFFLEVBQUU7UUFDWixLQUFLLEVBQUUsVUFBVTtRQUNqQixZQUFZLEVBQUUsRUFBRTtLQUNuQixDQUFDO0lBRUY7OztPQUdHO0lBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxJQUFZLEVBQUUsS0FBYTtRQUNuRCxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUM7UUFDaEIsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUU7WUFDaEQsT0FBTyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUM7WUFDM0IsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDdEIsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNkO1FBQ0QsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN4QyxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7U0FDekM7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCw4REFBOEQ7SUFDOUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsVUFBVSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2hELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLG1FQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsTUFBTTtTQUNUO1FBQ0QsSUFBSSxvQkFBb0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbkQsTUFBTTtTQUNUO1FBQ0QsSUFBSSxlQUFlLEVBQUU7WUFDakIseURBQXlEO1lBQ3pELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQztZQUNyQixPQUFPLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztZQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdCLElBQUksa0JBQWtCLENBQUMsSUFBSSxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDMUMsT0FBTyxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUM7aUJBQ2hDO3FCQUFNO29CQUNILFNBQVMsR0FBRyxLQUFLLENBQUM7b0JBQ2xCLE1BQU07aUJBQ1Q7YUFDSjtZQUNELElBQUksU0FBUyxFQUFFO2dCQUNYLE9BQU8sQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO2FBQzdCO2lCQUFNO2dCQUNILE1BQU07YUFDVDtTQUNKO2FBQU07WUFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0JBQ25ELE1BQU07YUFDVDtTQUNKO0tBQ0o7SUFFRCxPQUFPLE9BQU8sQ0FBQyxRQUFRO1FBQ25CLENBQUMsQ0FBQztZQUNJLEtBQUssRUFBRSxPQUFPLENBQUMsUUFBUTtZQUN2QixZQUFZLEVBQUUsT0FBTyxDQUFDLEtBQUs7WUFDM0IsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLFlBQVk7Z0JBQ3JDLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWTtnQkFDdEIsQ0FBQyxDQUFDLElBQUk7U0FDYjtRQUNILENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDZixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNHc0Q7QUFDTztBQUU5RDs7OztHQUlHO0FBQ0ksU0FBUyxJQUFJLENBQ2hCLEtBQWtDLEVBQ2xDLEtBQXVDLEVBQ3ZDLE9BZUM7SUFFRCxNQUFNLEVBQUUsVUFBVSxFQUFFLDZCQUE2QixFQUFFLHFCQUFxQixFQUFFLEdBQ3RFLE9BQU8sSUFBSSxFQUFFLENBQUM7SUFDbEIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDM0IsS0FBSyxHQUFHLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFnQixDQUFDO0tBQzVEO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxVQUFVLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2pELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLElBQUksRUFBRTtZQUMxQixRQUFRLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ2YsS0FBSyxTQUFTLENBQUM7Z0JBQ2YsS0FBSyxhQUFhLENBQUM7Z0JBQ25CLEtBQUssWUFBWSxDQUFDO2dCQUNsQixLQUFLLE1BQU0sQ0FBQztnQkFDWixLQUFLLFVBQVUsQ0FBQztnQkFDaEIsS0FBSyxZQUFZLENBQUM7Z0JBQ2xCLEtBQUssTUFBTSxDQUFDO2dCQUNaLEtBQUssVUFBVSxDQUFDO2dCQUNoQixLQUFLLE9BQU87b0JBQ1IsT0FBTyxDQUFDLENBQUM7Z0JBQ2IsS0FBSyxPQUFPO29CQUNSLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBTSxLQUFtQixDQUFDLE9BQU8sRUFBRTt3QkFDL0MsT0FBTyxDQUFDLENBQUM7cUJBQ1o7b0JBQ0QsTUFBTTtnQkFDVixLQUFLLGFBQWEsQ0FBQztnQkFDbkIsS0FBSyxTQUFTO29CQUNWLElBQ0ksdUVBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO3dCQUNsQix1RUFBUSxDQUFFLEtBQXlCLENBQUMsR0FBRyxDQUFDLEVBQzFDO3dCQUNFLE9BQU8sQ0FBQyxDQUFDO3FCQUNaO29CQUNELE1BQU07Z0JBQ1YsS0FBSyxRQUFRO29CQUNULElBQUksSUFBSSxDQUFDLE9BQU8sS0FBTSxLQUFvQixDQUFDLE9BQU8sRUFBRTt3QkFDaEQsT0FBTyxDQUFDLENBQUM7cUJBQ1o7b0JBQ0QsSUFDSSxxQkFBcUI7d0JBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFFLEtBQW9CLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUMxRDt3QkFDRSxPQUFPLENBQUMsQ0FBQztxQkFDWjtvQkFDRCxNQUFNO2FBQ2I7U0FDSjtRQUNELElBQ0ksNkJBQTZCO1lBQzdCLENBQUMsdUVBQWdCLENBQUMsSUFBSSxDQUFDO1lBQ3ZCLENBQUMsb0VBQWEsQ0FBQyxJQUFJLENBQUMsRUFDdEI7WUFDRSxPQUFPLElBQUksQ0FBQztTQUNmO0tBQ0o7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDOzs7Ozs7O1NDdEZEO1NBQ0E7O1NBRUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7O1NBRUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7Ozs7O1VDdEJBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxpQ0FBaUMsV0FBVztVQUM1QztVQUNBOzs7OztVQ1BBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7O1VDQUE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNONEI7QUFDUTtBQUVwQywwRUFBMEU7QUFDMUU7Ozs7Ozs7O0dBUUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvYXBwZW5kLmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9jaGVja1ByZWZpeC5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvY29uZmlnLmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uLi8uLi9ub2RlX21vZHVsZXMvdHJpZS1wcmVmaXgtdHJlZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9wZXJtdXRhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uLi8uLi9ub2RlX21vZHVsZXMvdHJpZS1wcmVmaXgtdHJlZS9kaXN0L3JlY3Vyc2VQcmVmaXguanMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uLi8uLi9ub2RlX21vZHVsZXMvdHJpZS1wcmVmaXgtdHJlZS9kaXN0L3JlY3Vyc2VSYW5kb21Xb3JkLmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC91dGlscy5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvbGlicy9tYXRjaC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9saWJzL3ByaW50LXJhdy50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNjYW4vbGlicy9wcmVmaXgtbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zY2FuL2xpYnMvc2Nhbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNjYW4vaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXBwZW5kO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBfY29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmZpZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFwcGVuZCh0cmllLCBsZXR0ZXIsIGluZGV4LCBhcnJheSkge1xuICB2YXIgaXNFbmRXb3JkTGV0dGVyID0gbGV0dGVyID09PSBfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEO1xuICB2YXIgaXNMYXN0TGV0dGVyID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgaWYgKGlzRW5kV29yZExldHRlciAmJiAhaXNMYXN0TGV0dGVyKSB7XG4gICAgdHJpZVtfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEXSA9IDE7XG4gICAgdHJpZVtfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEX1JFUExBQ0VSXSA9IHt9O1xuICAgIHRyaWUgPSB0cmllW19jb25maWcyLmRlZmF1bHQuRU5EX1dPUkRfUkVQTEFDRVJdO1xuICB9IGVsc2Uge1xuICAgIHRyaWVbbGV0dGVyXSA9IHRyaWVbbGV0dGVyXSB8fCB7fTtcbiAgICB0cmllID0gdHJpZVtsZXR0ZXJdO1xuICB9XG5cbiAgaWYgKGlzTGFzdExldHRlcikge1xuICAgIHRyaWVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF0gPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRyaWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjaGVja1ByZWZpeDtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNoZWNrUHJlZml4KHByZWZpeE5vZGUsIHByZWZpeCkge1xuICB2YXIgaW5wdXQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKS5zcGxpdCgnJyk7XG4gIHZhciBwcmVmaXhGb3VuZCA9IGlucHV0LmV2ZXJ5KGZ1bmN0aW9uIChsZXR0ZXIsIGluZGV4KSB7XG4gICAgaWYgKCFwcmVmaXhOb2RlW2xldHRlcl0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeE5vZGUgPSBwcmVmaXhOb2RlW2xldHRlcl07XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJlZml4Rm91bmQ6IHByZWZpeEZvdW5kLFxuICAgIHByZWZpeE5vZGU6IHByZWZpeE5vZGVcbiAgfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIEVORF9XT1JEOiAnJCcsXG4gIEVORF9XT1JEX1JFUExBQ0VSOiAnOWEyMTlhODktOTFjZC00MmUyLWFiZDUtZWIxMTNhZjA4Y2E4JyxcbiAgUEVSTVNfTUlOX0xFTjogMlxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGU7XG5cbnZhciBfYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcblxudmFyIF9hcHBlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlKGlucHV0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aHJvdyAnRXhwZWN0ZWQgcGFyYW1ldGVyIEFycmF5LCByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKTtcbiAgfVxuXG4gIHZhciB0cmllID0gaW5wdXQucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgaXRlbSkge1xuICAgIGl0ZW0udG9Mb3dlckNhc2UoKS5zcGxpdCgnJykucmVkdWNlKF9hcHBlbmQyLmRlZmF1bHQsIGFjY3VtdWxhdG9yKTtcblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfSwge30pO1xuXG4gIHJldHVybiB0cmllO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHRocm93ICdFeHBlY3RlZCBwYXJhbWV0ZXIgQXJyYXksIHJlY2VpdmVkICcgKyAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpO1xuICB9XG5cbiAgdmFyIHRyaWUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpbnB1dCkpKTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZ2VuZXJhdGVkIHJhdyB0cmllIG9iamVjdFxuICAgICovXG4gICAgdHJlZTogZnVuY3Rpb24gdHJlZSgpIHtcbiAgICAgIHJldHVybiB0cmllO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJpZVxuICAgICovXG4gICAgZHVtcDogZnVuY3Rpb24gZHVtcCgpIHtcbiAgICAgIHZhciBzcGFjZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgIHJldHVybiBfdXRpbHMyLmRlZmF1bHQuc3RyaW5naWZ5KHRyaWUsIHNwYWNlcik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHdvcmQgdG8gdGhlIHRyaWVcbiAgICAgKi9cbiAgICBhZGRXb3JkOiBmdW5jdGlvbiBhZGRXb3JkKHdvcmQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd29yZCAhPT0gJ3N0cmluZycgfHwgd29yZCA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHBhcmFtZXRlciBzdHJpbmcsIHJlY2VpdmVkICcgKyAodHlwZW9mIHdvcmQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdvcmQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbiByZWR1Y2VyKCkge1xuICAgICAgICByZXR1cm4gX2FwcGVuZDIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5wdXQgPSB3b3JkLnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpO1xuICAgICAgaW5wdXQucmVkdWNlKHJlZHVjZXIsIHRyaWUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXhpc3Rpbmcgd29yZCBmcm9tIHRoZSB0cmllXG4gICAgICovXG4gICAgcmVtb3ZlV29yZDogZnVuY3Rpb24gcmVtb3ZlV29yZCh3b3JkKSB7XG4gICAgICBpZiAodHlwZW9mIHdvcmQgIT09ICdzdHJpbmcnIHx8IHdvcmQgPT09ICcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBwYXJhbWV0ZXIgc3RyaW5nLCByZWNlaXZlZCAnICsgKHR5cGVvZiB3b3JkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3b3JkKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfY2hlY2tQcmVmaXggPSAoMCwgX2NoZWNrUHJlZml4Ni5kZWZhdWx0KSh0cmllLCB3b3JkKSxcbiAgICAgICAgICBwcmVmaXhGb3VuZCA9IF9jaGVja1ByZWZpeC5wcmVmaXhGb3VuZCxcbiAgICAgICAgICBwcmVmaXhOb2RlID0gX2NoZWNrUHJlZml4LnByZWZpeE5vZGU7XG5cbiAgICAgIGlmIChwcmVmaXhGb3VuZCkge1xuICAgICAgICBkZWxldGUgcHJlZml4Tm9kZVtfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgYSBwcmVmaXggaXMgdmFsaWRcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgKi9cbiAgICBpc1ByZWZpeDogZnVuY3Rpb24gaXNQcmVmaXgocHJlZml4KSB7XG4gICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHN0cmluZyBwcmVmaXgsIHJlY2VpdmVkICcgKyAodHlwZW9mIHByZWZpeCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJlZml4KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfY2hlY2tQcmVmaXgyID0gKDAsIF9jaGVja1ByZWZpeDYuZGVmYXVsdCkodHJpZSwgcHJlZml4KSxcbiAgICAgICAgICBwcmVmaXhGb3VuZCA9IF9jaGVja1ByZWZpeDIucHJlZml4Rm91bmQ7XG5cbiAgICAgIHJldHVybiBwcmVmaXhGb3VuZDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHdvcmRzIGluIHRoZSB0cmllIHdpdGggdGhlIGdpdmVuIHByZWZpeFxuICAgICogQHJldHVybnMgQXJyYXlcbiAgICAqL1xuICAgIGdldFByZWZpeDogZnVuY3Rpb24gZ2V0UHJlZml4KHN0clByZWZpeCkge1xuICAgICAgdmFyIHNvcnRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHJQcmVmaXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcgcHJlZml4LCByZWNlaXZlZCAnICsgKHR5cGVvZiBzdHJQcmVmaXggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0clByZWZpeCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNvcnRlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBzb3J0IHBhcmFtZXRlciBhcyBib29sZWFuLCByZWNlaXZlZCAnICsgKHR5cGVvZiBzb3J0ZWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHNvcnRlZCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNQcmVmaXgoc3RyUHJlZml4KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVmaXhOb2RlID0gc3RyUHJlZml4Lmxlbmd0aCA/ICgwLCBfY2hlY2tQcmVmaXg2LmRlZmF1bHQpKHRyaWUsIHN0clByZWZpeCkucHJlZml4Tm9kZSA6IHRyaWU7XG5cbiAgICAgIHJldHVybiAoMCwgX3JlY3Vyc2VQcmVmaXgyLmRlZmF1bHQpKHByZWZpeE5vZGUsIHN0clByZWZpeCwgc29ydGVkKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIEdldCBhIHJhbmRvbSB3b3JkIGluIHRoZSB0cmllIHdpdGggdGhlIGdpdmVuIHByZWZpeFxuICAgICogQHJldHVybnMgQXJyYXlcbiAgICAqL1xuICAgIGdldFJhbmRvbVdvcmRXaXRoUHJlZml4OiBmdW5jdGlvbiBnZXRSYW5kb21Xb3JkV2l0aFByZWZpeChzdHJQcmVmaXgpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyUHJlZml4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc3RyaW5nIHByZWZpeCwgcmVjZWl2ZWQgJyArICh0eXBlb2Ygc3RyUHJlZml4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHJQcmVmaXgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzUHJlZml4KHN0clByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NoZWNrUHJlZml4MyA9ICgwLCBfY2hlY2tQcmVmaXg2LmRlZmF1bHQpKHRyaWUsIHN0clByZWZpeCksXG4gICAgICAgICAgcHJlZml4Tm9kZSA9IF9jaGVja1ByZWZpeDMucHJlZml4Tm9kZTtcblxuICAgICAgcmV0dXJuICgwLCBfcmVjdXJzZVJhbmRvbVdvcmQyLmRlZmF1bHQpKHByZWZpeE5vZGUsIHN0clByZWZpeCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIHdvcmRzIHdpdGggdGhlIGdpdmVuIHByZWZpeFNlYXJjaFxuICAgICogQHJldHVybnMgTnVtYmVyXG4gICAgKi9cbiAgICBjb3VudFByZWZpeDogZnVuY3Rpb24gY291bnRQcmVmaXgoc3RyUHJlZml4KSB7XG4gICAgICB2YXIgcHJlZml4ZXMgPSB0aGlzLmdldFByZWZpeChzdHJQcmVmaXgpO1xuXG4gICAgICByZXR1cm4gcHJlZml4ZXMubGVuZ3RoO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICogR2V0IGFsbCB3b3JkcyBpbiB0aGUgdHJpZVxuICAgICogQHJldHVybnMgQXJyYXlcbiAgICAqL1xuICAgIGdldFdvcmRzOiBmdW5jdGlvbiBnZXRXb3JkcygpIHtcbiAgICAgIHZhciBzb3J0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFByZWZpeCgnJywgc29ydGVkKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIENoZWNrIHRoZSBleGlzdGVuY2Ugb2YgYSB3b3JkIGluIHRoZSB0cmllXG4gICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgKi9cbiAgICBoYXNXb3JkOiBmdW5jdGlvbiBoYXNXb3JkKHdvcmQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHN0cmluZyB3b3JkLCByZWNlaXZlZCAnICsgKHR5cGVvZiB3b3JkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3b3JkKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfY2hlY2tQcmVmaXg0ID0gKDAsIF9jaGVja1ByZWZpeDYuZGVmYXVsdCkodHJpZSwgd29yZCksXG4gICAgICAgICAgcHJlZml4Rm91bmQgPSBfY2hlY2tQcmVmaXg0LnByZWZpeEZvdW5kLFxuICAgICAgICAgIHByZWZpeE5vZGUgPSBfY2hlY2tQcmVmaXg0LnByZWZpeE5vZGU7XG5cbiAgICAgIGlmIChwcmVmaXhGb3VuZCkge1xuICAgICAgICByZXR1cm4gcHJlZml4Tm9kZVtfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEXSA9PT0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICogR2V0IGEgbGlzdCBvZiB2YWxpZCBhbmFncmFtcyB0aGF0IGNhbiBiZSBtYWRlIGZyb20gdGhlIGdpdmVuIGxldHRlcnNcbiAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBnZXRBbmFncmFtczogZnVuY3Rpb24gZ2V0QW5hZ3JhbXMobGV0dGVycykge1xuICAgICAgaWYgKHR5cGVvZiBsZXR0ZXJzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyAnQW5hZ3JhbXMgZXhwZWN0ZWQgc3RyaW5nIGxldHRlcnMsIHJlY2VpdmVkICcgKyAodHlwZW9mIGxldHRlcnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGxldHRlcnMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldHRlcnMubGVuZ3RoIDwgUEVSTVNfTUlOX0xFTikge1xuICAgICAgICB0aHJvdyAnZ2V0QW5hZ3JhbXMgZXhwZWN0cyBhdCBsZWFzdCAnICsgUEVSTVNfTUlOX0xFTiArICcgbGV0dGVycyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3Blcm11dGF0aW9uczIuZGVmYXVsdCkobGV0dGVycywgdHJpZSwge1xuICAgICAgICB0eXBlOiAnYW5hZ3JhbSdcbiAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICogR2V0IGEgbGlzdCBvZiBhbGwgc3ViLWFuYWdyYW1zIHRoYXQgY2FuIGJlIG1hZGUgZnJvbSB0aGUgZ2l2ZW4gbGV0dGVyc1xuICAgICogQHJldHVybnMgQXJyYXlcbiAgICAqL1xuICAgIGdldFN1YkFuYWdyYW1zOiBmdW5jdGlvbiBnZXRTdWJBbmFncmFtcyhsZXR0ZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIGxldHRlcnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcgbGV0dGVycywgcmVjZWl2ZWQgJyArICh0eXBlb2YgbGV0dGVycyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobGV0dGVycykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV0dGVycy5sZW5ndGggPCBQRVJNU19NSU5fTEVOKSB7XG4gICAgICAgIHRocm93ICdnZXRTdWJBbmFncmFtcyBleHBlY3RzIGF0IGxlYXN0ICcgKyBQRVJNU19NSU5fTEVOICsgJyBsZXR0ZXJzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfcGVybXV0YXRpb25zMi5kZWZhdWx0KShsZXR0ZXJzLCB0cmllLCB7XG4gICAgICAgIHR5cGU6ICdzdWItYW5hZ3JhbSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9jcmVhdGUnKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF9hcHBlbmQgPSByZXF1aXJlKCcuL2FwcGVuZCcpO1xuXG52YXIgX2FwcGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBlbmQpO1xuXG52YXIgX2NoZWNrUHJlZml4NSA9IHJlcXVpcmUoJy4vY2hlY2tQcmVmaXgnKTtcblxudmFyIF9jaGVja1ByZWZpeDYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jaGVja1ByZWZpeDUpO1xuXG52YXIgX3JlY3Vyc2VQcmVmaXggPSByZXF1aXJlKCcuL3JlY3Vyc2VQcmVmaXgnKTtcblxudmFyIF9yZWN1cnNlUHJlZml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlY3Vyc2VQcmVmaXgpO1xuXG52YXIgX3JlY3Vyc2VSYW5kb21Xb3JkID0gcmVxdWlyZSgnLi9yZWN1cnNlUmFuZG9tV29yZCcpO1xuXG52YXIgX3JlY3Vyc2VSYW5kb21Xb3JkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlY3Vyc2VSYW5kb21Xb3JkKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIF9jb25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29uZmlnKTtcblxudmFyIF9wZXJtdXRhdGlvbnMgPSByZXF1aXJlKCcuL3Blcm11dGF0aW9ucycpO1xuXG52YXIgX3Blcm11dGF0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wZXJtdXRhdGlvbnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIFBFUk1TX01JTl9MRU4gPSBfY29uZmlnMi5kZWZhdWx0LlBFUk1TX01JTl9MRU47XG5cbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBwZXJtdXRhdGlvbnM7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIF9jb25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29uZmlnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcGVybXV0YXRpb25zKGxldHRlcnMsIHRyaWUpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICB0eXBlOiAnYW5hZ3JhbSdcbiAgfTtcblxuICBpZiAodHlwZW9mIGxldHRlcnMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgJ1Blcm11dGF0aW9ucyBleHBlY3RzIHN0cmluZyBsZXR0ZXJzLCByZWNlaXZlZCAnICsgKHR5cGVvZiBsZXR0ZXJzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihsZXR0ZXJzKSk7XG4gIH1cblxuICB2YXIgd29yZHMgPSBbXTtcblxuICB2YXIgcGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUod29yZCwgbm9kZSkge1xuICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuXG4gICAgdmFyIHdvcmRJc0VtcHR5ID0gd29yZC5sZW5ndGggPT09IDA7XG4gICAgdmFyIHdvcmRGb3VuZCA9IHdvcmRzLmluZGV4T2YocHJlZml4KSAhPT0gLTE7XG4gICAgdmFyIGVuZFdvcmRGb3VuZCA9IG5vZGVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF0gPT09IDE7XG5cbiAgICBpZiAod29yZElzRW1wdHkgJiYgZW5kV29yZEZvdW5kICYmICF3b3JkRm91bmQpIHtcbiAgICAgIHdvcmRzLnB1c2gocHJlZml4KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGxldHRlciA9IHdvcmRbaV07XG5cbiAgICAgIGlmIChvcHRzLnR5cGUgPT09ICdzdWItYW5hZ3JhbScpIHtcbiAgICAgICAgaWYgKGVuZFdvcmRGb3VuZCAmJiAhKHdvcmRzLmluZGV4T2YocHJlZml4KSAhPT0gLTEpKSB7XG4gICAgICAgICAgd29yZHMucHVzaChwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlW2xldHRlcl0pIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdvcmQuc3Vic3RyaW5nKDAsIGkpICsgd29yZC5zdWJzdHJpbmcoaSArIDEsIGxlbik7XG4gICAgICAgIHBlcm11dGUocmVtYWluaW5nLCBub2RlW2xldHRlcl0sIHByZWZpeCArIGxldHRlciwgd29yZHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3b3Jkcy5zb3J0KCk7XG4gIH07XG5cbiAgcmV0dXJuIHBlcm11dGUobGV0dGVycywgdHJpZSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVjdXJzZVByZWZpeDtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBzb3J0IGl0ZW1zIGFzIHRoZXkncmUgYmVpbmcgZm91bmRcbi8vIHRvIHByZXZlbnQgc2xvdyAuc29ydCgpIGluIE5vZGVKc1xudmFyIHB1c2hJbk9yZGVyID0gZnVuY3Rpb24gcHVzaEluT3JkZXIod29yZCwgcHJlZml4ZXMpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgcHJlZml4ZXMubGVuZ3RoKSB7XG4gICAgaWYgKHdvcmQgPCBwcmVmaXhlc1tpXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgfVxuXG4gIHByZWZpeGVzLnNwbGljZShpLCAwLCB3b3JkKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlUHJlZml4KG5vZGUsIHByZWZpeCwgc29ydGVkKSB7XG4gIHZhciBwcmVmaXhlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG5cbiAgdmFyIHdvcmQgPSBwcmVmaXg7XG5cbiAgZm9yICh2YXIgYnJhbmNoIGluIG5vZGUpIHtcbiAgICB2YXIgY3VycmVudExldHRlciA9IGJyYW5jaDtcbiAgICBpZiAoYnJhbmNoID09PSBfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEICYmIHR5cGVvZiBub2RlW2JyYW5jaF0gPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIHB1c2hJbk9yZGVyKHdvcmQsIHByZWZpeGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeGVzLnB1c2god29yZCk7XG4gICAgICB9XG4gICAgICB3b3JkID0gJyc7XG4gICAgfSBlbHNlIGlmIChicmFuY2ggPT09IF9jb25maWcyLmRlZmF1bHQuRU5EX1dPUkRfUkVQTEFDRVIpIHtcbiAgICAgIGN1cnJlbnRMZXR0ZXIgPSBfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEO1xuICAgIH1cbiAgICByZWN1cnNlUHJlZml4KG5vZGVbYnJhbmNoXSwgcHJlZml4ICsgY3VycmVudExldHRlciwgc29ydGVkLCBwcmVmaXhlcyk7XG4gIH1cblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWN1cnNlUmFuZG9tV29yZDtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiByZWN1cnNlUmFuZG9tV29yZChub2RlLCBwcmVmaXgpIHtcbiAgdmFyIHdvcmQgPSBwcmVmaXg7XG4gIHZhciBicmFuY2hlcyA9IE9iamVjdC5rZXlzKG5vZGUpO1xuICB2YXIgYnJhbmNoID0gYnJhbmNoZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYnJhbmNoZXMubGVuZ3RoKV07XG5cbiAgaWYgKGJyYW5jaCA9PT0gX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRCkge1xuICAgIHJldHVybiB3b3JkO1xuICB9XG4gIHJldHVybiByZWN1cnNlUmFuZG9tV29yZChub2RlW2JyYW5jaF0sIHByZWZpeCArIGJyYW5jaCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBvYmplY3RDb3B5OiBmdW5jdGlvbiBvYmplY3RDb3B5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG4gICAgdmFyIHNwYWNlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCBzcGFjZXIpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi9saWJzL21hdGNoXCI7XG5cbmV4cG9ydCB7IG1hdGNoIH07XG5cbmV4cG9ydCBjb25zdCB7XG4gICAgYW55RW52aXJvbm1lbnQsXG4gICAgYW55TWFjcm8sXG4gICAgYW55U3RyaW5nLFxuICAgIGFyZ3VtZW50LFxuICAgIGJsYW5rQXJndW1lbnQsXG4gICAgY29tbWVudCxcbiAgICBlbnZpcm9ubWVudCxcbiAgICBncm91cCxcbiAgICBtYWNybyxcbiAgICBtYXRoLFxuICAgIHBhcmJyZWFrLFxuICAgIHN0cmluZyxcbiAgICB3aGl0ZXNwYWNlLFxufSA9IG1hdGNoO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCBgQXN0Lk5vZGVgIHR5cGVzIGluIGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IG5lZWQgYSB0eXBlLWd1YXJkIHRvIGVuc3VyZSBhIG5vZGUgaXMgb2YgYSBjZXJ0YWluIHR5cGU7IGZvciBleGFtcGxlLCBkdXJpbmcgYSBjYWxsIHRvIGB1bmlmaWVkLWxhdGV4LXVudGlsLXZpc2l0YC5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBFbnZJbmZvLCBNYWNyb0luZm8sIE1hY3JvSW5mb1JlY29yZCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBwcmludFJhdyB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjcm9NYXRjaGVyKFxuICAgIG1hY3JvczogQXN0Lk1hY3JvW10gfCBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IG1hY3Jvc0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBtYWNyb3MubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB0eXBlb2YgbWFjcm9zWzBdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21hY3JvLCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGJyYW5jaCBvZiBtYXAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hY3JvLmVzY2FwZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm8uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGVzY2FwZVRva2VuOiBtYWNyby5lc2NhcGVUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8uY29udGVudCwge31dIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDoge31cbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0TWFjcm9zKG5vZGU6IGFueSB8IEFzdC5NYWNybykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUudHlwZSAhPT0gXCJtYWNyb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGEgbWFjcm8gdHlwZVxuICAgICAgICBjb25zdCBzcGVjID0gbWFjcm9zSGFzaFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYyA9PT0gXCJvYmplY3RcIiAmJiBcImVzY2FwZVRva2VuXCIgaW4gc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09PSBub2RlLmVzY2FwZVRva2VuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuTWFjcm8+O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYWNybyBtYXRjaGluZyBmdW5jdGlvbiB0aGF0IHVzZXMgYSBgU3BlY2lhbE1hY3JvU3BlY2Agb3IgbGlzdCBvZiBtYWNyb3NcbiAqIGFuZCBnZW5lcmF0ZXMgYSBoYXNoIGZvciBxdWljayBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcihtYWNyb3M6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IGVudmlyb25tZW50c0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKHN0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdHIsIHt9XSBhcyBbc3RyaW5nLCBFbnZJbmZvXTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIDogbWFjcm9zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoQWdhaW5zdEVudmlyb25tZW50cyhub2RlOiBhbnkgfCBBc3QuRW52aXJvbm1lbnQpIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hbnlFbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbiBlbnZpcm9ubWVudCB0eXBlXG4gICAgICAgIGNvbnN0IGVudk5hbWUgPSBwcmludFJhdyhub2RlLmVudik7XG4gICAgICAgIGNvbnN0IHNwZWMgPSBlbnZpcm9ubWVudHNIYXNoW2Vudk5hbWVdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuRW52aXJvbm1lbnQ+O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyB0byBtYXRjaCBkaWZmZXJlbnQgdHlwZXMgb2Ygbm9kZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaCA9IHtcbiAgICBtYWNybyhub2RlOiBhbnksIG1hY3JvTmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0Lk1hY3JvIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwibWFjcm9cIiAmJlxuICAgICAgICAgICAgKG1hY3JvTmFtZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gbWFjcm9OYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55TWFjcm8obm9kZTogYW55KTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICByZXR1cm4gbWF0Y2gubWFjcm8obm9kZSk7XG4gICAgfSxcbiAgICBlbnZpcm9ubWVudChub2RlOiBhbnksIGVudk5hbWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5FbnZpcm9ubWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJlbnZpcm9ubWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJtYXRoZW52XCIpICYmXG4gICAgICAgICAgICAoZW52TmFtZSA9PSBudWxsIHx8IHByaW50UmF3KG5vZGUuZW52KSA9PT0gZW52TmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueUVudmlyb25tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmVudmlyb25tZW50KG5vZGUpO1xuICAgIH0sXG4gICAgY29tbWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Db21tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiO1xuICAgIH0sXG4gICAgcGFyYnJlYWsobm9kZTogYW55KTogbm9kZSBpcyBBc3QuUGFyYnJlYWsge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJwYXJicmVha1wiO1xuICAgIH0sXG4gICAgd2hpdGVzcGFjZShub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB3aGl0ZXNwYWNlIG9yIGEgY29tbWVudCB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlTGlrZShcbiAgICAgICAgbm9kZTogYW55XG4gICAgKTogbm9kZSBpcyBBc3QuV2hpdGVzcGFjZSB8IChBc3QuQ29tbWVudCAmIHsgbGVhZGluZ1doaXRlc3BhY2U6IHRydWUgfSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgfHxcbiAgICAgICAgICAgIChub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UgPT09IHRydWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBzdHJpbmcobm9kZTogYW55LCB2YWx1ZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LlN0cmluZyB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcInN0cmluZ1wiICYmICh2YWx1ZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gdmFsdWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlTdHJpbmcobm9kZTogYW55KTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnN0cmluZyhub2RlKTtcbiAgICB9LFxuICAgIGdyb3VwKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0Lkdyb3VwIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZ3JvdXBcIjtcbiAgICB9LFxuICAgIGFyZ3VtZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkFyZ3VtZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiYXJndW1lbnRcIjtcbiAgICB9LFxuICAgIGJsYW5rQXJndW1lbnQobm9kZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghbWF0Y2guYXJndW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS5vcGVuTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jbG9zZU1hcmsgPT09IFwiXCIgJiZcbiAgICAgICAgICAgIG5vZGUuY29udGVudC5sZW5ndGggPT09IDBcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIG1hdGgobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRGlzcGxheU1hdGggfCBBc3QuSW5saW5lTWF0aCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImRpc3BsYXltYXRoXCIgfHwgbm9kZS50eXBlID09PSBcImlubGluZW1hdGhcIjtcbiAgICB9LFxuICAgIGNyZWF0ZU1hY3JvTWF0Y2hlcixcbiAgICBjcmVhdGVFbnZpcm9ubWVudE1hdGNoZXIsXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9wcmludC1yYXdcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBwcmludCBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKSB0byBhIHN0cmluZy5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIGRpcmVjdGx5IHByaW50IGFuIGBBc3QuQXN0YCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcgb3IgZm9ybWF0dGluZy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbnR5cGUgUHJpbnRhYmxlID0gQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCBzdHJpbmc7XG50eXBlIFByaW50VG9rZW4gPSBzdHJpbmcgfCB0eXBlb2YgbGluZWJyZWFrO1xuXG5leHBvcnQgY29uc3QgbGluZWJyZWFrID0gU3ltYm9sKFwibGluZWJyZWFrXCIpO1xuY29uc3QgRVNDQVBFID0gXCJcXFxcXCI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGFuIGFycmF5IGluc2VydGluZyBgbGluZWJyZWFrYCB3aGVyZSBuZWVkZWQ7XG4gKiBUaGlzIGFycmF5IG1heSBiZSBuZXN0ZWQuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKi9cbmZ1bmN0aW9uIF9wcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSk6IFByaW50VG9rZW5bXSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAoW10gYXMgUHJpbnRUb2tlbltdKS5jb25jYXQoXG4gICAgICAgICAgICAuLi5ub2RlLm1hcCgobjogUHJpbnRhYmxlKSA9PiBfcHJpbnRSYXcobikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIHRtcCB2YXJpYWJsZXNcbiAgICBsZXQgYXJnc1N0cmluZywgZXNjYXBlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICByZXR1cm4gX3ByaW50UmF3KG5vZGUuY29udGVudCk7XG4gICAgICAgIGNhc2UgXCJhcmd1bWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLm9wZW5NYXJrLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgbm9kZS5jbG9zZU1hcmtdO1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG5vZGUuc3VmZml4UGFyYnJlYWsgPyBcIlwiIDogbGluZWJyZWFrO1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyBpdHMgb3duIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICBzdWZmaXgsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBcIiVcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIHN1ZmZpeF07XG4gICAgICAgIGNhc2UgXCJlbnZpcm9ubWVudFwiOlxuICAgICAgICBjYXNlIFwibWF0aGVudlwiOlxuICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgIHZhciBlbnYgPSBfcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICAgICAgdmFyIGVudlN0YXJ0OiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJiZWdpbntcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICB2YXIgZW52RW5kOiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJlbmR7XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgYXJnc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgKG5vZGUgYXMgYW55KS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdygobm9kZSBhcyBhbnkpLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5lbnZTdGFydCxcbiAgICAgICAgICAgICAgICAuLi5hcmdzU3RyaW5nLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIC4uLmVudkVuZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJkaXNwbGF5bWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtFU0NBUEUgKyBcIltcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIEVTQ0FQRSArIFwiXVwiXTtcbiAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wie1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCJ9XCJdO1xuICAgICAgICBjYXNlIFwiaW5saW5lbWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiRcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwiJFwiXTtcbiAgICAgICAgY2FzZSBcIm1hY3JvXCI6XG4gICAgICAgICAgICBhcmdzU3RyaW5nID0gbm9kZS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdyhub2RlLmFyZ3MpO1xuICAgICAgICAgICAgZXNjYXBlID0gbm9kZS5lc2NhcGVUb2tlbiA9PSBudWxsID8gRVNDQVBFIDogbm9kZS5lc2NhcGVUb2tlbjtcbiAgICAgICAgICAgIHJldHVybiBbZXNjYXBlLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgLi4uYXJnc1N0cmluZ107XG4gICAgICAgIGNhc2UgXCJwYXJicmVha1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIGxpbmVicmVha107XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5jb250ZW50XTtcbiAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRVNDQVBFLFxuICAgICAgICAgICAgICAgIG5vZGUuZW52LFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIgXCJdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmluZCByZW5kZXIgZm9yIG5vZGUgXCIsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBgKG9mIHR5cGUgJHt0eXBlb2Ygbm9kZX0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBbXCJcIiArIG5vZGVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHsqfSBvcHRpb25zIC0gU2V0dGluZyBgYXNBcnJheWAgdG8gYHRydWVgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRoZSBzeW1ib2wgYGxpbmVicmVha2AsIHNvIHRoYXQgcHJpbnRpbmcgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zPzogeyBhc0FycmF5OiBmYWxzZSB9XG4pOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9uczogeyBhc0FycmF5OiB0cnVlIH1cbik6IFByaW50VG9rZW5bXTtcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSwgb3B0aW9ucz86IG9iamVjdCk6IGFueSB7XG4gICAgY29uc3QgYXNBcnJheSA9IG9wdGlvbnMgIT0gbnVsbCA/IChvcHRpb25zIGFzIGFueSkuYXNBcnJheSA6IGZhbHNlO1xuICAgIGNvbnN0IHByaW50ZWRUb2tlbnMgPSBfcHJpbnRSYXcobm9kZSk7XG4gICAgaWYgKGFzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHByaW50ZWRUb2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBwcmludGVkVG9rZW5zLm1hcCgoeCkgPT4gKHggPT09IGxpbmVicmVhayA/IFwiXFxuXCIgOiB4KSkuam9pbihcIlwiKTtcbn1cbiIsImltcG9ydCBUcmllIGZyb20gXCJ0cmllLXByZWZpeC10cmVlXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG5leHBvcnQgeyBUcmllIH07XG5cbi8qKlxuICogRWZmaWNpZW50bHkgc2VhcmNoIGZvciBhIGxhcmdlIG51bWJlciBvZiBzdHJpbmdzIHVzaW5nIGEgcHJlZml4LXRyZWUuXG4gKiBUaGUgbG9uZ2VzdCBtYXRjaCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5zdGFydEluZGV4IHRoZSBpbmRleCB0byBzdGFydCBzY2FubmluZyBhdC4gRGVmYXVsdHMgdG8gMC5cbiAqIEBwYXJhbSBvcHRpb25zLm1hdGNoU3Vic3RyaW5ncyB3aGV0aGVyIHRvIGFsbG93IG1hdGNoaW5nIG9ubHkgcGFydCBvZiBhIHN1YnN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zLmFzc3VtZU9uZUNoYXJTdHJpbmdzIGFzc3VtZSB0aGF0IGFsbCBzdHJpbmdzIGFyZSBvbmUgY2hhcmFjdGVyIGxvbmcgKGZvciBleGFtcGxlLCBsaWtlIHRoZXkgYXJlIGluIG1hdGggbW9kZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeE1hdGNoKFxuICAgIG5vZGVzOiBBc3QuTm9kZVtdLFxuICAgIHByZWZpeGVzOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFJldHVyblR5cGU8dHlwZW9mIFRyaWU+LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIHN0YXJ0SW5kZXg/OiBudW1iZXI7XG4gICAgICAgIG1hdGNoU3Vic3RyaW5ncz86IGJvb2xlYW47XG4gICAgICAgIGFzc3VtZU9uZUNoYXJTdHJpbmdzPzogYm9vbGVhbjtcbiAgICB9XG4pOiB7XG4gICAgbWF0Y2g6IHN0cmluZztcbiAgICBlbmROb2RlSW5kZXg6IG51bWJlcjtcbiAgICBlbmROb2RlUGFydGlhbE1hdGNoOiBzdHJpbmcgfCBudWxsO1xufSB8IG51bGwge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRJbmRleCA9IDAsXG4gICAgICAgIG1hdGNoU3Vic3RyaW5ncyA9IGZhbHNlLFxuICAgICAgICBhc3N1bWVPbmVDaGFyU3RyaW5ncyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBwcmVmaXhlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmVmaXhlcyA9IFtwcmVmaXhlc107XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHByZWZpeGVzKSkge1xuICAgICAgICBwcmVmaXhlcyA9IFRyaWUocHJlZml4ZXMpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhUcmVlID0gcHJlZml4ZXM7XG5cbiAgICBjb25zdCBoaXN0b3J5ID0ge1xuICAgICAgICBsYXN0UHJlZml4OiBcIlwiLFxuICAgICAgICBsYXN0V29yZDogXCJcIixcbiAgICAgICAgaW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgIHBhcnRpYWxNYXRjaDogXCJcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIG1hdGNoIHRoZSBuZXh0IGNoYXJhY3Rlci4gSWYgaXQgbWF0Y2hlcyxcbiAgICAgKiByZWNvcmQgaXQgcHJvcGVybHkgaW4gdGhlIGBoaXN0b3J5YCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ5VG9NYXRjaE5leHRDaGFyKGNoYXI6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgICAgIGlmIChwcmVmaXhUcmVlLmlzUHJlZml4KGhpc3RvcnkubGFzdFByZWZpeCArIGNoYXIpKSB7XG4gICAgICAgICAgICBoaXN0b3J5Lmxhc3RQcmVmaXggKz0gY2hhcjtcbiAgICAgICAgICAgIGhpc3RvcnkuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeFRyZWUuaGFzV29yZChoaXN0b3J5Lmxhc3RQcmVmaXgpKSB7XG4gICAgICAgICAgICBoaXN0b3J5Lmxhc3RXb3JkID0gaGlzdG9yeS5sYXN0UHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBub2RlcyBsb29raW5nIGZvciB0aGUgbG9uZ2VzdCBwcmVmaXggbWF0Y2hcbiAgICBmb3IgKGxldCBpID0gMDsgc3RhcnRJbmRleCArIGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbc3RhcnRJbmRleCArIGldO1xuICAgICAgICBpZiAoIW1hdGNoLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzc3VtZU9uZUNoYXJTdHJpbmdzICYmIG5vZGUuY29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFN1YnN0cmluZ3MpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGVzdCBsZXR0ZXItYnktbGV0dGVyIGZvciBzdWJzdHJpbmcgbWF0Y2hlc1xuICAgICAgICAgICAgbGV0IGZ1bGxNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBoaXN0b3J5LnBhcnRpYWxNYXRjaCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuY29udGVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBub2RlLmNvbnRlbnRbal07XG4gICAgICAgICAgICAgICAgaWYgKHRyeVRvTWF0Y2hOZXh0Q2hhcihjaGFyLCBzdGFydEluZGV4ICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5wYXJ0aWFsTWF0Y2ggKz0gY2hhcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmdWxsTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgIGhpc3RvcnkucGFydGlhbE1hdGNoID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRyeVRvTWF0Y2hOZXh0Q2hhcihub2RlLmNvbnRlbnQsIHN0YXJ0SW5kZXggKyBpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpc3RvcnkubGFzdFdvcmRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAgIG1hdGNoOiBoaXN0b3J5Lmxhc3RXb3JkLFxuICAgICAgICAgICAgICBlbmROb2RlSW5kZXg6IGhpc3RvcnkuaW5kZXgsXG4gICAgICAgICAgICAgIGVuZE5vZGVQYXJ0aWFsTWF0Y2g6IGhpc3RvcnkucGFydGlhbE1hdGNoXG4gICAgICAgICAgICAgICAgICA/IGhpc3RvcnkucGFydGlhbE1hdGNoXG4gICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgcHJpbnRSYXcgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhd1wiO1xuXG4vKipcbiAqIFNjYW4gYSBgbm9kZXNgIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB0b2tlbmAuXG4gKiBJZiBgb3B0aW9ucy5vbmx5U2tpcFdoaXRlc3BhY2VBbmRDb21tZW50cz09dHJ1ZWAsIHRoZW4gdGhlIHNjYW5cbiAqIHdpbGwgb25seSBza2lwIHdoaXRlc3BhY2UvY29tbWVudCBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW4oXG4gICAgbm9kZXM6IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXSxcbiAgICB0b2tlbjogc3RyaW5nIHwgQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IHRvIHN0YXJ0IHNjYW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbmRleD86IG51bWJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMgd2lsbCBiZSBza2lsbGVkIGJ1dCBhbnkgb3RoZXJcbiAgICAgICAgICogbm9kZSB0aGF0IGRvZXNuJ3QgbWF0Y2ggYHRva2VuYCB3aWxsIGNhdXNlIHRoZSBzY2FuIHRvIHRlcm1pbmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIG9ubHlTa2lwV2hpdGVzcGFjZUFuZENvbW1lbnRzPzogYm9vbGVhbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgd2lsbCBsb29rIGluc2lkZSBgQXN0LlN0cmluZ2Agbm9kZXMgdG8gc2VlIGlmIHRoZSBzdHJpbmcgY29udGVudHNcbiAgICAgICAgICogY29udGFpbiBgdG9rZW5gLlxuICAgICAgICAgKi9cbiAgICAgICAgYWxsb3dTdWJzdHJpbmdNYXRjaGVzPzogYm9vbGVhbjtcbiAgICB9XG4pOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIG9ubHlTa2lwV2hpdGVzcGFjZUFuZENvbW1lbnRzLCBhbGxvd1N1YnN0cmluZ01hdGNoZXMgfSA9XG4gICAgICAgIG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0b2tlbiA9IHsgdHlwZTogXCJzdHJpbmdcIiwgY29udGVudDogdG9rZW4gfSBhcyBBc3QuU3RyaW5nO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4IHx8IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlzcGxheW1hdGhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5saW5lbWF0aFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInBhcmJyZWFrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZXJiYXRpbVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudCA9PT0gKHRva2VuIGFzIEFzdC5NYWNybykuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudmlyb25tZW50XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hdGhlbnZcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRSYXcobm9kZS5lbnYpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRSYXcoKHRva2VuIGFzIEFzdC5FbnZpcm9ubWVudCkuZW52KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudCA9PT0gKHRva2VuIGFzIEFzdC5TdHJpbmcpLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3Vic3RyaW5nTWF0Y2hlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50LmluZGV4T2YoKHRva2VuIGFzIEFzdC5TdHJpbmcpLmNvbnRlbnQpID49IDBcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBvbmx5U2tpcFdoaXRlc3BhY2VBbmRDb21tZW50cyAmJlxuICAgICAgICAgICAgIW1hdGNoLndoaXRlc3BhY2Uobm9kZSkgJiZcbiAgICAgICAgICAgICFtYXRjaC5jb21tZW50KG5vZGUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3NjYW5cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvcHJlZml4LW1hdGNoXCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gYW5hbHl6ZSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBsb29rIGZvciBwYXJ0aWN1bGFyIEFTVCBub2RlcyBpbiBhbiBhcnJheTsgdXNlZnVsIHdoZW4gbWFraW5nIHBsdWdpbnMuXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==