/******/ var __webpack_modules__ = ({

/***/ "../../node_modules/trie-prefix-tree/dist/append.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/append.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = append;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function append(trie, letter, index, array) {
  var isEndWordLetter = letter === _config2.default.END_WORD;
  var isLastLetter = index === array.length - 1;

  if (isEndWordLetter && !isLastLetter) {
    trie[_config2.default.END_WORD] = 1;
    trie[_config2.default.END_WORD_REPLACER] = {};
    trie = trie[_config2.default.END_WORD_REPLACER];
  } else {
    trie[letter] = trie[letter] || {};
    trie = trie[letter];
  }

  if (isLastLetter) {
    trie[_config2.default.END_WORD] = 1;
  }

  return trie;
}
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/checkPrefix.js":
/*!***************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/checkPrefix.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkPrefix;

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/trie-prefix-tree/dist/utils.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function checkPrefix(prefixNode, prefix) {
  var input = prefix.toLowerCase().split('');
  var prefixFound = input.every(function (letter, index) {
    if (!prefixNode[letter]) {
      return false;
    }
    return prefixNode = prefixNode[letter];
  });

  return {
    prefixFound: prefixFound,
    prefixNode: prefixNode
  };
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/config.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/config.js ***!
  \**********************************************************/
/***/ ((module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = {
  END_WORD: '$',
  END_WORD_REPLACER: '9a219a89-91cd-42e2-abd5-eb113af08ca8',
  PERMS_MIN_LEN: 2
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/create.js":
/*!**********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/create.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = create;

var _append = __webpack_require__(/*! ./append */ "../../node_modules/trie-prefix-tree/dist/append.js");

var _append2 = _interopRequireDefault(_append);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function create(input) {
  if (!Array.isArray(input)) {
    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));
  }

  var trie = input.reduce(function (accumulator, item) {
    item.toLowerCase().split('').reduce(_append2.default, accumulator);

    return accumulator;
  }, {});

  return trie;
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/index.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = function (input) {
  if (!Array.isArray(input)) {
    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));
  }

  var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));

  return {
    /**
     * Get the generated raw trie object
    */
    tree: function tree() {
      return trie;
    },


    /**
     * Get a string representation of the trie
    */
    dump: function dump() {
      var spacer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return _utils2.default.stringify(trie, spacer);
    },


    /**
     * Add a new word to the trie
     */
    addWord: function addWord(word) {
      if (typeof word !== 'string' || word === '') {
        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var reducer = function reducer() {
        return _append2.default.apply(undefined, arguments);
      };

      var input = word.toLowerCase().split('');
      input.reduce(reducer, trie);

      return this;
    },


    /**
     * Remove an existing word from the trie
     */
    removeWord: function removeWord(word) {
      if (typeof word !== 'string' || word === '') {
        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var _checkPrefix = (0, _checkPrefix6.default)(trie, word),
          prefixFound = _checkPrefix.prefixFound,
          prefixNode = _checkPrefix.prefixNode;

      if (prefixFound) {
        delete prefixNode[_config2.default.END_WORD];
      }

      return this;
    },


    /**
     * Check a prefix is valid
     * @returns Boolean
    */
    isPrefix: function isPrefix(prefix) {
      if (typeof prefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof prefix === 'undefined' ? 'undefined' : _typeof(prefix));
      }

      var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix),
          prefixFound = _checkPrefix2.prefixFound;

      return prefixFound;
    },


    /**
    * Get a list of all words in the trie with the given prefix
    * @returns Array
    */
    getPrefix: function getPrefix(strPrefix) {
      var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof strPrefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));
      }

      if (typeof sorted !== 'boolean') {
        throw 'Expected sort parameter as boolean, received ' + (typeof sorted === 'undefined' ? 'undefined' : _typeof(sorted));
      }

      if (!this.isPrefix(strPrefix)) {
        return [];
      }

      var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;

      return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
    },


    /**
    * Get a random word in the trie with the given prefix
    * @returns Array
    */
    getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
      if (typeof strPrefix !== 'string') {
        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));
      }

      if (!this.isPrefix(strPrefix)) {
        return '';
      }

      var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix),
          prefixNode = _checkPrefix3.prefixNode;

      return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
    },


    /**
    * Count the number of words with the given prefixSearch
    * @returns Number
    */
    countPrefix: function countPrefix(strPrefix) {
      var prefixes = this.getPrefix(strPrefix);

      return prefixes.length;
    },


    /**
    * Get all words in the trie
    * @returns Array
    */
    getWords: function getWords() {
      var sorted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      return this.getPrefix('', sorted);
    },


    /**
    * Check the existence of a word in the trie
    * @returns Boolean
    */
    hasWord: function hasWord(word) {
      if (typeof word !== 'string') {
        throw 'Expected string word, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));
      }

      var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word),
          prefixFound = _checkPrefix4.prefixFound,
          prefixNode = _checkPrefix4.prefixNode;

      if (prefixFound) {
        return prefixNode[_config2.default.END_WORD] === 1;
      }

      return false;
    },


    /**
    * Get a list of valid anagrams that can be made from the given letters
    * @returns Array
    */
    getAnagrams: function getAnagrams(letters) {
      if (typeof letters !== 'string') {
        throw 'Anagrams expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
      }

      if (letters.length < PERMS_MIN_LEN) {
        throw 'getAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';
      }

      return (0, _permutations2.default)(letters, trie, {
        type: 'anagram'
      });
    },


    /**
    * Get a list of all sub-anagrams that can be made from the given letters
    * @returns Array
    */
    getSubAnagrams: function getSubAnagrams(letters) {
      if (typeof letters !== 'string') {
        throw 'Expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
      }

      if (letters.length < PERMS_MIN_LEN) {
        throw 'getSubAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';
      }

      return (0, _permutations2.default)(letters, trie, {
        type: 'sub-anagram'
      });
    }
  };
};

var _create = __webpack_require__(/*! ./create */ "../../node_modules/trie-prefix-tree/dist/create.js");

var _create2 = _interopRequireDefault(_create);

var _append = __webpack_require__(/*! ./append */ "../../node_modules/trie-prefix-tree/dist/append.js");

var _append2 = _interopRequireDefault(_append);

var _checkPrefix5 = __webpack_require__(/*! ./checkPrefix */ "../../node_modules/trie-prefix-tree/dist/checkPrefix.js");

var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);

var _recursePrefix = __webpack_require__(/*! ./recursePrefix */ "../../node_modules/trie-prefix-tree/dist/recursePrefix.js");

var _recursePrefix2 = _interopRequireDefault(_recursePrefix);

var _recurseRandomWord = __webpack_require__(/*! ./recurseRandomWord */ "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js");

var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/trie-prefix-tree/dist/utils.js");

var _utils2 = _interopRequireDefault(_utils);

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

var _permutations = __webpack_require__(/*! ./permutations */ "../../node_modules/trie-prefix-tree/dist/permutations.js");

var _permutations2 = _interopRequireDefault(_permutations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;

;
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/permutations.js":
/*!****************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/permutations.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports["default"] = permutations;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function permutations(letters, trie) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    type: 'anagram'
  };

  if (typeof letters !== 'string') {
    throw 'Permutations expects string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));
  }

  var words = [];

  var permute = function permute(word, node) {
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    var wordIsEmpty = word.length === 0;
    var wordFound = words.indexOf(prefix) !== -1;
    var endWordFound = node[_config2.default.END_WORD] === 1;

    if (wordIsEmpty && endWordFound && !wordFound) {
      words.push(prefix);
    }

    for (var i = 0, len = word.length; i < len; i++) {
      var letter = word[i];

      if (opts.type === 'sub-anagram') {
        if (endWordFound && !(words.indexOf(prefix) !== -1)) {
          words.push(prefix);
        }
      }

      if (node[letter]) {
        var remaining = word.substring(0, i) + word.substring(i + 1, len);
        permute(remaining, node[letter], prefix + letter, words);
      }
    }

    return words.sort();
  };

  return permute(letters, trie);
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/recursePrefix.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/recursePrefix.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = recursePrefix;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// sort items as they're being found
// to prevent slow .sort() in NodeJs
var pushInOrder = function pushInOrder(word, prefixes) {
  var i = 0;

  while (i < prefixes.length) {
    if (word < prefixes[i]) {
      break;
    }
    i += 1;
  }

  prefixes.splice(i, 0, word);

  return prefixes;
};

function recursePrefix(node, prefix, sorted) {
  var prefixes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var word = prefix;

  for (var branch in node) {
    var currentLetter = branch;
    if (branch === _config2.default.END_WORD && typeof node[branch] === 'number') {
      if (sorted) {
        pushInOrder(word, prefixes);
      } else {
        prefixes.push(word);
      }
      word = '';
    } else if (branch === _config2.default.END_WORD_REPLACER) {
      currentLetter = _config2.default.END_WORD;
    }
    recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
  }

  return prefixes;
}
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = recurseRandomWord;

var _config = __webpack_require__(/*! ./config */ "../../node_modules/trie-prefix-tree/dist/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function recurseRandomWord(node, prefix) {
  var word = prefix;
  var branches = Object.keys(node);
  var branch = branches[Math.floor(Math.random() * branches.length)];

  if (branch === _config2.default.END_WORD) {
    return word;
  }
  return recurseRandomWord(node[branch], prefix + branch);
};
module.exports = exports['default'];

/***/ }),

/***/ "../../node_modules/trie-prefix-tree/dist/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/trie-prefix-tree/dist/utils.js ***!
  \*********************************************************/
/***/ ((module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = {
  objectCopy: function objectCopy(obj) {
    if (typeof obj === 'undefined') {
      return {};
    }
    return JSON.parse(JSON.stringify(obj));
  },
  stringify: function stringify(obj) {
    var spacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

    if (typeof obj === 'undefined') {
      return '';
    }
    return JSON.stringify(obj, null, spacer);
  }
};
module.exports = exports['default'];

/***/ }),

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-scan/libs/prefix-match.ts":
/*!******************************************************!*\
  !*** ./unified-latex-util-scan/libs/prefix-match.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trie": () => (/* reexport default from dynamic */ trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "prefixMatch": () => (/* binding */ prefixMatch)
/* harmony export */ });
/* harmony import */ var trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trie-prefix-tree */ "../../node_modules/trie-prefix-tree/dist/index.js");
/* harmony import */ var trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");



/**
 * Efficiently search for a large number of strings using a prefix-tree.
 * The longest match is returned.
 *
 * @param options.startIndex the index to start scanning at. Defaults to 0.
 * @param options.matchSubstrings whether to allow matching only part of a substring.
 * @param options.assumeOneCharStrings assume that all strings are one character long (for example, like they are in math mode)
 */
function prefixMatch(nodes, prefixes, options) {
    const { startIndex = 0, matchSubstrings = false, assumeOneCharStrings = false, } = options || {};
    if (typeof prefixes === "string") {
        prefixes = [prefixes];
    }
    if (Array.isArray(prefixes)) {
        prefixes = trie_prefix_tree__WEBPACK_IMPORTED_MODULE_0___default()(prefixes);
    }
    const prefixTree = prefixes;
    const history = {
        lastPrefix: "",
        lastWord: "",
        index: startIndex,
        partialMatch: "",
    };
    /**
     * Try to match the next character. If it matches,
     * record it properly in the `history` object.
     */
    function tryToMatchNextChar(char, index) {
        let ret = false;
        if (prefixTree.isPrefix(history.lastPrefix + char)) {
            history.lastPrefix += char;
            history.index = index;
            ret = true;
        }
        if (prefixTree.hasWord(history.lastPrefix)) {
            history.lastWord = history.lastPrefix;
        }
        return ret;
    }
    // Loop through the nodes looking for the longest prefix match
    for (let i = 0; startIndex + i < nodes.length; i++) {
        const node = nodes[startIndex + i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.string(node)) {
            break;
        }
        if (assumeOneCharStrings && node.content.length !== 1) {
            break;
        }
        if (matchSubstrings) {
            // We need to test letter-by-letter for substring matches
            let fullMatch = true;
            history.partialMatch = "";
            for (let j = 0; j < node.content.length; j++) {
                const char = node.content[j];
                if (tryToMatchNextChar(char, startIndex + i)) {
                    history.partialMatch += char;
                }
                else {
                    fullMatch = false;
                    break;
                }
            }
            if (fullMatch) {
                history.partialMatch = "";
            }
            else {
                break;
            }
        }
        else {
            if (!tryToMatchNextChar(node.content, startIndex + i)) {
                break;
            }
        }
    }
    return history.lastWord
        ? {
            match: history.lastWord,
            endNodeIndex: history.index,
            endNodePartialMatch: history.partialMatch
                ? history.partialMatch
                : null,
        }
        : null;
}


/***/ }),

/***/ "./unified-latex-util-scan/libs/scan.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-scan/libs/scan.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scan": () => (/* binding */ scan)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");


/**
 * Scan a `nodes` looking for the first occurrence of `token`.
 * If `options.onlySkipWhitespaceAndComments==true`, then the scan
 * will only skip whitespace/comment nodes.
 */
function scan(nodes, token, options) {
    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
    if (typeof token === "string") {
        token = { type: "string", content: token };
    }
    for (let i = startIndex || 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.type === token.type) {
            switch (node.type) {
                case "comment":
                case "displaymath":
                case "inlinemath":
                case "root":
                case "parbreak":
                case "whitespace":
                case "verb":
                case "verbatim":
                case "group":
                    return i;
                case "macro":
                    if (node.content === token.content) {
                        return i;
                    }
                    break;
                case "environment":
                case "mathenv":
                    if ((0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__.printRaw)(node.env) ===
                        (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_1__.printRaw)(token.env)) {
                        return i;
                    }
                    break;
                case "string":
                    if (node.content === token.content) {
                        return i;
                    }
                    if (allowSubstringMatches &&
                        node.content.indexOf(token.content) >= 0) {
                        return i;
                    }
                    break;
            }
        }
        if (onlySkipWhitespaceAndComments &&
            !_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) &&
            !_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            return null;
        }
    }
    return null;
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************************!*\
  !*** ./unified-latex-util-scan/index.ts ***!
  \******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trie": () => (/* reexport safe */ _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__.Trie),
/* harmony export */   "prefixMatch": () => (/* reexport safe */ _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__.prefixMatch),
/* harmony export */   "scan": () => (/* reexport safe */ _libs_scan__WEBPACK_IMPORTED_MODULE_0__.scan)
/* harmony export */ });
/* harmony import */ var _libs_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/scan */ "./unified-latex-util-scan/libs/scan.ts");
/* harmony import */ var _libs_prefix_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/prefix-match */ "./unified-latex-util-scan/libs/prefix-match.ts");


// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to analyze `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to look for particular AST nodes in an array; useful when making plugins.
 */

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pZmllZC1sYXRleC11dGlsLXNjYW4vaW5kZXguY2pzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNoQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsYUFBYSxtQkFBTyxDQUFDLGtFQUFTOztBQUU5Qjs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDM0JhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ1ZhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFN0ksa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJOztBQUVQO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzdCYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYscUdBQXFHLHFCQUFxQixtQkFBbUI7O0FBRTdJLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDOztBQUVBLGNBQWMsbUJB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Q0FBQztxQkFDWjtvQkFDRCxNQUFNO2dCQUNWLEtBQUssUUFBUTtvQkFDVCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQU0sS0FBb0IsQ0FBQyxPQUFPLEVBQUU7d0JBQ2hELE9BQU8sQ0FBQyxDQUFDO3FCQUNaO29CQUNELElBQ0kscUJBQXFCO3dCQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBRSxLQUFvQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFDMUQ7d0JBQ0UsT0FBTyxDQUFDLENBQUM7cUJBQ1o7b0JBQ0QsTUFBTTthQUNiO1NBQ0o7UUFDRCxJQUNJLDZCQUE2QjtZQUM3QixDQUFDLHVFQUFnQixDQUFDLElBQUksQ0FBQztZQUN2QixDQUFDLG9FQUFhLENBQUMsSUFBSSxDQUFDLEVBQ3RCO1lBQ0UsT0FBTyxJQUFJLENBQUM7U0FDZjtLQUNKO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQzs7Ozs7OztTQ3RGRDtTQUNBOztTQUVBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBOztTQUVBO1NBQ0E7O1NBRUE7U0FDQTtTQUNBOzs7OztVQ3RCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsaUNBQWlDLFdBQVc7VUFDNUM7VUFDQTs7Ozs7VUNQQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLHlDQUF5Qyx3Q0FBd0M7VUFDakY7VUFDQTtVQUNBOzs7OztVQ1BBOzs7OztVQ0FBO1VBQ0E7VUFDQTtVQUNBLHVEQUF1RCxpQkFBaUI7VUFDeEU7VUFDQSxnREFBZ0QsYUFBYTtVQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTjRCO0FBQ1E7QUFFcEMsMEVBQTBFO0FBQzFFOzs7Ozs7OztHQVFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uLi8uLi9ub2RlX21vZHVsZXMvdHJpZS1wcmVmaXgtdHJlZS9kaXN0L2FwcGVuZC5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvY2hlY2tQcmVmaXguanMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uLi8uLi9ub2RlX21vZHVsZXMvdHJpZS1wcmVmaXgtdHJlZS9kaXN0L2NvbmZpZy5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvY3JlYXRlLmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvcGVybXV0YXRpb25zLmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9yZWN1cnNlUHJlZml4LmpzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi4vLi4vbm9kZV9tb2R1bGVzL3RyaWUtcHJlZml4LXRyZWUvZGlzdC9yZWN1cnNlUmFuZG9tV29yZC5qcyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4uLy4uL25vZGVfbW9kdWxlcy90cmllLXByZWZpeC10cmVlL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2xpYnMvbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvbGlicy9wcmludC1yYXcudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zY2FuL2xpYnMvcHJlZml4LW1hdGNoLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc2Nhbi9saWJzL3NjYW4udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zY2FuL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFwcGVuZDtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhcHBlbmQodHJpZSwgbGV0dGVyLCBpbmRleCwgYXJyYXkpIHtcbiAgdmFyIGlzRW5kV29yZExldHRlciA9IGxldHRlciA9PT0gX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRDtcbiAgdmFyIGlzTGFzdExldHRlciA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuXG4gIGlmIChpc0VuZFdvcmRMZXR0ZXIgJiYgIWlzTGFzdExldHRlcikge1xuICAgIHRyaWVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF0gPSAxO1xuICAgIHRyaWVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF9SRVBMQUNFUl0gPSB7fTtcbiAgICB0cmllID0gdHJpZVtfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEX1JFUExBQ0VSXTtcbiAgfSBlbHNlIHtcbiAgICB0cmllW2xldHRlcl0gPSB0cmllW2xldHRlcl0gfHwge307XG4gICAgdHJpZSA9IHRyaWVbbGV0dGVyXTtcbiAgfVxuXG4gIGlmIChpc0xhc3RMZXR0ZXIpIHtcbiAgICB0cmllW19jb25maWcyLmRlZmF1bHQuRU5EX1dPUkRdID0gMTtcbiAgfVxuXG4gIHJldHVybiB0cmllO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tQcmVmaXg7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjaGVja1ByZWZpeChwcmVmaXhOb2RlLCBwcmVmaXgpIHtcbiAgdmFyIGlucHV0ID0gcHJlZml4LnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpO1xuICB2YXIgcHJlZml4Rm91bmQgPSBpbnB1dC5ldmVyeShmdW5jdGlvbiAobGV0dGVyLCBpbmRleCkge1xuICAgIGlmICghcHJlZml4Tm9kZVtsZXR0ZXJdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwcmVmaXhOb2RlID0gcHJlZml4Tm9kZVtsZXR0ZXJdO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHByZWZpeEZvdW5kOiBwcmVmaXhGb3VuZCxcbiAgICBwcmVmaXhOb2RlOiBwcmVmaXhOb2RlXG4gIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBFTkRfV09SRDogJyQnLFxuICBFTkRfV09SRF9SRVBMQUNFUjogJzlhMjE5YTg5LTkxY2QtNDJlMi1hYmQ1LWViMTEzYWYwOGNhOCcsXG4gIFBFUk1TX01JTl9MRU46IDJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlO1xuXG52YXIgX2FwcGVuZCA9IHJlcXVpcmUoJy4vYXBwZW5kJyk7XG5cbnZhciBfYXBwZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGVuZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZShpbnB1dCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhyb3cgJ0V4cGVjdGVkIHBhcmFtZXRlciBBcnJheSwgcmVjZWl2ZWQgJyArICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSk7XG4gIH1cblxuICB2YXIgdHJpZSA9IGlucHV0LnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGl0ZW0pIHtcbiAgICBpdGVtLnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpLnJlZHVjZShfYXBwZW5kMi5kZWZhdWx0LCBhY2N1bXVsYXRvcik7XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gdHJpZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aHJvdyAnRXhwZWN0ZWQgcGFyYW1ldGVyIEFycmF5LCByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKTtcbiAgfVxuXG4gIHZhciB0cmllID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5wdXQpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdlbmVyYXRlZCByYXcgdHJpZSBvYmplY3RcbiAgICAqL1xuICAgIHRyZWU6IGZ1bmN0aW9uIHRyZWUoKSB7XG4gICAgICByZXR1cm4gdHJpZTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyaWVcbiAgICAqL1xuICAgIGR1bXA6IGZ1bmN0aW9uIGR1bXAoKSB7XG4gICAgICB2YXIgc3BhY2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgICByZXR1cm4gX3V0aWxzMi5kZWZhdWx0LnN0cmluZ2lmeSh0cmllLCBzcGFjZXIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyB3b3JkIHRvIHRoZSB0cmllXG4gICAgICovXG4gICAgYWRkV29yZDogZnVuY3Rpb24gYWRkV29yZCh3b3JkKSB7XG4gICAgICBpZiAodHlwZW9mIHdvcmQgIT09ICdzdHJpbmcnIHx8IHdvcmQgPT09ICcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBwYXJhbWV0ZXIgc3RyaW5nLCByZWNlaXZlZCAnICsgKHR5cGVvZiB3b3JkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3b3JkKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24gcmVkdWNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9hcHBlbmQyLmRlZmF1bHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGlucHV0ID0gd29yZC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcnKTtcbiAgICAgIGlucHV0LnJlZHVjZShyZWR1Y2VyLCB0cmllKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV4aXN0aW5nIHdvcmQgZnJvbSB0aGUgdHJpZVxuICAgICAqL1xuICAgIHJlbW92ZVdvcmQ6IGZ1bmN0aW9uIHJlbW92ZVdvcmQod29yZCkge1xuICAgICAgaWYgKHR5cGVvZiB3b3JkICE9PSAnc3RyaW5nJyB8fCB3b3JkID09PSAnJykge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgcGFyYW1ldGVyIHN0cmluZywgcmVjZWl2ZWQgJyArICh0eXBlb2Ygd29yZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod29yZCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NoZWNrUHJlZml4ID0gKDAsIF9jaGVja1ByZWZpeDYuZGVmYXVsdCkodHJpZSwgd29yZCksXG4gICAgICAgICAgcHJlZml4Rm91bmQgPSBfY2hlY2tQcmVmaXgucHJlZml4Rm91bmQsXG4gICAgICAgICAgcHJlZml4Tm9kZSA9IF9jaGVja1ByZWZpeC5wcmVmaXhOb2RlO1xuXG4gICAgICBpZiAocHJlZml4Rm91bmQpIHtcbiAgICAgICAgZGVsZXRlIHByZWZpeE5vZGVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGEgcHJlZml4IGlzIHZhbGlkXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICovXG4gICAgaXNQcmVmaXg6IGZ1bmN0aW9uIGlzUHJlZml4KHByZWZpeCkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcgcHJlZml4LCByZWNlaXZlZCAnICsgKHR5cGVvZiBwcmVmaXggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByZWZpeCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NoZWNrUHJlZml4MiA9ICgwLCBfY2hlY2tQcmVmaXg2LmRlZmF1bHQpKHRyaWUsIHByZWZpeCksXG4gICAgICAgICAgcHJlZml4Rm91bmQgPSBfY2hlY2tQcmVmaXgyLnByZWZpeEZvdW5kO1xuXG4gICAgICByZXR1cm4gcHJlZml4Rm91bmQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB3b3JkcyBpbiB0aGUgdHJpZSB3aXRoIHRoZSBnaXZlbiBwcmVmaXhcbiAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBnZXRQcmVmaXg6IGZ1bmN0aW9uIGdldFByZWZpeChzdHJQcmVmaXgpIHtcbiAgICAgIHZhciBzb3J0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RyUHJlZml4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc3RyaW5nIHByZWZpeCwgcmVjZWl2ZWQgJyArICh0eXBlb2Ygc3RyUHJlZml4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHJQcmVmaXgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzb3J0ZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc29ydCBwYXJhbWV0ZXIgYXMgYm9vbGVhbiwgcmVjZWl2ZWQgJyArICh0eXBlb2Ygc29ydGVkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzb3J0ZWQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzUHJlZml4KHN0clByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJlZml4Tm9kZSA9IHN0clByZWZpeC5sZW5ndGggPyAoMCwgX2NoZWNrUHJlZml4Ni5kZWZhdWx0KSh0cmllLCBzdHJQcmVmaXgpLnByZWZpeE5vZGUgOiB0cmllO1xuXG4gICAgICByZXR1cm4gKDAsIF9yZWN1cnNlUHJlZml4Mi5kZWZhdWx0KShwcmVmaXhOb2RlLCBzdHJQcmVmaXgsIHNvcnRlZCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBHZXQgYSByYW5kb20gd29yZCBpbiB0aGUgdHJpZSB3aXRoIHRoZSBnaXZlbiBwcmVmaXhcbiAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBnZXRSYW5kb21Xb3JkV2l0aFByZWZpeDogZnVuY3Rpb24gZ2V0UmFuZG9tV29yZFdpdGhQcmVmaXgoc3RyUHJlZml4KSB7XG4gICAgICBpZiAodHlwZW9mIHN0clByZWZpeCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHN0cmluZyBwcmVmaXgsIHJlY2VpdmVkICcgKyAodHlwZW9mIHN0clByZWZpeCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3RyUHJlZml4KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc1ByZWZpeChzdHJQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIF9jaGVja1ByZWZpeDMgPSAoMCwgX2NoZWNrUHJlZml4Ni5kZWZhdWx0KSh0cmllLCBzdHJQcmVmaXgpLFxuICAgICAgICAgIHByZWZpeE5vZGUgPSBfY2hlY2tQcmVmaXgzLnByZWZpeE5vZGU7XG5cbiAgICAgIHJldHVybiAoMCwgX3JlY3Vyc2VSYW5kb21Xb3JkMi5kZWZhdWx0KShwcmVmaXhOb2RlLCBzdHJQcmVmaXgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICogQ291bnQgdGhlIG51bWJlciBvZiB3b3JkcyB3aXRoIHRoZSBnaXZlbiBwcmVmaXhTZWFyY2hcbiAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICovXG4gICAgY291bnRQcmVmaXg6IGZ1bmN0aW9uIGNvdW50UHJlZml4KHN0clByZWZpeCkge1xuICAgICAgdmFyIHByZWZpeGVzID0gdGhpcy5nZXRQcmVmaXgoc3RyUHJlZml4KTtcblxuICAgICAgcmV0dXJuIHByZWZpeGVzLmxlbmd0aDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIEdldCBhbGwgd29yZHMgaW4gdGhlIHRyaWVcbiAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBnZXRXb3JkczogZnVuY3Rpb24gZ2V0V29yZHMoKSB7XG4gICAgICB2YXIgc29ydGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICByZXR1cm4gdGhpcy5nZXRQcmVmaXgoJycsIHNvcnRlZCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBDaGVjayB0aGUgZXhpc3RlbmNlIG9mIGEgd29yZCBpbiB0aGUgdHJpZVxuICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICovXG4gICAgaGFzV29yZDogZnVuY3Rpb24gaGFzV29yZCh3b3JkKSB7XG4gICAgICBpZiAodHlwZW9mIHdvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcgd29yZCwgcmVjZWl2ZWQgJyArICh0eXBlb2Ygd29yZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod29yZCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NoZWNrUHJlZml4NCA9ICgwLCBfY2hlY2tQcmVmaXg2LmRlZmF1bHQpKHRyaWUsIHdvcmQpLFxuICAgICAgICAgIHByZWZpeEZvdW5kID0gX2NoZWNrUHJlZml4NC5wcmVmaXhGb3VuZCxcbiAgICAgICAgICBwcmVmaXhOb2RlID0gX2NoZWNrUHJlZml4NC5wcmVmaXhOb2RlO1xuXG4gICAgICBpZiAocHJlZml4Rm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeE5vZGVbX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRF0gPT09IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIEdldCBhIGxpc3Qgb2YgdmFsaWQgYW5hZ3JhbXMgdGhhdCBjYW4gYmUgbWFkZSBmcm9tIHRoZSBnaXZlbiBsZXR0ZXJzXG4gICAgKiBAcmV0dXJucyBBcnJheVxuICAgICovXG4gICAgZ2V0QW5hZ3JhbXM6IGZ1bmN0aW9uIGdldEFuYWdyYW1zKGxldHRlcnMpIHtcbiAgICAgIGlmICh0eXBlb2YgbGV0dGVycyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0FuYWdyYW1zIGV4cGVjdGVkIHN0cmluZyBsZXR0ZXJzLCByZWNlaXZlZCAnICsgKHR5cGVvZiBsZXR0ZXJzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihsZXR0ZXJzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXR0ZXJzLmxlbmd0aCA8IFBFUk1TX01JTl9MRU4pIHtcbiAgICAgICAgdGhyb3cgJ2dldEFuYWdyYW1zIGV4cGVjdHMgYXQgbGVhc3QgJyArIFBFUk1TX01JTl9MRU4gKyAnIGxldHRlcnMnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF9wZXJtdXRhdGlvbnMyLmRlZmF1bHQpKGxldHRlcnMsIHRyaWUsIHtcbiAgICAgICAgdHlwZTogJ2FuYWdyYW0nXG4gICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHN1Yi1hbmFncmFtcyB0aGF0IGNhbiBiZSBtYWRlIGZyb20gdGhlIGdpdmVuIGxldHRlcnNcbiAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBnZXRTdWJBbmFncmFtczogZnVuY3Rpb24gZ2V0U3ViQW5hZ3JhbXMobGV0dGVycykge1xuICAgICAgaWYgKHR5cGVvZiBsZXR0ZXJzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc3RyaW5nIGxldHRlcnMsIHJlY2VpdmVkICcgKyAodHlwZW9mIGxldHRlcnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGxldHRlcnMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldHRlcnMubGVuZ3RoIDwgUEVSTVNfTUlOX0xFTikge1xuICAgICAgICB0aHJvdyAnZ2V0U3ViQW5hZ3JhbXMgZXhwZWN0cyBhdCBsZWFzdCAnICsgUEVSTVNfTUlOX0xFTiArICcgbGV0dGVycyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3Blcm11dGF0aW9uczIuZGVmYXVsdCkobGV0dGVycywgdHJpZSwge1xuICAgICAgICB0eXBlOiAnc3ViLWFuYWdyYW0nXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJyk7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcblxudmFyIF9hcHBlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kKTtcblxudmFyIF9jaGVja1ByZWZpeDUgPSByZXF1aXJlKCcuL2NoZWNrUHJlZml4Jyk7XG5cbnZhciBfY2hlY2tQcmVmaXg2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tQcmVmaXg1KTtcblxudmFyIF9yZWN1cnNlUHJlZml4ID0gcmVxdWlyZSgnLi9yZWN1cnNlUHJlZml4Jyk7XG5cbnZhciBfcmVjdXJzZVByZWZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWN1cnNlUHJlZml4KTtcblxudmFyIF9yZWN1cnNlUmFuZG9tV29yZCA9IHJlcXVpcmUoJy4vcmVjdXJzZVJhbmRvbVdvcmQnKTtcblxudmFyIF9yZWN1cnNlUmFuZG9tV29yZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWN1cnNlUmFuZG9tV29yZCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBfY29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmZpZyk7XG5cbnZhciBfcGVybXV0YXRpb25zID0gcmVxdWlyZSgnLi9wZXJtdXRhdGlvbnMnKTtcblxudmFyIF9wZXJtdXRhdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGVybXV0YXRpb25zKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBQRVJNU19NSU5fTEVOID0gX2NvbmZpZzIuZGVmYXVsdC5QRVJNU19NSU5fTEVOO1xuXG47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gcGVybXV0YXRpb25zO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBfY29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmZpZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHBlcm11dGF0aW9ucyhsZXR0ZXJzLCB0cmllKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XG4gICAgdHlwZTogJ2FuYWdyYW0nXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBsZXR0ZXJzICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93ICdQZXJtdXRhdGlvbnMgZXhwZWN0cyBzdHJpbmcgbGV0dGVycywgcmVjZWl2ZWQgJyArICh0eXBlb2YgbGV0dGVycyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobGV0dGVycykpO1xuICB9XG5cbiAgdmFyIHdvcmRzID0gW107XG5cbiAgdmFyIHBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlKHdvcmQsIG5vZGUpIHtcbiAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnJztcblxuICAgIHZhciB3b3JkSXNFbXB0eSA9IHdvcmQubGVuZ3RoID09PSAwO1xuICAgIHZhciB3b3JkRm91bmQgPSB3b3Jkcy5pbmRleE9mKHByZWZpeCkgIT09IC0xO1xuICAgIHZhciBlbmRXb3JkRm91bmQgPSBub2RlW19jb25maWcyLmRlZmF1bHQuRU5EX1dPUkRdID09PSAxO1xuXG4gICAgaWYgKHdvcmRJc0VtcHR5ICYmIGVuZFdvcmRGb3VuZCAmJiAhd29yZEZvdW5kKSB7XG4gICAgICB3b3Jkcy5wdXNoKHByZWZpeCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHdvcmQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBsZXR0ZXIgPSB3b3JkW2ldO1xuXG4gICAgICBpZiAob3B0cy50eXBlID09PSAnc3ViLWFuYWdyYW0nKSB7XG4gICAgICAgIGlmIChlbmRXb3JkRm91bmQgJiYgISh3b3Jkcy5pbmRleE9mKHByZWZpeCkgIT09IC0xKSkge1xuICAgICAgICAgIHdvcmRzLnB1c2gocHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZVtsZXR0ZXJdKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3b3JkLnN1YnN0cmluZygwLCBpKSArIHdvcmQuc3Vic3RyaW5nKGkgKyAxLCBsZW4pO1xuICAgICAgICBwZXJtdXRlKHJlbWFpbmluZywgbm9kZVtsZXR0ZXJdLCBwcmVmaXggKyBsZXR0ZXIsIHdvcmRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd29yZHMuc29ydCgpO1xuICB9O1xuXG4gIHJldHVybiBwZXJtdXRlKGxldHRlcnMsIHRyaWUpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlY3Vyc2VQcmVmaXg7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIF9jb25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29uZmlnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gc29ydCBpdGVtcyBhcyB0aGV5J3JlIGJlaW5nIGZvdW5kXG4vLyB0byBwcmV2ZW50IHNsb3cgLnNvcnQoKSBpbiBOb2RlSnNcbnZhciBwdXNoSW5PcmRlciA9IGZ1bmN0aW9uIHB1c2hJbk9yZGVyKHdvcmQsIHByZWZpeGVzKSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHByZWZpeGVzLmxlbmd0aCkge1xuICAgIGlmICh3b3JkIDwgcHJlZml4ZXNbaV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpICs9IDE7XG4gIH1cblxuICBwcmVmaXhlcy5zcGxpY2UoaSwgMCwgd29yZCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufTtcblxuZnVuY3Rpb24gcmVjdXJzZVByZWZpeChub2RlLCBwcmVmaXgsIHNvcnRlZCkge1xuICB2YXIgcHJlZml4ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuXG4gIHZhciB3b3JkID0gcHJlZml4O1xuXG4gIGZvciAodmFyIGJyYW5jaCBpbiBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnRMZXR0ZXIgPSBicmFuY2g7XG4gICAgaWYgKGJyYW5jaCA9PT0gX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRCAmJiB0eXBlb2Ygbm9kZVticmFuY2hdID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICBwdXNoSW5PcmRlcih3b3JkLCBwcmVmaXhlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhlcy5wdXNoKHdvcmQpO1xuICAgICAgfVxuICAgICAgd29yZCA9ICcnO1xuICAgIH0gZWxzZSBpZiAoYnJhbmNoID09PSBfY29uZmlnMi5kZWZhdWx0LkVORF9XT1JEX1JFUExBQ0VSKSB7XG4gICAgICBjdXJyZW50TGV0dGVyID0gX2NvbmZpZzIuZGVmYXVsdC5FTkRfV09SRDtcbiAgICB9XG4gICAgcmVjdXJzZVByZWZpeChub2RlW2JyYW5jaF0sIHByZWZpeCArIGN1cnJlbnRMZXR0ZXIsIHNvcnRlZCwgcHJlZml4ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVjdXJzZVJhbmRvbVdvcmQ7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIF9jb25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29uZmlnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVjdXJzZVJhbmRvbVdvcmQobm9kZSwgcHJlZml4KSB7XG4gIHZhciB3b3JkID0gcHJlZml4O1xuICB2YXIgYnJhbmNoZXMgPSBPYmplY3Qua2V5cyhub2RlKTtcbiAgdmFyIGJyYW5jaCA9IGJyYW5jaGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJyYW5jaGVzLmxlbmd0aCldO1xuXG4gIGlmIChicmFuY2ggPT09IF9jb25maWcyLmRlZmF1bHQuRU5EX1dPUkQpIHtcbiAgICByZXR1cm4gd29yZDtcbiAgfVxuICByZXR1cm4gcmVjdXJzZVJhbmRvbVdvcmQobm9kZVticmFuY2hdLCBwcmVmaXggKyBicmFuY2gpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgb2JqZWN0Q29weTogZnVuY3Rpb24gb2JqZWN0Q29weShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICAgIHZhciBzcGFjZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDI7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgc3BhY2VyKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsImltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4vbGlicy9tYXRjaFwiO1xuXG5leHBvcnQgeyBtYXRjaCB9O1xuXG5leHBvcnQgY29uc3Qge1xuICAgIGFueUVudmlyb25tZW50LFxuICAgIGFueU1hY3JvLFxuICAgIGFueVN0cmluZyxcbiAgICBhcmd1bWVudCxcbiAgICBibGFua0FyZ3VtZW50LFxuICAgIGNvbW1lbnQsXG4gICAgZW52aXJvbm1lbnQsXG4gICAgZ3JvdXAsXG4gICAgbWFjcm8sXG4gICAgbWF0aCxcbiAgICBwYXJicmVhayxcbiAgICBzdHJpbmcsXG4gICAgd2hpdGVzcGFjZSxcbn0gPSBtYXRjaDtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBtYXRjaCBkaWZmZXJlbnQgYEFzdC5Ob2RlYCB0eXBlcyBpbiBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSBuZWVkIGEgdHlwZS1ndWFyZCB0byBlbnN1cmUgYSBub2RlIGlzIG9mIGEgY2VydGFpbiB0eXBlOyBmb3IgZXhhbXBsZSwgZHVyaW5nIGEgY2FsbCB0byBgdW5pZmllZC1sYXRleC11bnRpbC12aXNpdGAuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgRW52SW5mbywgTWFjcm9JbmZvLCBNYWNyb0luZm9SZWNvcmQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgcHJpbnRSYXcgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhd1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYWNybyBtYXRjaGluZyBmdW5jdGlvbiB0aGF0IHVzZXMgYSBgU3BlY2lhbE1hY3JvU3BlY2Agb3IgbGlzdCBvZiBtYWNyb3NcbiAqIGFuZCBnZW5lcmF0ZXMgYSBoYXNoIGZvciBxdWljayBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY3JvTWF0Y2hlcihcbiAgICBtYWNyb3M6IEFzdC5NYWNyb1tdIHwgc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKSB7XG4gICAgLy8gV2UgZmlyc3QgbWFrZSBzdXJlIHdlIGhhdmUgYSByZWNvcmQgdHlwZSB3aXRoIGtleXMgYmVpbmcgdGhlIG1hY3JvJ3MgY29udGVudHNcbiAgICBjb25zdCBtYWNyb3NIYXNoID0gQXJyYXkuaXNBcnJheShtYWNyb3MpXG4gICAgICAgID8gbWFjcm9zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdHlwZW9mIG1hY3Jvc1swXSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFjcm8gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGJyYW5jaCBvZiBtYXAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNybywge31dIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWNyby5lc2NhcGVUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hY3JvLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBlc2NhcGVUb2tlbjogbWFjcm8uZXNjYXBlVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21hY3JvLmNvbnRlbnQsIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHt9XG4gICAgICAgIDogbWFjcm9zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoQWdhaW5zdE1hY3Jvcyhub2RlOiBhbnkgfCBBc3QuTWFjcm8pIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCB8fCBub2RlLnR5cGUgIT09IFwibWFjcm9cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhIG1hY3JvIHR5cGVcbiAgICAgICAgY29uc3Qgc3BlYyA9IG1hY3Jvc0hhc2hbbm9kZS5jb250ZW50XTtcbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwib2JqZWN0XCIgJiYgXCJlc2NhcGVUb2tlblwiIGluIHNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNwZWMgYXMgTWFjcm9JbmZvUmVjb3JkKS5lc2NhcGVUb2tlbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHNwZWMgYXMgTWFjcm9JbmZvUmVjb3JkKS5lc2NhcGVUb2tlbiA9PT0gbm9kZS5lc2NhcGVUb2tlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGFzIEFzdC5UeXBlR3VhcmQ8QXN0Lk1hY3JvPjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbnZpcm9ubWVudE1hdGNoZXIobWFjcm9zOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgLy8gV2UgZmlyc3QgbWFrZSBzdXJlIHdlIGhhdmUgYSByZWNvcmQgdHlwZSB3aXRoIGtleXMgYmVpbmcgdGhlIG1hY3JvJ3MgY29udGVudHNcbiAgICBjb25zdCBlbnZpcm9ubWVudHNIYXNoID0gQXJyYXkuaXNBcnJheShtYWNyb3MpXG4gICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICBtYWNyb3MubWFwKChzdHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RyLCB7fV0gYXMgW3N0cmluZywgRW52SW5mb107XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RFbnZpcm9ubWVudHMobm9kZTogYW55IHwgQXN0LkVudmlyb25tZW50KSB7XG4gICAgICAgIGlmICghbWF0Y2guYW55RW52aXJvbm1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYW4gZW52aXJvbm1lbnQgdHlwZVxuICAgICAgICBjb25zdCBlbnZOYW1lID0gcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICBjb25zdCBzcGVjID0gZW52aXJvbm1lbnRzSGFzaFtlbnZOYW1lXTtcbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGFzIEFzdC5UeXBlR3VhcmQ8QXN0LkVudmlyb25tZW50Pjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IHR5cGVzIG9mIG5vZGVzLlxuICovXG5leHBvcnQgY29uc3QgbWF0Y2ggPSB7XG4gICAgbWFjcm8obm9kZTogYW55LCBtYWNyb05hbWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIm1hY3JvXCIgJiZcbiAgICAgICAgICAgIChtYWNyb05hbWUgPT0gbnVsbCB8fCBub2RlLmNvbnRlbnQgPT09IG1hY3JvTmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueU1hY3JvKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0Lk1hY3JvIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLm1hY3JvKG5vZGUpO1xuICAgIH0sXG4gICAgZW52aXJvbm1lbnQobm9kZTogYW55LCBlbnZOYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChub2RlLnR5cGUgPT09IFwiZW52aXJvbm1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwibWF0aGVudlwiKSAmJlxuICAgICAgICAgICAgKGVudk5hbWUgPT0gbnVsbCB8fCBwcmludFJhdyhub2RlLmVudikgPT09IGVudk5hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlFbnZpcm9ubWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5FbnZpcm9ubWVudCB7XG4gICAgICAgIHJldHVybiBtYXRjaC5lbnZpcm9ubWVudChub2RlKTtcbiAgICB9LFxuICAgIGNvbW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQ29tbWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNvbW1lbnRcIjtcbiAgICB9LFxuICAgIHBhcmJyZWFrKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LlBhcmJyZWFrIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwicGFyYnJlYWtcIjtcbiAgICB9LFxuICAgIHdoaXRlc3BhY2Uobm9kZTogYW55KTogbm9kZSBpcyBBc3QuV2hpdGVzcGFjZSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgd2hpdGVzcGFjZSBvciBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgICovXG4gICAgd2hpdGVzcGFjZUxpa2UoXG4gICAgICAgIG5vZGU6IGFueVxuICAgICk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2UgfCAoQXN0LkNvbW1lbnQgJiB7IGxlYWRpbmdXaGl0ZXNwYWNlOiB0cnVlIH0pIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiIHx8XG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiAmJiBub2RlLmxlYWRpbmdXaGl0ZXNwYWNlID09PSB0cnVlKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgc3RyaW5nKG5vZGU6IGFueSwgdmFsdWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAodmFsdWUgPT0gbnVsbCB8fCBub2RlLmNvbnRlbnQgPT09IHZhbHVlKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55U3RyaW5nKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LlN0cmluZyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5zdHJpbmcobm9kZSk7XG4gICAgfSxcbiAgICBncm91cChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Hcm91cCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImdyb3VwXCI7XG4gICAgfSxcbiAgICBhcmd1bWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Bcmd1bWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImFyZ3VtZW50XCI7XG4gICAgfSxcbiAgICBibGFua0FyZ3VtZW50KG5vZGU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIW1hdGNoLmFyZ3VtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUub3Blbk1hcmsgPT09IFwiXCIgJiZcbiAgICAgICAgICAgIG5vZGUuY2xvc2VNYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNvbnRlbnQubGVuZ3RoID09PSAwXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBtYXRoKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkRpc3BsYXlNYXRoIHwgQXN0LklubGluZU1hdGgge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJkaXNwbGF5bWF0aFwiIHx8IG5vZGUudHlwZSA9PT0gXCJpbmxpbmVtYXRoXCI7XG4gICAgfSxcbiAgICBjcmVhdGVNYWNyb01hdGNoZXIsXG4gICAgY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyLFxufTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvcHJpbnQtcmF3XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gcHJpbnQgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkgdG8gYSBzdHJpbmcuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBkaXJlY3RseSBwcmludCBhbiBgQXN0LkFzdGAgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nIG9yIGZvcm1hdHRpbmcuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG50eXBlIFByaW50YWJsZSA9IEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50IHwgc3RyaW5nO1xudHlwZSBQcmludFRva2VuID0gc3RyaW5nIHwgdHlwZW9mIGxpbmVicmVhaztcblxuZXhwb3J0IGNvbnN0IGxpbmVicmVhayA9IFN5bWJvbChcImxpbmVicmVha1wiKTtcbmNvbnN0IEVTQ0FQRSA9IFwiXFxcXFwiO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhbiBhcnJheSBpbnNlcnRpbmcgYGxpbmVicmVha2Agd2hlcmUgbmVlZGVkO1xuICogVGhpcyBhcnJheSBtYXkgYmUgbmVzdGVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICovXG5mdW5jdGlvbiBfcHJpbnRSYXcobm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10pOiBQcmludFRva2VuW10ge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICByZXR1cm4gKFtdIGFzIFByaW50VG9rZW5bXSkuY29uY2F0KFxuICAgICAgICAgICAgLi4ubm9kZS5tYXAoKG46IFByaW50YWJsZSkgPT4gX3ByaW50UmF3KG4pKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyB0bXAgdmFyaWFibGVzXG4gICAgbGV0IGFyZ3NTdHJpbmcsIGVzY2FwZTtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9wcmludFJhdyhub2RlLmNvbnRlbnQpO1xuICAgICAgICBjYXNlIFwiYXJndW1lbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5vcGVuTWFyaywgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIG5vZGUuY2xvc2VNYXJrXTtcbiAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBub2RlLnN1ZmZpeFBhcmJyZWFrID8gXCJcIiA6IGxpbmVicmVhaztcbiAgICAgICAgICAgIC8vIEEgY29tbWVudCBpcyByZXNwb25zaWJsZSBmb3IgcHJpbnRpbmcgaXRzIG93biBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSAmJiBub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIFwiJVwiLFxuICAgICAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgXCIlXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBzdWZmaXhdO1xuICAgICAgICBjYXNlIFwiZW52aXJvbm1lbnRcIjpcbiAgICAgICAgY2FzZSBcIm1hdGhlbnZcIjpcbiAgICAgICAgY2FzZSBcInZlcmJhdGltXCI6XG4gICAgICAgICAgICB2YXIgZW52ID0gX3ByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgICAgIHZhciBlbnZTdGFydDogUHJpbnRUb2tlbltdID0gW0VTQ0FQRSArIFwiYmVnaW57XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgdmFyIGVudkVuZDogUHJpbnRUb2tlbltdID0gW0VTQ0FQRSArIFwiZW5ke1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPVxuICAgICAgICAgICAgICAgIChub2RlIGFzIGFueSkuYXJncyA9PSBudWxsID8gW10gOiBfcHJpbnRSYXcoKG5vZGUgYXMgYW55KS5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4uZW52U3RhcnQsXG4gICAgICAgICAgICAgICAgLi4uYXJnc1N0cmluZyxcbiAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAuLi5lbnZFbmQsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwiZGlzcGxheW1hdGhcIjpcbiAgICAgICAgICAgIHJldHVybiBbRVNDQVBFICsgXCJbXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBFU0NBUEUgKyBcIl1cIl07XG4gICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIntcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwifVwiXTtcbiAgICAgICAgY2FzZSBcImlubGluZW1hdGhcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIkXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIiRcIl07XG4gICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgYXJnc1N0cmluZyA9IG5vZGUuYXJncyA9PSBudWxsID8gW10gOiBfcHJpbnRSYXcobm9kZS5hcmdzKTtcbiAgICAgICAgICAgIGVzY2FwZSA9IG5vZGUuZXNjYXBlVG9rZW4gPT0gbnVsbCA/IEVTQ0FQRSA6IG5vZGUuZXNjYXBlVG9rZW47XG4gICAgICAgICAgICByZXR1cm4gW2VzY2FwZSwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIC4uLmFyZ3NTdHJpbmddO1xuICAgICAgICBjYXNlIFwicGFyYnJlYWtcIjpcbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBsaW5lYnJlYWtdO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUuY29udGVudF07XG4gICAgICAgIGNhc2UgXCJ2ZXJiXCI6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEVTQ0FQRSxcbiAgICAgICAgICAgICAgICBub2RlLmVudixcbiAgICAgICAgICAgICAgICBub2RlLmVzY2FwZSxcbiAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICBub2RlLmVzY2FwZSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJ3aGl0ZXNwYWNlXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiIFwiXTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IGZpbmQgcmVuZGVyIGZvciBub2RlIFwiLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgYChvZiB0eXBlICR7dHlwZW9mIG5vZGV9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gW1wiXCIgKyBub2RlXTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZy5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEBwYXJhbSB7Kn0gb3B0aW9ucyAtIFNldHRpbmcgYGFzQXJyYXlgIHRvIGB0cnVlYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0aGUgc3ltYm9sIGBsaW5lYnJlYWtgLCBzbyB0aGF0IHByaW50aW5nIGNhbiBiZSBjdXN0b21pemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9ucz86IHsgYXNBcnJheTogZmFsc2UgfVxuKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM6IHsgYXNBcnJheTogdHJ1ZSB9XG4pOiBQcmludFRva2VuW107XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcobm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sIG9wdGlvbnM/OiBvYmplY3QpOiBhbnkge1xuICAgIGNvbnN0IGFzQXJyYXkgPSBvcHRpb25zICE9IG51bGwgPyAob3B0aW9ucyBhcyBhbnkpLmFzQXJyYXkgOiBmYWxzZTtcbiAgICBjb25zdCBwcmludGVkVG9rZW5zID0gX3ByaW50UmF3KG5vZGUpO1xuICAgIGlmIChhc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBwcmludGVkVG9rZW5zO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbnRlZFRva2Vucy5tYXAoKHgpID0+ICh4ID09PSBsaW5lYnJlYWsgPyBcIlxcblwiIDogeCkpLmpvaW4oXCJcIik7XG59XG4iLCJpbXBvcnQgVHJpZSBmcm9tIFwidHJpZS1wcmVmaXgtdHJlZVwiO1xuaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuZXhwb3J0IHsgVHJpZSB9O1xuXG4vKipcbiAqIEVmZmljaWVudGx5IHNlYXJjaCBmb3IgYSBsYXJnZSBudW1iZXIgb2Ygc3RyaW5ncyB1c2luZyBhIHByZWZpeC10cmVlLlxuICogVGhlIGxvbmdlc3QgbWF0Y2ggaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMuc3RhcnRJbmRleCB0aGUgaW5kZXggdG8gc3RhcnQgc2Nhbm5pbmcgYXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXRjaFN1YnN0cmluZ3Mgd2hldGhlciB0byBhbGxvdyBtYXRjaGluZyBvbmx5IHBhcnQgb2YgYSBzdWJzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucy5hc3N1bWVPbmVDaGFyU3RyaW5ncyBhc3N1bWUgdGhhdCBhbGwgc3RyaW5ncyBhcmUgb25lIGNoYXJhY3RlciBsb25nIChmb3IgZXhhbXBsZSwgbGlrZSB0aGV5IGFyZSBpbiBtYXRoIG1vZGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhNYXRjaChcbiAgICBub2RlczogQXN0Lk5vZGVbXSxcbiAgICBwcmVmaXhlczogc3RyaW5nIHwgc3RyaW5nW10gfCBSZXR1cm5UeXBlPHR5cGVvZiBUcmllPixcbiAgICBvcHRpb25zPzoge1xuICAgICAgICBzdGFydEluZGV4PzogbnVtYmVyO1xuICAgICAgICBtYXRjaFN1YnN0cmluZ3M/OiBib29sZWFuO1xuICAgICAgICBhc3N1bWVPbmVDaGFyU3RyaW5ncz86IGJvb2xlYW47XG4gICAgfVxuKToge1xuICAgIG1hdGNoOiBzdHJpbmc7XG4gICAgZW5kTm9kZUluZGV4OiBudW1iZXI7XG4gICAgZW5kTm9kZVBhcnRpYWxNYXRjaDogc3RyaW5nIHwgbnVsbDtcbn0gfCBudWxsIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICBtYXRjaFN1YnN0cmluZ3MgPSBmYWxzZSxcbiAgICAgICAgYXNzdW1lT25lQ2hhclN0cmluZ3MgPSBmYWxzZSxcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgcHJlZml4ZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJlZml4ZXMgPSBbcHJlZml4ZXNdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcmVmaXhlcykpIHtcbiAgICAgICAgcHJlZml4ZXMgPSBUcmllKHByZWZpeGVzKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4VHJlZSA9IHByZWZpeGVzO1xuXG4gICAgY29uc3QgaGlzdG9yeSA9IHtcbiAgICAgICAgbGFzdFByZWZpeDogXCJcIixcbiAgICAgICAgbGFzdFdvcmQ6IFwiXCIsXG4gICAgICAgIGluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICBwYXJ0aWFsTWF0Y2g6IFwiXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyeSB0byBtYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIuIElmIGl0IG1hdGNoZXMsXG4gICAgICogcmVjb3JkIGl0IHByb3Blcmx5IGluIHRoZSBgaGlzdG9yeWAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyeVRvTWF0Y2hOZXh0Q2hhcihjaGFyOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHJldCA9IGZhbHNlO1xuICAgICAgICBpZiAocHJlZml4VHJlZS5pc1ByZWZpeChoaXN0b3J5Lmxhc3RQcmVmaXggKyBjaGFyKSkge1xuICAgICAgICAgICAgaGlzdG9yeS5sYXN0UHJlZml4ICs9IGNoYXI7XG4gICAgICAgICAgICBoaXN0b3J5LmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXhUcmVlLmhhc1dvcmQoaGlzdG9yeS5sYXN0UHJlZml4KSkge1xuICAgICAgICAgICAgaGlzdG9yeS5sYXN0V29yZCA9IGhpc3RvcnkubGFzdFByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgbm9kZXMgbG9va2luZyBmb3IgdGhlIGxvbmdlc3QgcHJlZml4IG1hdGNoXG4gICAgZm9yIChsZXQgaSA9IDA7IHN0YXJ0SW5kZXggKyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgICAgaWYgKCFtYXRjaC5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3N1bWVPbmVDaGFyU3RyaW5ncyAmJiBub2RlLmNvbnRlbnQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hTdWJzdHJpbmdzKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRlc3QgbGV0dGVyLWJ5LWxldHRlciBmb3Igc3Vic3RyaW5nIG1hdGNoZXNcbiAgICAgICAgICAgIGxldCBmdWxsTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgaGlzdG9yeS5wYXJ0aWFsTWF0Y2ggPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmNvbnRlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gbm9kZS5jb250ZW50W2pdO1xuICAgICAgICAgICAgICAgIGlmICh0cnlUb01hdGNoTmV4dENoYXIoY2hhciwgc3RhcnRJbmRleCArIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvcnkucGFydGlhbE1hdGNoICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdWxsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnBhcnRpYWxNYXRjaCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0cnlUb01hdGNoTmV4dENoYXIobm9kZS5jb250ZW50LCBzdGFydEluZGV4ICsgaSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoaXN0b3J5Lmxhc3RXb3JkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgICBtYXRjaDogaGlzdG9yeS5sYXN0V29yZCxcbiAgICAgICAgICAgICAgZW5kTm9kZUluZGV4OiBoaXN0b3J5LmluZGV4LFxuICAgICAgICAgICAgICBlbmROb2RlUGFydGlhbE1hdGNoOiBoaXN0b3J5LnBhcnRpYWxNYXRjaFxuICAgICAgICAgICAgICAgICAgPyBoaXN0b3J5LnBhcnRpYWxNYXRjaFxuICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBTY2FuIGEgYG5vZGVzYCBsb29raW5nIGZvciB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdG9rZW5gLlxuICogSWYgYG9wdGlvbnMub25seVNraXBXaGl0ZXNwYWNlQW5kQ29tbWVudHM9PXRydWVgLCB0aGVuIHRoZSBzY2FuXG4gKiB3aWxsIG9ubHkgc2tpcCB3aGl0ZXNwYWNlL2NvbW1lbnQgbm9kZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FuKFxuICAgIG5vZGVzOiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10sXG4gICAgdG9rZW46IHN0cmluZyB8IEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCB0byBzdGFydCBzY2FubmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0SW5kZXg/OiBudW1iZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzIHdpbGwgYmUgc2tpbGxlZCBidXQgYW55IG90aGVyXG4gICAgICAgICAqIG5vZGUgdGhhdCBkb2Vzbid0IG1hdGNoIGB0b2tlbmAgd2lsbCBjYXVzZSB0aGUgc2NhbiB0byB0ZXJtaW5hdGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbmx5U2tpcFdoaXRlc3BhY2VBbmRDb21tZW50cz86IGJvb2xlYW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHdpbGwgbG9vayBpbnNpZGUgYEFzdC5TdHJpbmdgIG5vZGVzIHRvIHNlZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnRzXG4gICAgICAgICAqIGNvbnRhaW4gYHRva2VuYC5cbiAgICAgICAgICovXG4gICAgICAgIGFsbG93U3Vic3RyaW5nTWF0Y2hlcz86IGJvb2xlYW47XG4gICAgfVxuKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgeyBzdGFydEluZGV4LCBvbmx5U2tpcFdoaXRlc3BhY2VBbmRDb21tZW50cywgYWxsb3dTdWJzdHJpbmdNYXRjaGVzIH0gPVxuICAgICAgICBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdG9rZW4gPSB7IHR5cGU6IFwic3RyaW5nXCIsIGNvbnRlbnQ6IHRva2VuIH0gYXMgQXN0LlN0cmluZztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCB8fCAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc3BsYXltYXRoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImlubGluZW1hdGhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJwYXJicmVha1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3aGl0ZXNwYWNlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hY3JvXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnQgPT09ICh0b2tlbiBhcyBBc3QuTWFjcm8pLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnZpcm9ubWVudFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXRoZW52XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50UmF3KG5vZGUuZW52KSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50UmF3KCh0b2tlbiBhcyBBc3QuRW52aXJvbm1lbnQpLmVudilcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnQgPT09ICh0b2tlbiBhcyBBc3QuU3RyaW5nKS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1N1YnN0cmluZ01hdGNoZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudC5pbmRleE9mKCh0b2tlbiBhcyBBc3QuU3RyaW5nKS5jb250ZW50KSA+PSAwXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb25seVNraXBXaGl0ZXNwYWNlQW5kQ29tbWVudHMgJiZcbiAgICAgICAgICAgICFtYXRjaC53aGl0ZXNwYWNlKG5vZGUpICYmXG4gICAgICAgICAgICAhbWF0Y2guY29tbWVudChub2RlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9zY2FuXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3ByZWZpeC1tYXRjaFwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGFuYWx5emUgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gbG9vayBmb3IgcGFydGljdWxhciBBU1Qgbm9kZXMgaW4gYW4gYXJyYXk7IHVzZWZ1bCB3aGVuIG1ha2luZyBwbHVnaW5zLlxuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=