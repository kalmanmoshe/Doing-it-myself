/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-types/libs/ast-types.ts":
/*!***********************************************!*\
  !*** ./unified-latex-types/libs/ast-types.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./unified-latex-types/libs/info-specs.ts":
/*!************************************************!*\
  !*** ./unified-latex-types/libs/info-specs.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./unified-latex-types/libs/type-guard.ts":
/*!************************************************!*\
  !*** ./unified-latex-types/libs/type-guard.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**************************************!*\
  !*** ./unified-latex-types/index.ts ***!
  \**************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ast_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/ast-types */ "./unified-latex-types/libs/ast-types.ts");
/* harmony import */ var _libs_type_guard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/type-guard */ "./unified-latex-types/libs/type-guard.ts");
/* harmony import */ var _libs_info_specs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/info-specs */ "./unified-latex-types/libs/info-specs.ts");



// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Types for the `unified-latex` Abstract Syntax Tree (AST). These types extend the `unist` AST,
 * but instead of a `children` attribute, they have a `content` attribute.
 *
 * ## When should I use this?
 *
 * If you're working with `unified-latex` ASTs.
 */

})();


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pZmllZC1sYXRleC10eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NHQUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7Ozs7Ozs7Ozs7OztBQ05pQztBQUNDO0FBQ0E7QUFFbEMsMEVBQTBFO0FBQzFFOzs7Ozs7Ozs7R0FTRyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXR5cGVzL2xpYnMvYXN0LXR5cGVzLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXR5cGVzL2xpYnMvaW5mby1zcGVjcy50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC10eXBlcy9saWJzL3R5cGUtZ3VhcmQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdHlwZXMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgR2VuZXJpY0FzdCA9IEdlbmVyaWNOb2RlIHwgR2VuZXJpY05vZGVbXTtcblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljTm9kZSB7XG4gICAgW3g6IHN0cmluZ106IGFueTtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgX3JlbmRlckluZm8/OiBvYmplY3Q7XG59XG5cbi8vIEFic3RyYWN0IG5vZGVzXG5pbnRlcmZhY2UgQmFzZU5vZGUge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBfcmVuZGVySW5mbz86IGFueTtcbiAgICBwb3NpdGlvbj86IHtcbiAgICAgICAgc3RhcnQ6IHsgb2Zmc2V0OiBudW1iZXI7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfTtcbiAgICAgICAgZW5kOiB7IG9mZnNldDogbnVtYmVyOyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH07XG4gICAgfTtcbn1cblxuaW50ZXJmYWNlIENvbnRlbnROb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGNvbnRlbnQ6IE5vZGVbXTtcbn1cblxuLy8gQWN0dWFsIG5vZGVzXG5leHBvcnQgaW50ZXJmYWNlIFJvb3QgZXh0ZW5kcyBDb250ZW50Tm9kZSB7XG4gICAgdHlwZTogXCJyb290XCI7XG59XG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZyBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICB0eXBlOiBcInN0cmluZ1wiO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXaGl0ZXNwYWNlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIHR5cGU6IFwid2hpdGVzcGFjZVwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmJyZWFrIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIHR5cGU6IFwicGFyYnJlYWtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIHR5cGU6IFwiY29tbWVudFwiO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBzYW1lbGluZT86IGJvb2xlYW47XG4gICAgc3VmZml4UGFyYnJlYWs/OiBib29sZWFuO1xuICAgIGxlYWRpbmdXaGl0ZXNwYWNlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWNybyBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICB0eXBlOiBcIm1hY3JvXCI7XG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIGVzY2FwZVRva2VuPzogc3RyaW5nO1xuICAgIGFyZ3M/OiBBcmd1bWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudmlyb25tZW50IGV4dGVuZHMgQ29udGVudE5vZGUge1xuICAgIHR5cGU6IFwiZW52aXJvbm1lbnRcIiB8IFwibWF0aGVudlwiO1xuICAgIGVudjogc3RyaW5nO1xuICAgIGFyZ3M/OiBBcmd1bWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmJhdGltRW52aXJvbm1lbnQgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgdHlwZTogXCJ2ZXJiYXRpbVwiO1xuICAgIGVudjogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNwbGF5TWF0aCBleHRlbmRzIENvbnRlbnROb2RlIHtcbiAgICB0eXBlOiBcImRpc3BsYXltYXRoXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAgZXh0ZW5kcyBDb250ZW50Tm9kZSB7XG4gICAgdHlwZTogXCJncm91cFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElubGluZU1hdGggZXh0ZW5kcyBDb250ZW50Tm9kZSB7XG4gICAgdHlwZTogXCJpbmxpbmVtYXRoXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyYiBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICB0eXBlOiBcInZlcmJcIjtcbiAgICBlbnY6IHN0cmluZztcbiAgICBlc2NhcGU6IHN0cmluZztcbiAgICBjb250ZW50OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJndW1lbnQgZXh0ZW5kcyBDb250ZW50Tm9kZSB7XG4gICAgdHlwZTogXCJhcmd1bWVudFwiO1xuICAgIG9wZW5NYXJrOiBzdHJpbmc7XG4gICAgY2xvc2VNYXJrOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIE5vZGUgPVxuICAgIHwgUm9vdFxuICAgIHwgU3RyaW5nXG4gICAgfCBXaGl0ZXNwYWNlXG4gICAgfCBQYXJicmVha1xuICAgIHwgQ29tbWVudFxuICAgIHwgTWFjcm9cbiAgICB8IEVudmlyb25tZW50XG4gICAgfCBWZXJiYXRpbUVudmlyb25tZW50XG4gICAgfCBJbmxpbmVNYXRoXG4gICAgfCBEaXNwbGF5TWF0aFxuICAgIHwgR3JvdXBcbiAgICB8IFZlcmI7XG5cbmV4cG9ydCB0eXBlIEFzdCA9IE5vZGUgfCBBcmd1bWVudCB8IE5vZGVbXTtcbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi9hc3QtdHlwZXNcIjtcblxuZXhwb3J0IHR5cGUgRW52SW5mbyA9IHtcbiAgICByZW5kZXJJbmZvPzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbWF0aCBtb2RlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaW5NYXRoTW9kZT86IGJvb2xlYW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGFsaWduIHRoZSBlbnZpcm9ubWVudCBjb250ZW50cyBiYXNlZCBvbiBgJmAgYW5kIGBcXFxcYCBkZWxpbWl0ZXJzXG4gICAgICAgICAqIChsaWtlIGEgbWF0cml4IG9yIHRhYnVsYXIgZW52aXJvbm1lbnQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduQ29udGVudD86IGJvb2xlYW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBhcmd1bWVudHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcGdma2V5cy10eXBlIGFyZ3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBwZ2ZrZXlzQXJncz86IGJvb2xlYW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwcm9jZXNzIHRoZSBib2R5IG9mIGFuIGVudmlyb25tZW50LiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBwcm9jZXNzQ29udGVudGBcbiAgICAgKiBpcyB0cmVhdGVkIGFzIHRoZSBuZXcgYm9keS5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb2Nlc3NDb250ZW50PzogKGFzdDogQXN0Lk5vZGVbXSkgPT4gQXN0Lk5vZGVbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgc2lnbmF0dXJlIGFzIGFuIHhwYXJzZSBhcmd1bWVudCBzcGVjaWZpY2F0aW9uIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2lnbmF0dXJlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgTWFjcm9JbmZvID0ge1xuICAgIHJlbmRlckluZm8/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBtYWNybydzIGNvbnRlbnRzIHdyYXBzIGFsb25nIHdpdGggdGhlIGN1cnJlbnRcbiAgICAgICAgICogcGFyYWdyYXBoIG9yIGRpc3BsYXlzIGFzIGl0J3Mgb3duIGJsb2NrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGluUGFyTW9kZT86IGJvb2xlYW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBhcmd1bWVudHMgc2hvdWxkIGJlIHByb2Nlc3NlZCBhcyBwZ2ZrZXlzLXR5cGUgYXJndW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHBnZmtleXNBcmdzPzogYm9vbGVhbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlcmUgc2hvdWxkIGJlIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1hY3JvXG4gICAgICAgICAqIChlLmcuLCBsaWtlIHRoZSBcXHNlY3Rpb257Li4ufSBjb21tYW5kLilcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBicmVha0Fyb3VuZD86IGJvb2xlYW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb250ZW50cyBvZiB0aGUgbWFjcm8gc2hvdWxkIGJlIGFzc3VtZWQgdG8gYmUgaW4gbWF0aCBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGluTWF0aE1vZGU/OiBib29sZWFuO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXJndW1lbnRzIHNob3VsZCBiZSByZW5kZXJlZCB3aXRoIGEgaGFuZ2luZyBpbmRlbnQgd2hlbiB0aGUgd3JhcFxuICAgICAgICAgKiAobGlrZSB0aGUgYXJndW1lbnRzIHRvIFxcaXRlbSBpbiBhbiBlbnVtZXJhdGUgZW52aXJvbm1lbnQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhbmdpbmdJbmRlbnQ/OiBib29sZWFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIG1hY3JvIHNpZ25hdHVyZSBhcyBhbiB4cGFyc2UgYXJndW1lbnQgc3BlY2lmaWNhdGlvbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNpZ25hdHVyZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTb21lIHNwZWNpYWwgbWFjcm9zIGxpa2UgYF5gIGFuZCBgX2AgZG9uJ3QgdXNlXG4gICAgICogYW4gZXNjYXBlIHRva2VuLiBXaGVuIG1hdGNoaW5nIGFnYWluc3QgdGhlc2UgbWFjcm9zLFxuICAgICAqIGNhcmUgbXVzdCBiZSB0YWtlbiB0byBtYXRjaCB0aGUgbWFjcm8gY29udGVudHMgYW5kIHRoZSBtYWNybydzXG4gICAgICogZXNjYXBlIHRva2VuLlxuICAgICAqL1xuICAgIGVzY2FwZVRva2VuPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgRW52SW5mb1JlY29yZCA9IFJlY29yZDxzdHJpbmcsIEVudkluZm8+O1xuZXhwb3J0IHR5cGUgTWFjcm9JbmZvUmVjb3JkID0gUmVjb3JkPHN0cmluZywgTWFjcm9JbmZvPjtcbiIsIi8qKlxuICogR2VuZXJpYyB0eXBlIG9mIGEgdHlwZS1ndWFyZCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlR3VhcmQ8VD4ge1xuICAgIChub2RlOiBhbnkpOiBub2RlIGlzIFQ7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9hc3QtdHlwZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdHlwZS1ndWFyZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy9pbmZvLXNwZWNzXCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBUeXBlcyBmb3IgdGhlIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS4gVGhlc2UgdHlwZXMgZXh0ZW5kIHRoZSBgdW5pc3RgIEFTVCxcbiAqIGJ1dCBpbnN0ZWFkIG9mIGEgYGNoaWxkcmVuYCBhdHRyaWJ1dGUsIHRoZXkgaGF2ZSBhIGBjb250ZW50YCBhdHRyaWJ1dGUuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UncmUgd29ya2luZyB3aXRoIGB1bmlmaWVkLWxhdGV4YCBBU1RzLlxuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=