/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */

})();

var __webpack_exports__anyEnvironment = __webpack_exports__.anyEnvironment;
var __webpack_exports__anyMacro = __webpack_exports__.anyMacro;
var __webpack_exports__anyString = __webpack_exports__.anyString;
var __webpack_exports__argument = __webpack_exports__.argument;
var __webpack_exports__blankArgument = __webpack_exports__.blankArgument;
var __webpack_exports__comment = __webpack_exports__.comment;
var __webpack_exports__environment = __webpack_exports__.environment;
var __webpack_exports__group = __webpack_exports__.group;
var __webpack_exports__macro = __webpack_exports__.macro;
var __webpack_exports__match = __webpack_exports__.match;
var __webpack_exports__math = __webpack_exports__.math;
var __webpack_exports__parbreak = __webpack_exports__.parbreak;
var __webpack_exports__string = __webpack_exports__.string;
var __webpack_exports__whitespace = __webpack_exports__.whitespace;
export { __webpack_exports__anyEnvironment as anyEnvironment, __webpack_exports__anyMacro as anyMacro, __webpack_exports__anyString as anyString, __webpack_exports__argument as argument, __webpack_exports__blankArgument as blankArgument, __webpack_exports__comment as comment, __webpack_exports__environment as environment, __webpack_exports__group as group, __webpack_exports__macro as macro, __webpack_exports__match as match, __webpack_exports__math as math, __webpack_exports__parbreak as parbreak, __webpack_exports__string as string, __webpack_exports__whitespace as whitespace };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzNFLENBQUM7Ozs7Ozs7U0NwSEQ7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOcUM7QUFFcEI7QUFFVixNQUFNLEVBQ1QsY0FBYyxFQUNkLFFBQVEsRUFDUixTQUFTLEVBQ1QsUUFBUSxFQUNSLGFBQWEsRUFDYixPQUFPLEVBQ1AsV0FBVyxFQUNYLEtBQUssRUFDTCxLQUFLLEVBQ0wsSUFBSSxFQUNKLFFBQVEsRUFDUixNQUFNLEVBQ04sVUFBVSxHQUNiLEdBQUcsOENBQUssQ0FBQztBQUVWLDBFQUEwRTtBQUMxRTs7Ozs7Ozs7R0FRRyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvbGlicy9tYXRjaC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9saWJzL3ByaW50LXJhdy50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IEVudkluZm8sIE1hY3JvSW5mbywgTWFjcm9JbmZvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNyb01hdGNoZXIoXG4gICAgbWFjcm9zOiBBc3QuTWFjcm9bXSB8IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgbWFjcm9zSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IG1hY3Jvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHR5cGVvZiBtYWNyb3NbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8sIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjcm8uZXNjYXBlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXNjYXBlVG9rZW46IG1hY3JvLmVzY2FwZVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNyby5jb250ZW50LCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RNYWNyb3Mobm9kZTogYW55IHwgQXN0Lk1hY3JvKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS50eXBlICE9PSBcIm1hY3JvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSBtYWNybyB0eXBlXG4gICAgICAgIGNvbnN0IHNwZWMgPSBtYWNyb3NIYXNoW25vZGUuY29udGVudF07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcIm9iamVjdFwiICYmIFwiZXNjYXBlVG9rZW5cIiBpbiBzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT09IG5vZGUuZXNjYXBlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5NYWNybz47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyKG1hY3Jvczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgZW52aXJvbm1lbnRzSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgbWFjcm9zLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N0ciwge31dIGFzIFtzdHJpbmcsIEVudkluZm9dO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0RW52aXJvbm1lbnRzKG5vZGU6IGFueSB8IEFzdC5FbnZpcm9ubWVudCkge1xuICAgICAgICBpZiAoIW1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuIGVudmlyb25tZW50IHR5cGVcbiAgICAgICAgY29uc3QgZW52TmFtZSA9IHByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgY29uc3Qgc3BlYyA9IGVudmlyb25tZW50c0hhc2hbZW52TmFtZV07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5FbnZpcm9ubWVudD47XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCB0eXBlcyBvZiBub2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0ge1xuICAgIG1hY3JvKG5vZGU6IGFueSwgbWFjcm9OYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJtYWNyb1wiICYmXG4gICAgICAgICAgICAobWFjcm9OYW1lID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSBtYWNyb05hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlNYWNybyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5tYWNybyhub2RlKTtcbiAgICB9LFxuICAgIGVudmlyb25tZW50KG5vZGU6IGFueSwgZW52TmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcImVudmlyb25tZW50XCIgfHwgbm9kZS50eXBlID09PSBcIm1hdGhlbnZcIikgJiZcbiAgICAgICAgICAgIChlbnZOYW1lID09IG51bGwgfHwgcHJpbnRSYXcobm9kZS5lbnYpID09PSBlbnZOYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55RW52aXJvbm1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICByZXR1cm4gbWF0Y2guZW52aXJvbm1lbnQobm9kZSk7XG4gICAgfSxcbiAgICBjb21tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkNvbW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gICAgfSxcbiAgICBwYXJicmVhayhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5QYXJicmVhayB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInBhcmJyZWFrXCI7XG4gICAgfSxcbiAgICB3aGl0ZXNwYWNlKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2Uge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VMaWtlKFxuICAgICAgICBub2RlOiBhbnlcbiAgICApOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHwgKEFzdC5Db21tZW50ICYgeyBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiB8fFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHN0cmluZyhub2RlOiBhbnksIHZhbHVlPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHZhbHVlID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueVN0cmluZyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICByZXR1cm4gbWF0Y2guc3RyaW5nKG5vZGUpO1xuICAgIH0sXG4gICAgZ3JvdXAobm9kZTogYW55KTogbm9kZSBpcyBBc3QuR3JvdXAge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJncm91cFwiO1xuICAgIH0sXG4gICAgYXJndW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQXJndW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJhcmd1bWVudFwiO1xuICAgIH0sXG4gICAgYmxhbmtBcmd1bWVudChub2RlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hcmd1bWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLm9wZW5NYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNsb3NlTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jb250ZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH0sXG4gICAgbWF0aChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5EaXNwbGF5TWF0aCB8IEFzdC5JbmxpbmVNYXRoIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZGlzcGxheW1hdGhcIiB8fCBub2RlLnR5cGUgPT09IFwiaW5saW5lbWF0aFwiO1xuICAgIH0sXG4gICAgY3JlYXRlTWFjcm9NYXRjaGVyLFxuICAgIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcixcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3ByaW50LXJhd1wiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIHByaW50IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpIHRvIGEgc3RyaW5nLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gZGlyZWN0bHkgcHJpbnQgYW4gYEFzdC5Bc3RgIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZyBvciBmb3JtYXR0aW5nLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxudHlwZSBQcmludGFibGUgPSBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCB8IHN0cmluZztcbnR5cGUgUHJpbnRUb2tlbiA9IHN0cmluZyB8IHR5cGVvZiBsaW5lYnJlYWs7XG5cbmV4cG9ydCBjb25zdCBsaW5lYnJlYWsgPSBTeW1ib2woXCJsaW5lYnJlYWtcIik7XG5jb25zdCBFU0NBUEUgPSBcIlxcXFxcIjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYW4gYXJyYXkgaW5zZXJ0aW5nIGBsaW5lYnJlYWtgIHdoZXJlIG5lZWRlZDtcbiAqIFRoaXMgYXJyYXkgbWF5IGJlIG5lc3RlZC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqL1xuZnVuY3Rpb24gX3ByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdKTogUHJpbnRUb2tlbltdIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIChbXSBhcyBQcmludFRva2VuW10pLmNvbmNhdChcbiAgICAgICAgICAgIC4uLm5vZGUubWFwKChuOiBQcmludGFibGUpID0+IF9wcmludFJhdyhuKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gdG1wIHZhcmlhYmxlc1xuICAgIGxldCBhcmdzU3RyaW5nLCBlc2NhcGU7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICAgIHJldHVybiBfcHJpbnRSYXcobm9kZS5jb250ZW50KTtcbiAgICAgICAgY2FzZSBcImFyZ3VtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUub3Blbk1hcmssIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBub2RlLmNsb3NlTWFya107XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gbm9kZS5zdWZmaXhQYXJicmVhayA/IFwiXCIgOiBsaW5lYnJlYWs7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgaXMgcmVzcG9uc2libGUgZm9yIHByaW50aW5nIGl0cyBvd24gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBcIiVcIixcbiAgICAgICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIFwiJVwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgc3VmZml4XTtcbiAgICAgICAgY2FzZSBcImVudmlyb25tZW50XCI6XG4gICAgICAgIGNhc2UgXCJtYXRoZW52XCI6XG4gICAgICAgIGNhc2UgXCJ2ZXJiYXRpbVwiOlxuICAgICAgICAgICAgdmFyIGVudiA9IF9wcmludFJhdyhub2RlLmVudik7XG4gICAgICAgICAgICB2YXIgZW52U3RhcnQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImJlZ2lue1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIHZhciBlbnZFbmQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImVuZHtcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICBhcmdzU3RyaW5nID1cbiAgICAgICAgICAgICAgICAobm9kZSBhcyBhbnkpLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KChub2RlIGFzIGFueSkuYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmVudlN0YXJ0LFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NTdHJpbmcsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgLi4uZW52RW5kLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcImRpc3BsYXltYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW0VTQ0FQRSArIFwiW1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgRVNDQVBFICsgXCJdXCJdO1xuICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCJ7XCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIn1cIl07XG4gICAgICAgIGNhc2UgXCJpbmxpbmVtYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiJFwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCIkXCJdO1xuICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPSBub2RlLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KG5vZGUuYXJncyk7XG4gICAgICAgICAgICBlc2NhcGUgPSBub2RlLmVzY2FwZVRva2VuID09IG51bGwgPyBFU0NBUEUgOiBub2RlLmVzY2FwZVRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIFtlc2NhcGUsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCAuLi5hcmdzU3RyaW5nXTtcbiAgICAgICAgY2FzZSBcInBhcmJyZWFrXCI6XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgbGluZWJyZWFrXTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBjYXNlIFwidmVyYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBFU0NBUEUsXG4gICAgICAgICAgICAgICAgbm9kZS5lbnYsXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwid2hpdGVzcGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiBcIl07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmaW5kIHJlbmRlciBmb3Igbm9kZSBcIixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGAob2YgdHlwZSAke3R5cGVvZiBub2RlfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFtcIlwiICsgbm9kZV07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgLSBTZXR0aW5nIGBhc0FycmF5YCB0byBgdHJ1ZWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdGhlIHN5bWJvbCBgbGluZWJyZWFrYCwgc28gdGhhdCBwcmludGluZyBjYW4gYmUgY3VzdG9taXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM/OiB7IGFzQXJyYXk6IGZhbHNlIH1cbik6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zOiB7IGFzQXJyYXk6IHRydWUgfVxuKTogUHJpbnRUb2tlbltdO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLCBvcHRpb25zPzogb2JqZWN0KTogYW55IHtcbiAgICBjb25zdCBhc0FycmF5ID0gb3B0aW9ucyAhPSBudWxsID8gKG9wdGlvbnMgYXMgYW55KS5hc0FycmF5IDogZmFsc2U7XG4gICAgY29uc3QgcHJpbnRlZFRva2VucyA9IF9wcmludFJhdyhub2RlKTtcbiAgICBpZiAoYXNBcnJheSkge1xuICAgICAgICByZXR1cm4gcHJpbnRlZFRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIHByaW50ZWRUb2tlbnMubWFwKCh4KSA9PiAoeCA9PT0gbGluZWJyZWFrID8gXCJcXG5cIiA6IHgpKS5qb2luKFwiXCIpO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuL2xpYnMvbWF0Y2hcIjtcblxuZXhwb3J0IHsgbWF0Y2ggfTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgICBhbnlFbnZpcm9ubWVudCxcbiAgICBhbnlNYWNybyxcbiAgICBhbnlTdHJpbmcsXG4gICAgYXJndW1lbnQsXG4gICAgYmxhbmtBcmd1bWVudCxcbiAgICBjb21tZW50LFxuICAgIGVudmlyb25tZW50LFxuICAgIGdyb3VwLFxuICAgIG1hY3JvLFxuICAgIG1hdGgsXG4gICAgcGFyYnJlYWssXG4gICAgc3RyaW5nLFxuICAgIHdoaXRlc3BhY2UsXG59ID0gbWF0Y2g7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IGBBc3QuTm9kZWAgdHlwZXMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UgbmVlZCBhIHR5cGUtZ3VhcmQgdG8gZW5zdXJlIGEgbm9kZSBpcyBvZiBhIGNlcnRhaW4gdHlwZTsgZm9yIGV4YW1wbGUsIGR1cmluZyBhIGNhbGwgdG8gYHVuaWZpZWQtbGF0ZXgtdW50aWwtdmlzaXRgLlxuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=