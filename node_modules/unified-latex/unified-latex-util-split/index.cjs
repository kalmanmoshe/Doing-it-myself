/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-split/libs/array-join.ts":
/*!*****************************************************!*\
  !*** ./unified-latex-util-split/libs/array-join.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* binding */ arrayJoin)
/* harmony export */ });
/**
 * Joins an array of arrays with the item `sep`
 */
function arrayJoin(array, sep) {
    return array.flatMap((item, i) => {
        if (i === 0) {
            return item;
        }
        if (Array.isArray(sep)) {
            return [...sep, ...item];
        }
        else {
            return [sep, ...item];
        }
    });
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-condition.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-condition.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnCondition": () => (/* binding */ splitOnCondition)
/* harmony export */ });
/**
 * Split a list of nodes based on whether `splitFunc` returns `true`.
 * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then
 * there will be at most two segments returned.
 */
function splitOnCondition(nodes, splitFunc = () => false, options) {
    if (!Array.isArray(nodes)) {
        throw new Error(`Can only split an Array, not ${nodes}`);
    }
    const { onlySplitOnFirstOccurrence = false } = options || {};
    const splitIndices = [];
    for (let i = 0; i < nodes.length; i++) {
        if (splitFunc(nodes[i])) {
            splitIndices.push(i);
            if (onlySplitOnFirstOccurrence) {
                break;
            }
        }
    }
    // Short circuit if there is no splitting to be done
    if (splitIndices.length === 0) {
        return { segments: [nodes], separators: [] };
    }
    let separators = splitIndices.map((i) => nodes[i]);
    let segments = splitIndices.map((splitEnd, i) => {
        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
        return nodes.slice(splitStart, splitEnd);
    });
    segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
    return { segments, separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-macro.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-macro.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnMacro": () => (/* binding */ splitOnMacro)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");


/**
 * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`
 * is returned. The original array is reconstructed as
 * `segments[0] + macros[0] + segments[1] + ...`.
 *
 * @param {[object]} ast
 * @param {(string|[string])} macroName
 * @returns {{segments: [object], macros: [object]}}
 */
function splitOnMacro(ast, macroName) {
    if (typeof macroName === "string") {
        macroName = [macroName];
    }
    if (!Array.isArray(macroName)) {
        throw new Error("Type coercion failed");
    }
    const isSeparator = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.createMacroMatcher(macroName);
    const { segments, separators } = (0,_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(ast, isSeparator);
    return { segments, macros: separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/unsplit-on-macro.ts":
/*!***********************************************************!*\
  !*** ./unified-latex-util-split/libs/unsplit-on-macro.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsplitOnMacro": () => (/* binding */ unsplitOnMacro)
/* harmony export */ });
/**
 * Does the reverse of `splitOnMacro`
 */
function unsplitOnMacro({ segments, macros, }) {
    if (segments.length === 0) {
        console.warn("Trying to join zero segments");
        return [];
    }
    if (segments.length !== macros.length + 1) {
        console.warn("Mismatch between lengths of macros and segments when trying to unsplit");
    }
    let ret = segments[0];
    for (let i = 0; i < macros.length; i++) {
        // Even though the type of macros[i] is node and not array,
        // Array.concat still works
        ret = ret.concat(macros[i]).concat(segments[i + 1]);
    }
    return ret;
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************************!*\
  !*** ./unified-latex-util-split/index.ts ***!
  \*******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* reexport safe */ _libs_array_join__WEBPACK_IMPORTED_MODULE_3__.arrayJoin),
/* harmony export */   "splitOnCondition": () => (/* reexport safe */ _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition),
/* harmony export */   "splitOnMacro": () => (/* reexport safe */ _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__.splitOnMacro),
/* harmony export */   "unsplitOnMacro": () => (/* reexport safe */ _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__.unsplitOnMacro)
/* harmony export */ });
/* harmony import */ var _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/split-on-macro */ "./unified-latex-util-split/libs/split-on-macro.ts");
/* harmony import */ var _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");
/* harmony import */ var _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unsplit-on-macro */ "./unified-latex-util-split/libs/unsplit-on-macro.ts");
/* harmony import */ var _libs_array_join__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/array-join */ "./unified-latex-util-split/libs/array-join.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to manipulate `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want break apart or join an array of nodes based on a condition. For example,
 * this is used to split on `&` characters in the `align` environment.
 */ 

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQywyREFBMkQ7UUFDM0QsMkJBQTJCO1FBQzNCLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdkQ7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7Ozs7Ozs7U0M5QkQ7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05zQztBQUNJO0FBQ0Y7QUFDTjtBQUVsQywwRUFBMEU7QUFDMUU7Ozs7Ozs7OztHQVNHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2xpYnMvbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvbGlicy9wcmludC1yYXcudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL2FycmF5LWpvaW4udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3NwbGl0LW9uLWNvbmRpdGlvbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNwbGl0L2xpYnMvc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3Vuc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi9saWJzL21hdGNoXCI7XG5cbmV4cG9ydCB7IG1hdGNoIH07XG5cbmV4cG9ydCBjb25zdCB7XG4gICAgYW55RW52aXJvbm1lbnQsXG4gICAgYW55TWFjcm8sXG4gICAgYW55U3RyaW5nLFxuICAgIGFyZ3VtZW50LFxuICAgIGJsYW5rQXJndW1lbnQsXG4gICAgY29tbWVudCxcbiAgICBlbnZpcm9ubWVudCxcbiAgICBncm91cCxcbiAgICBtYWNybyxcbiAgICBtYXRoLFxuICAgIHBhcmJyZWFrLFxuICAgIHN0cmluZyxcbiAgICB3aGl0ZXNwYWNlLFxufSA9IG1hdGNoO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCBgQXN0Lk5vZGVgIHR5cGVzIGluIGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IG5lZWQgYSB0eXBlLWd1YXJkIHRvIGVuc3VyZSBhIG5vZGUgaXMgb2YgYSBjZXJ0YWluIHR5cGU7IGZvciBleGFtcGxlLCBkdXJpbmcgYSBjYWxsIHRvIGB1bmlmaWVkLWxhdGV4LXVudGlsLXZpc2l0YC5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBFbnZJbmZvLCBNYWNyb0luZm8sIE1hY3JvSW5mb1JlY29yZCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBwcmludFJhdyB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjcm9NYXRjaGVyKFxuICAgIG1hY3JvczogQXN0Lk1hY3JvW10gfCBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IG1hY3Jvc0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBtYWNyb3MubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB0eXBlb2YgbWFjcm9zWzBdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21hY3JvLCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGJyYW5jaCBvZiBtYXAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hY3JvLmVzY2FwZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm8uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGVzY2FwZVRva2VuOiBtYWNyby5lc2NhcGVUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8uY29udGVudCwge31dIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDoge31cbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0TWFjcm9zKG5vZGU6IGFueSB8IEFzdC5NYWNybykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUudHlwZSAhPT0gXCJtYWNyb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGEgbWFjcm8gdHlwZVxuICAgICAgICBjb25zdCBzcGVjID0gbWFjcm9zSGFzaFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYyA9PT0gXCJvYmplY3RcIiAmJiBcImVzY2FwZVRva2VuXCIgaW4gc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09PSBub2RlLmVzY2FwZVRva2VuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuTWFjcm8+O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYWNybyBtYXRjaGluZyBmdW5jdGlvbiB0aGF0IHVzZXMgYSBgU3BlY2lhbE1hY3JvU3BlY2Agb3IgbGlzdCBvZiBtYWNyb3NcbiAqIGFuZCBnZW5lcmF0ZXMgYSBoYXNoIGZvciBxdWljayBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcihtYWNyb3M6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IGVudmlyb25tZW50c0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKHN0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdHIsIHt9XSBhcyBbc3RyaW5nLCBFbnZJbmZvXTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIDogbWFjcm9zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoQWdhaW5zdEVudmlyb25tZW50cyhub2RlOiBhbnkgfCBBc3QuRW52aXJvbm1lbnQpIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hbnlFbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbiBlbnZpcm9ubWVudCB0eXBlXG4gICAgICAgIGNvbnN0IGVudk5hbWUgPSBwcmludFJhdyhub2RlLmVudik7XG4gICAgICAgIGNvbnN0IHNwZWMgPSBlbnZpcm9ubWVudHNIYXNoW2Vudk5hbWVdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuRW52aXJvbm1lbnQ+O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyB0byBtYXRjaCBkaWZmZXJlbnQgdHlwZXMgb2Ygbm9kZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaCA9IHtcbiAgICBtYWNybyhub2RlOiBhbnksIG1hY3JvTmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0Lk1hY3JvIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwibWFjcm9cIiAmJlxuICAgICAgICAgICAgKG1hY3JvTmFtZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gbWFjcm9OYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55TWFjcm8obm9kZTogYW55KTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICByZXR1cm4gbWF0Y2gubWFjcm8obm9kZSk7XG4gICAgfSxcbiAgICBlbnZpcm9ubWVudChub2RlOiBhbnksIGVudk5hbWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5FbnZpcm9ubWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJlbnZpcm9ubWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJtYXRoZW52XCIpICYmXG4gICAgICAgICAgICAoZW52TmFtZSA9PSBudWxsIHx8IHByaW50UmF3KG5vZGUuZW52KSA9PT0gZW52TmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueUVudmlyb25tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmVudmlyb25tZW50KG5vZGUpO1xuICAgIH0sXG4gICAgY29tbWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Db21tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiO1xuICAgIH0sXG4gICAgcGFyYnJlYWsobm9kZTogYW55KTogbm9kZSBpcyBBc3QuUGFyYnJlYWsge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJwYXJicmVha1wiO1xuICAgIH0sXG4gICAgd2hpdGVzcGFjZShub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB3aGl0ZXNwYWNlIG9yIGEgY29tbWVudCB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlTGlrZShcbiAgICAgICAgbm9kZTogYW55XG4gICAgKTogbm9kZSBpcyBBc3QuV2hpdGVzcGFjZSB8IChBc3QuQ29tbWVudCAmIHsgbGVhZGluZ1doaXRlc3BhY2U6IHRydWUgfSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgfHxcbiAgICAgICAgICAgIChub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UgPT09IHRydWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBzdHJpbmcobm9kZTogYW55LCB2YWx1ZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LlN0cmluZyB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcInN0cmluZ1wiICYmICh2YWx1ZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gdmFsdWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlTdHJpbmcobm9kZTogYW55KTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnN0cmluZyhub2RlKTtcbiAgICB9LFxuICAgIGdyb3VwKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0Lkdyb3VwIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZ3JvdXBcIjtcbiAgICB9LFxuICAgIGFyZ3VtZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkFyZ3VtZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiYXJndW1lbnRcIjtcbiAgICB9LFxuICAgIGJsYW5rQXJndW1lbnQobm9kZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghbWF0Y2guYXJndW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS5vcGVuTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jbG9zZU1hcmsgPT09IFwiXCIgJiZcbiAgICAgICAgICAgIG5vZGUuY29udGVudC5sZW5ndGggPT09IDBcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIG1hdGgobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRGlzcGxheU1hdGggfCBBc3QuSW5saW5lTWF0aCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImRpc3BsYXltYXRoXCIgfHwgbm9kZS50eXBlID09PSBcImlubGluZW1hdGhcIjtcbiAgICB9LFxuICAgIGNyZWF0ZU1hY3JvTWF0Y2hlcixcbiAgICBjcmVhdGVFbnZpcm9ubWVudE1hdGNoZXIsXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9wcmludC1yYXdcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBwcmludCBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKSB0byBhIHN0cmluZy5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIGRpcmVjdGx5IHByaW50IGFuIGBBc3QuQXN0YCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcgb3IgZm9ybWF0dGluZy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbnR5cGUgUHJpbnRhYmxlID0gQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCBzdHJpbmc7XG50eXBlIFByaW50VG9rZW4gPSBzdHJpbmcgfCB0eXBlb2YgbGluZWJyZWFrO1xuXG5leHBvcnQgY29uc3QgbGluZWJyZWFrID0gU3ltYm9sKFwibGluZWJyZWFrXCIpO1xuY29uc3QgRVNDQVBFID0gXCJcXFxcXCI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGFuIGFycmF5IGluc2VydGluZyBgbGluZWJyZWFrYCB3aGVyZSBuZWVkZWQ7XG4gKiBUaGlzIGFycmF5IG1heSBiZSBuZXN0ZWQuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKi9cbmZ1bmN0aW9uIF9wcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSk6IFByaW50VG9rZW5bXSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAoW10gYXMgUHJpbnRUb2tlbltdKS5jb25jYXQoXG4gICAgICAgICAgICAuLi5ub2RlLm1hcCgobjogUHJpbnRhYmxlKSA9PiBfcHJpbnRSYXcobikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIHRtcCB2YXJpYWJsZXNcbiAgICBsZXQgYXJnc1N0cmluZywgZXNjYXBlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICByZXR1cm4gX3ByaW50UmF3KG5vZGUuY29udGVudCk7XG4gICAgICAgIGNhc2UgXCJhcmd1bWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLm9wZW5NYXJrLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgbm9kZS5jbG9zZU1hcmtdO1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG5vZGUuc3VmZml4UGFyYnJlYWsgPyBcIlwiIDogbGluZWJyZWFrO1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyBpdHMgb3duIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICBzdWZmaXgsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBcIiVcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIHN1ZmZpeF07XG4gICAgICAgIGNhc2UgXCJlbnZpcm9ubWVudFwiOlxuICAgICAgICBjYXNlIFwibWF0aGVudlwiOlxuICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgIHZhciBlbnYgPSBfcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICAgICAgdmFyIGVudlN0YXJ0OiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJiZWdpbntcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICB2YXIgZW52RW5kOiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJlbmR7XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgYXJnc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgKG5vZGUgYXMgYW55KS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdygobm9kZSBhcyBhbnkpLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5lbnZTdGFydCxcbiAgICAgICAgICAgICAgICAuLi5hcmdzU3RyaW5nLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIC4uLmVudkVuZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJkaXNwbGF5bWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtFU0NBUEUgKyBcIltcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIEVTQ0FQRSArIFwiXVwiXTtcbiAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wie1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCJ9XCJdO1xuICAgICAgICBjYXNlIFwiaW5saW5lbWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiRcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwiJFwiXTtcbiAgICAgICAgY2FzZSBcIm1hY3JvXCI6XG4gICAgICAgICAgICBhcmdzU3RyaW5nID0gbm9kZS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdyhub2RlLmFyZ3MpO1xuICAgICAgICAgICAgZXNjYXBlID0gbm9kZS5lc2NhcGVUb2tlbiA9PSBudWxsID8gRVNDQVBFIDogbm9kZS5lc2NhcGVUb2tlbjtcbiAgICAgICAgICAgIHJldHVybiBbZXNjYXBlLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgLi4uYXJnc1N0cmluZ107XG4gICAgICAgIGNhc2UgXCJwYXJicmVha1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIGxpbmVicmVha107XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5jb250ZW50XTtcbiAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRVNDQVBFLFxuICAgICAgICAgICAgICAgIG5vZGUuZW52LFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIgXCJdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmluZCByZW5kZXIgZm9yIG5vZGUgXCIsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBgKG9mIHR5cGUgJHt0eXBlb2Ygbm9kZX0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBbXCJcIiArIG5vZGVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHsqfSBvcHRpb25zIC0gU2V0dGluZyBgYXNBcnJheWAgdG8gYHRydWVgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRoZSBzeW1ib2wgYGxpbmVicmVha2AsIHNvIHRoYXQgcHJpbnRpbmcgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zPzogeyBhc0FycmF5OiBmYWxzZSB9XG4pOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9uczogeyBhc0FycmF5OiB0cnVlIH1cbik6IFByaW50VG9rZW5bXTtcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSwgb3B0aW9ucz86IG9iamVjdCk6IGFueSB7XG4gICAgY29uc3QgYXNBcnJheSA9IG9wdGlvbnMgIT0gbnVsbCA/IChvcHRpb25zIGFzIGFueSkuYXNBcnJheSA6IGZhbHNlO1xuICAgIGNvbnN0IHByaW50ZWRUb2tlbnMgPSBfcHJpbnRSYXcobm9kZSk7XG4gICAgaWYgKGFzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHByaW50ZWRUb2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBwcmludGVkVG9rZW5zLm1hcCgoeCkgPT4gKHggPT09IGxpbmVicmVhayA/IFwiXFxuXCIgOiB4KSkuam9pbihcIlwiKTtcbn1cbiIsIi8qKlxuICogSm9pbnMgYW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdGhlIGl0ZW0gYHNlcGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5Sm9pbjxUPihhcnJheTogVFtdW10sIHNlcDogVCB8IFRbXSk6IFRbXSB7XG4gICAgcmV0dXJuIGFycmF5LmZsYXRNYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uc2VwLCAuLi5pdGVtXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbc2VwLCAuLi5pdGVtXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbi8qKlxuICogU3BsaXQgYSBsaXN0IG9mIG5vZGVzIGJhc2VkIG9uIHdoZXRoZXIgYHNwbGl0RnVuY2AgcmV0dXJucyBgdHJ1ZWAuXG4gKiBJZiBgb25seVNwbGl0T25GaXJzdE9jY3VycmVuY2VgIGlzIHNldCB0byB0cnVlIGluIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCB0aGVuXG4gKiB0aGVyZSB3aWxsIGJlIGF0IG1vc3QgdHdvIHNlZ21lbnRzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbkNvbmRpdGlvbihcbiAgICBub2RlczogQXN0Lk5vZGVbXSxcbiAgICBzcGxpdEZ1bmM6IChub2RlOiBBc3QuTm9kZSkgPT4gYm9vbGVhbiA9ICgpID0+IGZhbHNlLFxuICAgIG9wdGlvbnM/OiB7IG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlPzogYm9vbGVhbiB9XG4pOiB7IHNlZ21lbnRzOiBBc3QuTm9kZVtdW107IHNlcGFyYXRvcnM6IEFzdC5Ob2RlW10gfSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBvbmx5IHNwbGl0IGFuIEFycmF5LCBub3QgJHtub2Rlc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlID0gZmFsc2UgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBzcGxpdEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BsaXRGdW5jKG5vZGVzW2ldKSkge1xuICAgICAgICAgICAgc3BsaXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAob25seVNwbGl0T25GaXJzdE9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhlcmUgaXMgbm8gc3BsaXR0aW5nIHRvIGJlIGRvbmVcbiAgICBpZiAoc3BsaXRJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBzZWdtZW50czogW25vZGVzXSwgc2VwYXJhdG9yczogW10gfTtcbiAgICB9XG5cbiAgICBsZXQgc2VwYXJhdG9ycyA9IHNwbGl0SW5kaWNlcy5tYXAoKGkpID0+IG5vZGVzW2ldKTtcbiAgICBsZXQgc2VnbWVudHMgPSBzcGxpdEluZGljZXMubWFwKChzcGxpdEVuZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdFN0YXJ0ID0gaSA9PT0gMCA/IDAgOiBzcGxpdEluZGljZXNbaSAtIDFdICsgMTtcbiAgICAgICAgcmV0dXJuIG5vZGVzLnNsaWNlKHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICB9KTtcbiAgICBzZWdtZW50cy5wdXNoKFxuICAgICAgICBub2Rlcy5zbGljZShzcGxpdEluZGljZXNbc3BsaXRJbmRpY2VzLmxlbmd0aCAtIDFdICsgMSwgbm9kZXMubGVuZ3RoKVxuICAgICk7XG5cbiAgICByZXR1cm4geyBzZWdtZW50cywgc2VwYXJhdG9ycyB9O1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcbmltcG9ydCB7IHNwbGl0T25Db25kaXRpb24gfSBmcm9tIFwiLi9zcGxpdC1vbi1jb25kaXRpb25cIjtcblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheSBvZiBBU1Qgbm9kZXMgYmFzZWQgb24gYSBtYWNyby4gQW4gb2JqZWN0IGB7c2VnbWVudHM6IFtdLCBtYWNyb3M6IFtdfWBcbiAqIGlzIHJldHVybmVkLiBUaGUgb3JpZ2luYWwgYXJyYXkgaXMgcmVjb25zdHJ1Y3RlZCBhc1xuICogYHNlZ21lbnRzWzBdICsgbWFjcm9zWzBdICsgc2VnbWVudHNbMV0gKyAuLi5gLlxuICpcbiAqIEBwYXJhbSB7W29iamVjdF19IGFzdFxuICogQHBhcmFtIHsoc3RyaW5nfFtzdHJpbmddKX0gbWFjcm9OYW1lXG4gKiBAcmV0dXJucyB7e3NlZ21lbnRzOiBbb2JqZWN0XSwgbWFjcm9zOiBbb2JqZWN0XX19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdE9uTWFjcm8oXG4gICAgYXN0OiBBc3QuTm9kZVtdLFxuICAgIG1hY3JvTmFtZTogc3RyaW5nIHwgc3RyaW5nW11cbik6IHsgc2VnbWVudHM6IEFzdC5Ob2RlW11bXTsgbWFjcm9zOiBBc3QuTWFjcm9bXSB9IHtcbiAgICBpZiAodHlwZW9mIG1hY3JvTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtYWNyb05hbWUgPSBbbWFjcm9OYW1lXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hY3JvTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBjb2VyY2lvbiBmYWlsZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGlzU2VwYXJhdG9yID0gbWF0Y2guY3JlYXRlTWFjcm9NYXRjaGVyKG1hY3JvTmFtZSk7XG4gICAgY29uc3QgeyBzZWdtZW50cywgc2VwYXJhdG9ycyB9ID0gc3BsaXRPbkNvbmRpdGlvbihhc3QsIGlzU2VwYXJhdG9yKTtcbiAgICByZXR1cm4geyBzZWdtZW50cywgbWFjcm9zOiBzZXBhcmF0b3JzIGFzIEFzdC5NYWNyb1tdIH07XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxuLyoqXG4gKiBEb2VzIHRoZSByZXZlcnNlIG9mIGBzcGxpdE9uTWFjcm9gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnNwbGl0T25NYWNybyh7XG4gICAgc2VnbWVudHMsXG4gICAgbWFjcm9zLFxufToge1xuICAgIHNlZ21lbnRzOiBBc3QuTm9kZVtdW107XG4gICAgbWFjcm9zOiBBc3QuTm9kZVtdIHwgQXN0Lk5vZGVbXVtdO1xufSkge1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIGpvaW4gemVybyBzZWdtZW50c1wiKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoICE9PSBtYWNyb3MubGVuZ3RoICsgMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIk1pc21hdGNoIGJldHdlZW4gbGVuZ3RocyBvZiBtYWNyb3MgYW5kIHNlZ21lbnRzIHdoZW4gdHJ5aW5nIHRvIHVuc3BsaXRcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxldCByZXQgPSBzZWdtZW50c1swXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hY3Jvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgdHlwZSBvZiBtYWNyb3NbaV0gaXMgbm9kZSBhbmQgbm90IGFycmF5LFxuICAgICAgICAvLyBBcnJheS5jb25jYXQgc3RpbGwgd29ya3NcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChtYWNyb3NbaV0pLmNvbmNhdChzZWdtZW50c1tpICsgMV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tY29uZGl0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3Vuc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvYXJyYXktam9pblwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgYnJlYWsgYXBhcnQgb3Igam9pbiBhbiBhcnJheSBvZiBub2RlcyBiYXNlZCBvbiBhIGNvbmRpdGlvbi4gRm9yIGV4YW1wbGUsXG4gKiB0aGlzIGlzIHVzZWQgdG8gc3BsaXQgb24gYCZgIGNoYXJhY3RlcnMgaW4gdGhlIGBhbGlnbmAgZW52aXJvbm1lbnQuXG4gKi8iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=