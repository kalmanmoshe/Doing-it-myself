/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-lint/utils/replace-node.ts":
/*!**************************************************!*\
  !*** ./unified-latex-lint/utils/replace-node.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNodeDuringVisit": () => (/* binding */ replaceNodeDuringVisit)
/* harmony export */ });
/**
 * Replaces the current node with `replacement`. It is assumed that the current
 * node is in an array that is a child of a parent element. If this is not the case,
 * the function will error.
 */
function replaceNodeDuringVisit(replacement, info) {
    const parent = info.parents[0];
    if (!parent) {
        throw new Error(`Cannot replace node: parent not found`);
    }
    const container = parent[info.key];
    if (!Array.isArray(container)) {
        throw new Error(`Cannot replace node: containing array not found`);
    }
    if (info.index == null) {
        throw new Error(`Cannot replace node: node index undefined`);
    }
    if (!Array.isArray(replacement)) {
        container[info.index] = replacement;
    }
    else {
        container.splice(info.index, 1, ...replacement);
    }
}


/***/ }),

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-node.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-node.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* binding */ replaceNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");

/**
 * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If
 * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.
 * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.
 */
function replaceNode(ast, visitor) {
    (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, (node, info) => {
        let replacement = visitor(node, info.context);
        // Returning `undefined` or the same node means we shouldn't replace that node
        if (typeof replacement === "undefined" || replacement === node) {
            return;
        }
        if (!info.containingArray || info.index == null) {
            throw new Error("Trying to delete node, but cannot find containing array");
        }
        if (replacement === null ||
            (Array.isArray(replacement) && replacement.length === 0)) {
            // A null return means that we delete the current node
            info.containingArray.splice(info.index, 1);
            return info.index;
        }
        if (!Array.isArray(replacement)) {
            replacement = [replacement];
        }
        info.containingArray.splice(info.index, 1, ...replacement);
        // We don't want to *reprocess* the nodes we just inserted into the array,
        // lest we get stuck in a recursive loop if the replacement contains the original.
        // Thus we jump to the index after our replacements.
        return info.index + replacement.length;
    });
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-streaming-command.ts":
/*!**********************************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-streaming-command.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommand": () => (/* binding */ replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* binding */ replaceStreamingCommandInGroup)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-split */ "./unified-latex-util-split/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/first-significant-node */ "./unified-latex-util-replace/libs/utils/first-significant-node.ts");
/* harmony import */ var _utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/replace-streaming-command-in-array */ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts");
/* harmony import */ var _utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");






/**
 * Process streaming commands in a group. If needed, "escape" the group.
 * For example, `{\bfseries xx}` -> `\textbf{xx}`, but `{foo \bfseries xx}` -> `{foo \textbf{xx}}`.
 */
function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer) {
    const content = group.content;
    // If the group started with a streaming command, we want to pop
    // out of the group. E.g. `{\bfseries foo}` -> `\textbf{foo}` and not `{\textbf{foo}}`
    let popFromGroup = isStreamingCommand((0,_utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__.firstSignificantNode)(content));
    let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer);
    // If the group consisted of just streaming commands (for some reason...)
    // it should be eliminated
    if (innerProcessed.length === 0) {
        return [];
    }
    if (popFromGroup) {
        return innerProcessed;
    }
    else {
        return [{ type: "group", content: innerProcessed }];
    }
}
/**
 * Given a group or a node array, look for streaming commands (e.g., `\bfseries`) and replace them
 * with the specified macro. The "arguments" of the streaming command are passed to `replacer` and the return
 * value of `replacer` is inserted into the stream.
 *
 * By default, this command will split at parbreaks (since commands like `\textbf{...} do not accept parbreaks in their
 * contents) and call `replacer` multiple times, once per paragraph.
 */
function replaceStreamingCommand(ast, isStreamingCommand, replacer) {
    if (typeof isStreamingCommand !== "function") {
        throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);
    }
    let processedContent = [];
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.group(ast)) {
        processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);
    }
    if (Array.isArray(ast)) {
        // Streaming commands that come at the end of a sequence of nodes don't do anything.
        // They also will consume whitespace, so we should remove them and the whitespace.
        const nodes = ast;
        let scanIndex = nodes.length;
        let sliceIndex = scanIndex;
        while (scanIndex > 0 &&
            (isStreamingCommand(nodes[scanIndex - 1]) ||
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(nodes[scanIndex - 1]))) {
            scanIndex--;
            if (isStreamingCommand(nodes[scanIndex])) {
                sliceIndex = scanIndex;
            }
        }
        if (sliceIndex !== nodes.length) {
            nodes.splice(sliceIndex);
        }
        const isPar = (node) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node, "par");
        // We split on both a parbreak and a literal `\par`. But we will
        // normalize everything to be parbreaks
        const splitByPar = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(nodes, isPar);
        splitByPar.separators = splitByPar.separators.map((sep) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(sep) ? sep : { type: "parbreak" });
        const replacers = [];
        let segments = splitByPar.segments.map((segment) => {
            function applyAccumulatedReplacers(nodes) {
                if (replacers.length === 0) {
                    return nodes;
                }
                return (0,_utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__.wrapSignificantContent)(nodes, composeReplacers(replacers));
            }
            const { foundStreamingCommands } = (0,_utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommandInArray)(segment, isStreamingCommand, replacer);
            // All streaming commands in `segment` have now been replaced. However,
            // there might be commands from the previous paragraphs that should wrap
            // the current segment!
            const ret = applyAccumulatedReplacers(segment);
            // Any streaming commands from this segment will carry over to the next,
            // so keep track of them.
            foundStreamingCommands.forEach((macro) => {
                replacers.push((nodes) => {
                    const ret = replacer(nodes, macro);
                    if (!Array.isArray(ret)) {
                        return [ret];
                    }
                    return ret;
                });
            });
            return ret;
        });
        // Leading/trailing whitespace was hoisted in front/back of each replacer.
        // Since we're separated by parbreaks, we can safely trim all that whitespace.
        if (segments.length > 1) {
            segments.forEach((segment, i) => {
                if (i === 0) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(segment);
                }
                else if (i === segments.length - 1) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(segment);
                }
                else {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(segment);
                }
            });
        }
        processedContent = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.unsplitOnMacro)({
            segments: segments,
            macros: splitByPar.separators,
        });
    }
    return processedContent;
}
/**
 * Given a sequence of replacer functions `[f, g, h]` return
 * `h \circ g \circ f`
 *
 * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers
 * @returns {(nodes: Ast.Node[]) => Ast.Node}
 */
function composeReplacers(replacers) {
    if (replacers.length === 0) {
        throw new Error("Cannot compose zero replacement functions");
    }
    return (nodes) => {
        let ret = nodes;
        for (let i = 0; i < replacers.length; i++) {
            const func = replacers[i];
            ret = func(ret);
        }
        return ret;
    };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts":
/*!****************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/unified-latex-streaming-command.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* binding */ unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-lint/utils/replace-node */ "./unified-latex-lint/utils/replace-node.ts");
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");





/**
 * Unified plugin to replace all found streaming commands with their argument-style equivalents.
 * This only applies to sections of the tree with no math ancestor.
 *
 * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.
 */
const unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands(options) {
    const { replacers = {} } = options || {};
    const isReplaceable = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.createMacroMatcher(replacers);
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (group, info) => {
            if (info.context.hasMathModeAncestor ||
                !group.content.some(isReplaceable)) {
                return;
            }
            let fixed = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(group, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // We cannot replace the node unless we can access the containing array.
            if (!info.containingArray || info.index == null) {
                return;
            }
            // `fixed` may consist of only whitespace. If this is the case,
            // surrounding whitespace must trimmed before
            // inserting the group's contents.
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(prevToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[0])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(fixed);
            }
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(nextToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[fixed.length - 1])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(fixed);
            }
            (0,_unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNodeDuringVisit)(fixed, info);
        }, { test: _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.group });
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (nodes, info) => {
            if (info.context.hasMathModeAncestor ||
                !nodes.some(isReplaceable)) {
                return;
            }
            const replaced = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(nodes, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // If we get back a different array than we input, the replacement did
            // not happen in-place. In this case we need to manipulate `nodes`.
            if (replaced !== nodes) {
                nodes.length = 0;
                nodes.push(...replaced);
            }
        }, { includeArrays: true, test: Array.isArray });
    };
};


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/first-significant-node.ts":
/*!*************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/first-significant-node.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "firstSignificantNode": () => (/* binding */ firstSignificantNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such
 * node, `null` is returned.
 */
function firstSignificantNode(nodes) {
    let firstNode = null;
    for (const node of nodes) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            continue;
        }
        firstNode = node;
        break;
    }
    return firstNode;
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "joinWithoutExcessWhitespace": () => (/* binding */ joinWithoutExcessWhitespace)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");


/**
 * Is the node space-like? I.e., is it whitespace or
 * a comment with leading whitespace?
 */
function isSpaceLike(node) {
    return (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) ||
        (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node) && Boolean(node.leadingWhitespace)));
}
/**
 * Similar to `head.push(...tail)` except that whitespace at the start
 * of `tail` and the end of `head` is collapsed.
 */
function joinWithoutExcessWhitespace(head, tail) {
    if (tail.length === 0) {
        return;
    }
    if (head.length === 0) {
        head.push(...tail);
        return;
    }
    const headEnd = head[head.length - 1];
    const tailStart = tail[0];
    // Whitespace we can just trim off from either end
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(tailStart)) {
        head.push(...tail.slice(1));
        return;
    }
    // If there's no whitespace at one of the ends, no need to worry
    // unless `tailStart` is a comment, in which case it should "eat"
    // the whitespace
    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
            const comment = {
                type: "comment",
                content: tailStart.content,
                sameline: true,
                leadingWhitespace: true,
            };
            tail = tail.slice(1);
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__.trimStart)(tail);
            head.pop();
            head.push(comment, ...tail);
            return;
        }
        head.push(...tail);
        return;
    }
    // If we're here, we have a comment with leading whitespace on one side
    // and whitespace/comments on the other.
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
        if (tailStart.leadingWhitespace || tailStart.sameline) {
            head.push({ type: "comment", content: tailStart.content }, ...tail.slice(1));
            return;
        }
        head.push(...tail);
        return;
    }
    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,
    // but make sure the comment has leading whitespace!
    let comment = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) ? headEnd : tailStart;
    if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(comment)) {
        throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);
    }
    if (!comment.leadingWhitespace || !comment.sameline) {
        comment = {
            type: "comment",
            content: comment.content,
            leadingWhitespace: true,
            sameline: true,
        };
    }
    head.pop();
    head.push(comment, ...tail.slice(1));
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts":
/*!*************************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommandInArray": () => (/* binding */ replaceStreamingCommandInArray)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./join-without-excess-whitespace */ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts");
/* harmony import */ var _wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");



/**
 * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.
 * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.
 * This function does not split based on parbreaks/etc.. It is right-associative and returns
 * the streaming commands that were encountered.
 */
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
    // Streaming commands that come at the end don't do anything,
    // so we should remove them
    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
        nodes.pop();
        (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd)(nodes);
    }
    const foundStreamingCommands = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (isStreamingCommand(node)) {
            const wrapper = (content) => replacer(content, node);
            let tail = nodes.slice(i + 1);
            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart)(tail);
            tail = (0,_wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__.wrapSignificantContent)(tail, wrapper);
            foundStreamingCommands.push(node);
            // Trim off what we're about to replace!
            nodes.splice(i);
            (0,_join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__.joinWithoutExcessWhitespace)(nodes, tail);
        }
    }
    return { foundStreamingCommands };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts":
/*!***************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/wrap-significant-content.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrapSignificantContent": () => (/* binding */ wrapSignificantContent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Wraps `content` in the specified wrapper. This command is roughly equivalent to
 * `wrapper(content)` except that leading and trailing whitespace and comments are extracted
 * from `content` and moved to the front or back of the return array. For example,
 * `[" ", "foo", "bar", "% xxx"]` -> `[" ", wrapped(["foo", "bar"]), "% xxx"]`.
 *
 */
function wrapSignificantContent(content, wrapper) {
    let hoistUntil = 0;
    let hoistAfter = content.length;
    for (let i = 0; i < content.length; i++) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[i]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[i])) {
            hoistUntil = i + 1;
            continue;
        }
        break;
    }
    for (let j = content.length - 1; j >= 0; j--) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[j]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[j])) {
            hoistAfter = j;
            continue;
        }
        break;
    }
    if (hoistUntil === 0 && hoistAfter === content.length) {
        return ensureArray(wrapper(content));
    }
    const frontMatter = content.slice(0, hoistUntil);
    const middle = content.slice(hoistUntil, hoistAfter);
    const backMatter = content.slice(hoistAfter, content.length);
    return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
    if (!Array.isArray(x)) {
        return [x];
    }
    return x;
}


/***/ }),

/***/ "./unified-latex-util-split/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-split/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* reexport safe */ _libs_array_join__WEBPACK_IMPORTED_MODULE_3__.arrayJoin),
/* harmony export */   "splitOnCondition": () => (/* reexport safe */ _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition),
/* harmony export */   "splitOnMacro": () => (/* reexport safe */ _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__.splitOnMacro),
/* harmony export */   "unsplitOnMacro": () => (/* reexport safe */ _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__.unsplitOnMacro)
/* harmony export */ });
/* harmony import */ var _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/split-on-macro */ "./unified-latex-util-split/libs/split-on-macro.ts");
/* harmony import */ var _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");
/* harmony import */ var _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unsplit-on-macro */ "./unified-latex-util-split/libs/unsplit-on-macro.ts");
/* harmony import */ var _libs_array_join__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/array-join */ "./unified-latex-util-split/libs/array-join.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to manipulate `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want break apart or join an array of nodes based on a condition. For example,
 * this is used to split on `&` characters in the `align` environment.
 */ 


/***/ }),

/***/ "./unified-latex-util-split/libs/array-join.ts":
/*!*****************************************************!*\
  !*** ./unified-latex-util-split/libs/array-join.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* binding */ arrayJoin)
/* harmony export */ });
/**
 * Joins an array of arrays with the item `sep`
 */
function arrayJoin(array, sep) {
    return array.flatMap((item, i) => {
        if (i === 0) {
            return item;
        }
        if (Array.isArray(sep)) {
            return [...sep, ...item];
        }
        else {
            return [sep, ...item];
        }
    });
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-condition.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-condition.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnCondition": () => (/* binding */ splitOnCondition)
/* harmony export */ });
/**
 * Split a list of nodes based on whether `splitFunc` returns `true`.
 * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then
 * there will be at most two segments returned.
 */
function splitOnCondition(nodes, splitFunc = () => false, options) {
    if (!Array.isArray(nodes)) {
        throw new Error(`Can only split an Array, not ${nodes}`);
    }
    const { onlySplitOnFirstOccurrence = false } = options || {};
    const splitIndices = [];
    for (let i = 0; i < nodes.length; i++) {
        if (splitFunc(nodes[i])) {
            splitIndices.push(i);
            if (onlySplitOnFirstOccurrence) {
                break;
            }
        }
    }
    // Short circuit if there is no splitting to be done
    if (splitIndices.length === 0) {
        return { segments: [nodes], separators: [] };
    }
    let separators = splitIndices.map((i) => nodes[i]);
    let segments = splitIndices.map((splitEnd, i) => {
        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
        return nodes.slice(splitStart, splitEnd);
    });
    segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
    return { segments, separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-macro.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-macro.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnMacro": () => (/* binding */ splitOnMacro)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");


/**
 * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`
 * is returned. The original array is reconstructed as
 * `segments[0] + macros[0] + segments[1] + ...`.
 *
 * @param {[object]} ast
 * @param {(string|[string])} macroName
 * @returns {{segments: [object], macros: [object]}}
 */
function splitOnMacro(ast, macroName) {
    if (typeof macroName === "string") {
        macroName = [macroName];
    }
    if (!Array.isArray(macroName)) {
        throw new Error("Type coercion failed");
    }
    const isSeparator = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.createMacroMatcher(macroName);
    const { segments, separators } = (0,_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(ast, isSeparator);
    return { segments, macros: separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/unsplit-on-macro.ts":
/*!***********************************************************!*\
  !*** ./unified-latex-util-split/libs/unsplit-on-macro.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsplitOnMacro": () => (/* binding */ unsplitOnMacro)
/* harmony export */ });
/**
 * Does the reverse of `splitOnMacro`
 */
function unsplitOnMacro({ segments, macros, }) {
    if (segments.length === 0) {
        console.warn("Trying to join zero segments");
        return [];
    }
    if (segments.length !== macros.length + 1) {
        console.warn("Mismatch between lengths of macros and segments when trying to unsplit");
    }
    let ret = segments[0];
    for (let i = 0; i < macros.length; i++) {
        // Even though the type of macros[i] is node and not array,
        // Array.concat still works
        ret = ret.concat(macros[i]).concat(segments[i + 1]);
    }
    return ret;
}


/***/ }),

/***/ "./unified-latex-util-trim/index.ts":
/*!******************************************!*\
  !*** ./unified-latex-util-trim/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* reexport safe */ _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__.hasWhitespaceEquivalent),
/* harmony export */   "trim": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trim),
/* harmony export */   "trimEnd": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd),
/* harmony export */   "trimStart": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart),
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* reexport safe */ _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexTrimEnvironmentContents),
/* harmony export */   "unifiedLatexTrimRoot": () => (/* reexport safe */ _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__.unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _libs_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/trim */ "./unified-latex-util-trim/libs/trim.ts");
/* harmony import */ var _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-trim-environment-contents */ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts");
/* harmony import */ var _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unified-latex-trim-root */ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts");
/* harmony import */ var _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/has-whitespace-equivalent */ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to remove whitespace from the ends of an array of nodes.
 *
 * Note that whitespace can come from a `Ast.Whitespace` node or from an
 * `Ast.Comment` node that has leading whitespace. These functions take care
 * to deal with both situations.
 */


/***/ }),

/***/ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts":
/*!*******************************************************************!*\
  !*** ./unified-latex-util-trim/libs/has-whitespace-equivalent.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* binding */ hasWhitespaceEquivalent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`
 * are counted as whitespace. Other comments are ignored.
 */
function hasWhitespaceEquivalent(nodes) {
    let start = false;
    let end = false;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            // A comment with leading whitespace will render with leading whitespace,
            // so if we encounter one, we should consider ourselves to have leading whitespace.
            if (node.leadingWhitespace) {
                start = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            start = true;
        }
        break;
    }
    for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            if (node.leadingWhitespace) {
                end = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            end = true;
        }
        break;
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/trim.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-trim/libs/trim.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "trimEnd": () => (/* binding */ trimEnd),
/* harmony export */   "trimStart": () => (/* binding */ trimStart)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Trims whitespace and parbreaks from the start and end
 * of an array. The number of trimmed nodes is returned.
 * Special care is taken to preserve comments, though any whitespace
 * before the first comment(s) or after the last comment(s) is trimmed.
 */
function trim(nodes) {
    if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
}
/**
 * Trim whitespace and parbreaks from the left of an array.
 */
function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    // If there are comments at the start, they might have leading whitespace.
    // This leading whitespace should be trimmed
    for (const leadingToken of nodes) {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(leadingToken)) {
            break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
            // We remove the position information from this token to indicate that we've edited it
            delete leadingToken.position;
        }
        // Special care must be taken. If the comment was on the same line as a
        // parskip, it will no longer be on the same line after the trimming.
        // Thus, we must modify the comment.
        if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
            delete leadingToken.position;
        }
    }
    return { trimmedStart: start };
}
/**
 * Trim whitespace and parbreaks from the right of an array.
 */
function trimEnd(nodes) {
    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end, end);
    // Trim off any spaces belonging to trailing comments
    for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken)) {
            break;
        }
        // We don't trim spaces before trailing same-line comments. This is a stylistic choice
        // so that
        // `foo %xxx` does not become `foo%xxx`.
        // The latter is strictly "correct" for a trim function, but it is prettier to format
        // code preserving the space before the sameline comment
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken) &&
            trailingToken.leadingWhitespace &&
            !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
            delete trailingToken.position;
        }
    }
    return { trimmedEnd: end };
}
/**
 * Returns the number of whitespace/parbreak nodes at the start and end of an array.
 */
function amountOfLeadingAndTrailingWhitespace(ast) {
    let start = 0;
    let end = 0;
    for (const node of ast) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            start++;
        }
        else {
            break;
        }
    }
    if (start === ast.length) {
        return { start, end: 0 };
    }
    // Find the padding on the right
    for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            end++;
        }
        else {
            break;
        }
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* binding */ unifiedLatexTrimEnvironmentContents)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");



/**
 * Unified plugin to trim the whitespace from the start/end of any environments, including
 * math environments.
 */
const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents() {
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
            if (!(_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.anyEnvironment(node))) {
                return;
            }
            // If the first thing in the environment is a sameline comment,
            // we actually want to start trimming *after* it.
            let firstNode = node.content[0];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(firstNode) && firstNode.sameline) {
                firstNode.suffixParbreak = false;
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(node.content);
                // We play a nasty trick here. This call to `trimStart`
                // will actually modify `node.content` if `node.content.slice(1)` starts
                // with a comment that has leading whitespace (it will remove that whitespace).
                // However, it won't remove any elements from `node.content`; we need
                // to do that ourselves.
                const { trimmedStart } = (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(node.content.slice(1));
                node.content.splice(1, trimmedStart);
            }
            else {
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(node.content);
            }
        });
    };
};


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts":
/*!*****************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-root.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimRoot": () => (/* binding */ unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");

/**
 * Unified plugin to trim the whitespace from the start/end of the root element.
 */
const unifiedLatexTrimRoot = function unifiedLatexTrimRoot() {
    return (tree) => {
        (0,_trim__WEBPACK_IMPORTED_MODULE_0__.trim)(tree.content);
    };
};


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this node’s children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************************************!*\
  !*** ./unified-latex-util-replace/index.ts ***!
  \*********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* reexport safe */ _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNode),
/* harmony export */   "replaceStreamingCommand": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommandInGroup),
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* reexport safe */ _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/replace-node */ "./unified-latex-util-replace/libs/replace-node.ts");
/* harmony import */ var _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-streaming-command */ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts");
/* harmony import */ var _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");



// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */

})();

var __webpack_exports__replaceNode = __webpack_exports__.replaceNode;
var __webpack_exports__replaceStreamingCommand = __webpack_exports__.replaceStreamingCommand;
var __webpack_exports__replaceStreamingCommandInGroup = __webpack_exports__.replaceStreamingCommandInGroup;
var __webpack_exports__unifiedLatexReplaceStreamingCommands = __webpack_exports__.unifiedLatexReplaceStreamingCommands;
export { __webpack_exports__replaceNode as replaceNode, __webpack_exports__replaceStreamingCommand as replaceStreamingCommand, __webpack_exports__replaceStreamingCommandInGroup as replaceStreamingCommandInGroup, __webpack_exports__unifiedLatexReplaceStreamingCommands as unifiedLatexReplaceStreamingCommands };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLLENBQUMsRUFBRTtRQUN0QixPQUFPLEtBQUssQ0FBQztLQUNoQjtJQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzNCLE9BQU8sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDNUI7SUFFRCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkIsQ0FBQzs7Ozs7OztTQ25VRDtTQUNBOztTQUVBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBOztTQUVBO1NBQ0E7O1NBRUE7U0FDQTtTQUNBOzs7OztVQ3RCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLHlDQUF5Qyx3Q0FBd0M7VUFDakY7VUFDQTtVQUNBOzs7OztVQ1BBOzs7OztVQ0FBO1VBQ0E7VUFDQTtVQUNBLHVEQUF1RCxpQkFBaUI7VUFDeEU7VUFDQSxnREFBZ0QsYUFBYTtVQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOb0M7QUFDbUI7QUFDTjtBQUVqRCwwRUFBMEU7QUFDMUU7Ozs7Ozs7O0dBUUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC1saW50L3V0aWxzL3JlcGxhY2Utbm9kZS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvbGlicy9tYXRjaC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9saWJzL3ByaW50LXJhdy50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy9yZXBsYWNlLW5vZGUudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvcmVwbGFjZS1zdHJlYW1pbmctY29tbWFuZC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy91bmlmaWVkLWxhdGV4LXN0cmVhbWluZy1jb21tYW5kLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL2ZpcnN0LXNpZ25pZmljYW50LW5vZGUudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvdXRpbHMvam9pbi13aXRob3V0LWV4Y2Vzcy13aGl0ZXNwYWNlLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL3JlcGxhY2Utc3RyZWFtaW5nLWNvbW1hbmQtaW4tYXJyYXkudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvdXRpbHMvd3JhcC1zaWduaWZpY2FudC1jb250ZW50LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL2FycmF5LWpvaW4udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3NwbGl0LW9uLWNvbmRpdGlvbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNwbGl0L2xpYnMvc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3Vuc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL2hhcy13aGl0ZXNwYWNlLWVxdWl2YWxlbnQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdHJpbS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXRyaW0vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHMudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3QudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvbGlzdC1tYXRoLWNoaWxkcmVuLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvbGlicy92aXNpdC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZpc2l0SW5mbyB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IG5vZGUgd2l0aCBgcmVwbGFjZW1lbnRgLiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIGN1cnJlbnRcbiAqIG5vZGUgaXMgaW4gYW4gYXJyYXkgdGhhdCBpcyBhIGNoaWxkIG9mIGEgcGFyZW50IGVsZW1lbnQuIElmIHRoaXMgaXMgbm90IHRoZSBjYXNlLFxuICogdGhlIGZ1bmN0aW9uIHdpbGwgZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlTm9kZUR1cmluZ1Zpc2l0KFxuICAgIHJlcGxhY2VtZW50OiBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCB8IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXSxcbiAgICBpbmZvOiBWaXNpdEluZm9cbikge1xuICAgIGNvbnN0IHBhcmVudCA9IGluZm8ucGFyZW50c1swXTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIG5vZGU6IHBhcmVudCBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50W2luZm8ua2V5IGFzIGtleW9mIHR5cGVvZiBwYXJlbnRdIGFzIChcbiAgICAgICAgfCBBc3QuTm9kZVxuICAgICAgICB8IEFzdC5Bcmd1bWVudFxuICAgIClbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29udGFpbmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIG5vZGU6IGNvbnRhaW5pbmcgYXJyYXkgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIGlmIChpbmZvLmluZGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlOiBub2RlIGluZGV4IHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgIGNvbnRhaW5lcltpbmZvLmluZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zcGxpY2UoaW5mby5pbmRleCwgMSwgLi4ucmVwbGFjZW1lbnQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4vbGlicy9tYXRjaFwiO1xuXG5leHBvcnQgeyBtYXRjaCB9O1xuXG5leHBvcnQgY29uc3Qge1xuICAgIGFueUVudmlyb25tZW50LFxuICAgIGFueU1hY3JvLFxuICAgIGFueVN0cmluZyxcbiAgICBhcmd1bWVudCxcbiAgICBibGFua0FyZ3VtZW50LFxuICAgIGNvbW1lbnQsXG4gICAgZW52aXJvbm1lbnQsXG4gICAgZ3JvdXAsXG4gICAgbWFjcm8sXG4gICAgbWF0aCxcbiAgICBwYXJicmVhayxcbiAgICBzdHJpbmcsXG4gICAgd2hpdGVzcGFjZSxcbn0gPSBtYXRjaDtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBtYXRjaCBkaWZmZXJlbnQgYEFzdC5Ob2RlYCB0eXBlcyBpbiBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSBuZWVkIGEgdHlwZS1ndWFyZCB0byBlbnN1cmUgYSBub2RlIGlzIG9mIGEgY2VydGFpbiB0eXBlOyBmb3IgZXhhbXBsZSwgZHVyaW5nIGEgY2FsbCB0byBgdW5pZmllZC1sYXRleC11bnRpbC12aXNpdGAuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgRW52SW5mbywgTWFjcm9JbmZvLCBNYWNyb0luZm9SZWNvcmQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgcHJpbnRSYXcgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhd1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYWNybyBtYXRjaGluZyBmdW5jdGlvbiB0aGF0IHVzZXMgYSBgU3BlY2lhbE1hY3JvU3BlY2Agb3IgbGlzdCBvZiBtYWNyb3NcbiAqIGFuZCBnZW5lcmF0ZXMgYSBoYXNoIGZvciBxdWljayBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY3JvTWF0Y2hlcihcbiAgICBtYWNyb3M6IEFzdC5NYWNyb1tdIHwgc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKSB7XG4gICAgLy8gV2UgZmlyc3QgbWFrZSBzdXJlIHdlIGhhdmUgYSByZWNvcmQgdHlwZSB3aXRoIGtleXMgYmVpbmcgdGhlIG1hY3JvJ3MgY29udGVudHNcbiAgICBjb25zdCBtYWNyb3NIYXNoID0gQXJyYXkuaXNBcnJheShtYWNyb3MpXG4gICAgICAgID8gbWFjcm9zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdHlwZW9mIG1hY3Jvc1swXSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFjcm8gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGJyYW5jaCBvZiBtYXAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNybywge31dIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWNyby5lc2NhcGVUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hY3JvLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBlc2NhcGVUb2tlbjogbWFjcm8uZXNjYXBlVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21hY3JvLmNvbnRlbnQsIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHt9XG4gICAgICAgIDogbWFjcm9zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoQWdhaW5zdE1hY3Jvcyhub2RlOiBhbnkgfCBBc3QuTWFjcm8pIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCB8fCBub2RlLnR5cGUgIT09IFwibWFjcm9cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhIG1hY3JvIHR5cGVcbiAgICAgICAgY29uc3Qgc3BlYyA9IG1hY3Jvc0hhc2hbbm9kZS5jb250ZW50XTtcbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwib2JqZWN0XCIgJiYgXCJlc2NhcGVUb2tlblwiIGluIHNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNwZWMgYXMgTWFjcm9JbmZvUmVjb3JkKS5lc2NhcGVUb2tlbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHNwZWMgYXMgTWFjcm9JbmZvUmVjb3JkKS5lc2NhcGVUb2tlbiA9PT0gbm9kZS5lc2NhcGVUb2tlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGFzIEFzdC5UeXBlR3VhcmQ8QXN0Lk1hY3JvPjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbnZpcm9ubWVudE1hdGNoZXIobWFjcm9zOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgLy8gV2UgZmlyc3QgbWFrZSBzdXJlIHdlIGhhdmUgYSByZWNvcmQgdHlwZSB3aXRoIGtleXMgYmVpbmcgdGhlIG1hY3JvJ3MgY29udGVudHNcbiAgICBjb25zdCBlbnZpcm9ubWVudHNIYXNoID0gQXJyYXkuaXNBcnJheShtYWNyb3MpXG4gICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICBtYWNyb3MubWFwKChzdHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RyLCB7fV0gYXMgW3N0cmluZywgRW52SW5mb107XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RFbnZpcm9ubWVudHMobm9kZTogYW55IHwgQXN0LkVudmlyb25tZW50KSB7XG4gICAgICAgIGlmICghbWF0Y2guYW55RW52aXJvbm1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYW4gZW52aXJvbm1lbnQgdHlwZVxuICAgICAgICBjb25zdCBlbnZOYW1lID0gcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICBjb25zdCBzcGVjID0gZW52aXJvbm1lbnRzSGFzaFtlbnZOYW1lXTtcbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGFzIEFzdC5UeXBlR3VhcmQ8QXN0LkVudmlyb25tZW50Pjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IHR5cGVzIG9mIG5vZGVzLlxuICovXG5leHBvcnQgY29uc3QgbWF0Y2ggPSB7XG4gICAgbWFjcm8obm9kZTogYW55LCBtYWNyb05hbWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIm1hY3JvXCIgJiZcbiAgICAgICAgICAgIChtYWNyb05hbWUgPT0gbnVsbCB8fCBub2RlLmNvbnRlbnQgPT09IG1hY3JvTmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueU1hY3JvKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0Lk1hY3JvIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLm1hY3JvKG5vZGUpO1xuICAgIH0sXG4gICAgZW52aXJvbm1lbnQobm9kZTogYW55LCBlbnZOYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChub2RlLnR5cGUgPT09IFwiZW52aXJvbm1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwibWF0aGVudlwiKSAmJlxuICAgICAgICAgICAgKGVudk5hbWUgPT0gbnVsbCB8fCBwcmludFJhdyhub2RlLmVudikgPT09IGVudk5hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlFbnZpcm9ubWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5FbnZpcm9ubWVudCB7XG4gICAgICAgIHJldHVybiBtYXRjaC5lbnZpcm9ubWVudChub2RlKTtcbiAgICB9LFxuICAgIGNvbW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQ29tbWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNvbW1lbnRcIjtcbiAgICB9LFxuICAgIHBhcmJyZWFrKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LlBhcmJyZWFrIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwicGFyYnJlYWtcIjtcbiAgICB9LFxuICAgIHdoaXRlc3BhY2Uobm9kZTogYW55KTogbm9kZSBpcyBBc3QuV2hpdGVzcGFjZSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgd2hpdGVzcGFjZSBvciBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgICovXG4gICAgd2hpdGVzcGFjZUxpa2UoXG4gICAgICAgIG5vZGU6IGFueVxuICAgICk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2UgfCAoQXN0LkNvbW1lbnQgJiB7IGxlYWRpbmdXaGl0ZXNwYWNlOiB0cnVlIH0pIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiIHx8XG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiAmJiBub2RlLmxlYWRpbmdXaGl0ZXNwYWNlID09PSB0cnVlKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgc3RyaW5nKG5vZGU6IGFueSwgdmFsdWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAodmFsdWUgPT0gbnVsbCB8fCBub2RlLmNvbnRlbnQgPT09IHZhbHVlKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55U3RyaW5nKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LlN0cmluZyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5zdHJpbmcobm9kZSk7XG4gICAgfSxcbiAgICBncm91cChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Hcm91cCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImdyb3VwXCI7XG4gICAgfSxcbiAgICBhcmd1bWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Bcmd1bWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImFyZ3VtZW50XCI7XG4gICAgfSxcbiAgICBibGFua0FyZ3VtZW50KG5vZGU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIW1hdGNoLmFyZ3VtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUub3Blbk1hcmsgPT09IFwiXCIgJiZcbiAgICAgICAgICAgIG5vZGUuY2xvc2VNYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNvbnRlbnQubGVuZ3RoID09PSAwXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBtYXRoKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkRpc3BsYXlNYXRoIHwgQXN0LklubGluZU1hdGgge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJkaXNwbGF5bWF0aFwiIHx8IG5vZGUudHlwZSA9PT0gXCJpbmxpbmVtYXRoXCI7XG4gICAgfSxcbiAgICBjcmVhdGVNYWNyb01hdGNoZXIsXG4gICAgY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyLFxufTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvcHJpbnQtcmF3XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gcHJpbnQgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkgdG8gYSBzdHJpbmcuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBkaXJlY3RseSBwcmludCBhbiBgQXN0LkFzdGAgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nIG9yIGZvcm1hdHRpbmcuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG50eXBlIFByaW50YWJsZSA9IEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50IHwgc3RyaW5nO1xudHlwZSBQcmludFRva2VuID0gc3RyaW5nIHwgdHlwZW9mIGxpbmVicmVhaztcblxuZXhwb3J0IGNvbnN0IGxpbmVicmVhayA9IFN5bWJvbChcImxpbmVicmVha1wiKTtcbmNvbnN0IEVTQ0FQRSA9IFwiXFxcXFwiO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhbiBhcnJheSBpbnNlcnRpbmcgYGxpbmVicmVha2Agd2hlcmUgbmVlZGVkO1xuICogVGhpcyBhcnJheSBtYXkgYmUgbmVzdGVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICovXG5mdW5jdGlvbiBfcHJpbnRSYXcobm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10pOiBQcmludFRva2VuW10ge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICByZXR1cm4gKFtdIGFzIFByaW50VG9rZW5bXSkuY29uY2F0KFxuICAgICAgICAgICAgLi4ubm9kZS5tYXAoKG46IFByaW50YWJsZSkgPT4gX3ByaW50UmF3KG4pKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyB0bXAgdmFyaWFibGVzXG4gICAgbGV0IGFyZ3NTdHJpbmcsIGVzY2FwZTtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9wcmludFJhdyhub2RlLmNvbnRlbnQpO1xuICAgICAgICBjYXNlIFwiYXJndW1lbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5vcGVuTWFyaywgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIG5vZGUuY2xvc2VNYXJrXTtcbiAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBub2RlLnN1ZmZpeFBhcmJyZWFrID8gXCJcIiA6IGxpbmVicmVhaztcbiAgICAgICAgICAgIC8vIEEgY29tbWVudCBpcyByZXNwb25zaWJsZSBmb3IgcHJpbnRpbmcgaXRzIG93biBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSAmJiBub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIFwiJVwiLFxuICAgICAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgXCIlXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBzdWZmaXhdO1xuICAgICAgICBjYXNlIFwiZW52aXJvbm1lbnRcIjpcbiAgICAgICAgY2FzZSBcIm1hdGhlbnZcIjpcbiAgICAgICAgY2FzZSBcInZlcmJhdGltXCI6XG4gICAgICAgICAgICB2YXIgZW52ID0gX3ByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgICAgIHZhciBlbnZTdGFydDogUHJpbnRUb2tlbltdID0gW0VTQ0FQRSArIFwiYmVnaW57XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgdmFyIGVudkVuZDogUHJpbnRUb2tlbltdID0gW0VTQ0FQRSArIFwiZW5ke1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPVxuICAgICAgICAgICAgICAgIChub2RlIGFzIGFueSkuYXJncyA9PSBudWxsID8gW10gOiBfcHJpbnRSYXcoKG5vZGUgYXMgYW55KS5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4uZW52U3RhcnQsXG4gICAgICAgICAgICAgICAgLi4uYXJnc1N0cmluZyxcbiAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAuLi5lbnZFbmQsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwiZGlzcGxheW1hdGhcIjpcbiAgICAgICAgICAgIHJldHVybiBbRVNDQVBFICsgXCJbXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBFU0NBUEUgKyBcIl1cIl07XG4gICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIntcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwifVwiXTtcbiAgICAgICAgY2FzZSBcImlubGluZW1hdGhcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIkXCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIiRcIl07XG4gICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgYXJnc1N0cmluZyA9IG5vZGUuYXJncyA9PSBudWxsID8gW10gOiBfcHJpbnRSYXcobm9kZS5hcmdzKTtcbiAgICAgICAgICAgIGVzY2FwZSA9IG5vZGUuZXNjYXBlVG9rZW4gPT0gbnVsbCA/IEVTQ0FQRSA6IG5vZGUuZXNjYXBlVG9rZW47XG4gICAgICAgICAgICByZXR1cm4gW2VzY2FwZSwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIC4uLmFyZ3NTdHJpbmddO1xuICAgICAgICBjYXNlIFwicGFyYnJlYWtcIjpcbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBsaW5lYnJlYWtdO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUuY29udGVudF07XG4gICAgICAgIGNhc2UgXCJ2ZXJiXCI6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEVTQ0FQRSxcbiAgICAgICAgICAgICAgICBub2RlLmVudixcbiAgICAgICAgICAgICAgICBub2RlLmVzY2FwZSxcbiAgICAgICAgICAgICAgICAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICBub2RlLmVzY2FwZSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJ3aGl0ZXNwYWNlXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiIFwiXTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IGZpbmQgcmVuZGVyIGZvciBub2RlIFwiLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgYChvZiB0eXBlICR7dHlwZW9mIG5vZGV9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gW1wiXCIgKyBub2RlXTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZy5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEBwYXJhbSB7Kn0gb3B0aW9ucyAtIFNldHRpbmcgYGFzQXJyYXlgIHRvIGB0cnVlYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0aGUgc3ltYm9sIGBsaW5lYnJlYWtgLCBzbyB0aGF0IHByaW50aW5nIGNhbiBiZSBjdXN0b21pemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9ucz86IHsgYXNBcnJheTogZmFsc2UgfVxuKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM6IHsgYXNBcnJheTogdHJ1ZSB9XG4pOiBQcmludFRva2VuW107XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcobm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sIG9wdGlvbnM/OiBvYmplY3QpOiBhbnkge1xuICAgIGNvbnN0IGFzQXJyYXkgPSBvcHRpb25zICE9IG51bGwgPyAob3B0aW9ucyBhcyBhbnkpLmFzQXJyYXkgOiBmYWxzZTtcbiAgICBjb25zdCBwcmludGVkVG9rZW5zID0gX3ByaW50UmF3KG5vZGUpO1xuICAgIGlmIChhc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBwcmludGVkVG9rZW5zO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbnRlZFRva2Vucy5tYXAoKHgpID0+ICh4ID09PSBsaW5lYnJlYWsgPyBcIlxcblwiIDogeCkpLmpvaW4oXCJcIik7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHZpc2l0LCBWaXNpdG9yQ29udGV4dCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIG5vZGVzIGluIGBhc3RgLiBUaGUgYHZpc2l0b3JgIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIG5vZGUuIElmXG4gKiBgdmlzaXRvcmAgcmV0dXJucyBhIG5vZGUgb3IgYW4gYXJyYXkgb2Ygbm9kZXMsIHRob3NlIG5vZGVzIHJlcGxhY2UgdGhlIG5vZGUgcGFzc2VkIHRvIGB2aXNpdG9yYC5cbiAqIElmIGBudWxsYCBpcyByZXR1cm5lZCwgdGhlIG5vZGUgaXMgZGVsZXRlZC4gSWYgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQsIG5vIHJlcGxhY2VtZW50IGhhcHBlbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlTm9kZShcbiAgICBhc3Q6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjogKFxuICAgICAgICBub2RlOiBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCxcbiAgICAgICAgY29udGV4dDogVmlzaXRvckNvbnRleHRcbiAgICApID0+XG4gICAgICAgIHwgQXN0Lk5vZGVcbiAgICAgICAgfCBBc3QuQXJndW1lbnRcbiAgICAgICAgfCAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW11cbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgIHwgdm9pZFxuKSB7XG4gICAgdmlzaXQoYXN0LCAobm9kZSwgaW5mbykgPT4ge1xuICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB2aXNpdG9yKG5vZGUsIGluZm8uY29udGV4dCk7XG4gICAgICAgIC8vIFJldHVybmluZyBgdW5kZWZpbmVkYCBvciB0aGUgc2FtZSBub2RlIG1lYW5zIHdlIHNob3VsZG4ndCByZXBsYWNlIHRoYXQgbm9kZVxuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcInVuZGVmaW5lZFwiIHx8IHJlcGxhY2VtZW50ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluZm8uY29udGFpbmluZ0FycmF5IHx8IGluZm8uaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVHJ5aW5nIHRvIGRlbGV0ZSBub2RlLCBidXQgY2Fubm90IGZpbmQgY29udGFpbmluZyBhcnJheVwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSAmJiByZXBsYWNlbWVudC5sZW5ndGggPT09IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gQSBudWxsIHJldHVybiBtZWFucyB0aGF0IHdlIGRlbGV0ZSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICBpbmZvLmNvbnRhaW5pbmdBcnJheS5zcGxpY2UoaW5mby5pbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gaW5mby5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gW3JlcGxhY2VtZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm8uY29udGFpbmluZ0FycmF5LnNwbGljZShpbmZvLmluZGV4LCAxLCAuLi5yZXBsYWNlbWVudCk7XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gKnJlcHJvY2VzcyogdGhlIG5vZGVzIHdlIGp1c3QgaW5zZXJ0ZWQgaW50byB0aGUgYXJyYXksXG4gICAgICAgIC8vIGxlc3Qgd2UgZ2V0IHN0dWNrIGluIGEgcmVjdXJzaXZlIGxvb3AgaWYgdGhlIHJlcGxhY2VtZW50IGNvbnRhaW5zIHRoZSBvcmlnaW5hbC5cbiAgICAgICAgLy8gVGh1cyB3ZSBqdW1wIHRvIHRoZSBpbmRleCBhZnRlciBvdXIgcmVwbGFjZW1lbnRzLlxuICAgICAgICByZXR1cm4gaW5mby5pbmRleCArIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICB9KTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQge1xuICAgIHNwbGl0T25Db25kaXRpb24sXG4gICAgdW5zcGxpdE9uTWFjcm8sXG59IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXRcIjtcbmltcG9ydCB7IHRyaW0sIHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbVwiO1xuaW1wb3J0IHsgZmlyc3RTaWduaWZpY2FudE5vZGUgfSBmcm9tIFwiLi91dGlscy9maXJzdC1zaWduaWZpY2FudC1ub2RlXCI7XG5pbXBvcnQgeyByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluQXJyYXkgfSBmcm9tIFwiLi91dGlscy9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kLWluLWFycmF5XCI7XG5pbXBvcnQgeyB3cmFwU2lnbmlmaWNhbnRDb250ZW50IH0gZnJvbSBcIi4vdXRpbHMvd3JhcC1zaWduaWZpY2FudC1jb250ZW50XCI7XG5cbnR5cGUgUmVwbGFjZXIgPSAobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlW107XG5cbi8qKlxuICogUHJvY2VzcyBzdHJlYW1pbmcgY29tbWFuZHMgaW4gYSBncm91cC4gSWYgbmVlZGVkLCBcImVzY2FwZVwiIHRoZSBncm91cC5cbiAqIEZvciBleGFtcGxlLCBge1xcYmZzZXJpZXMgeHh9YCAtPiBgXFx0ZXh0YmZ7eHh9YCwgYnV0IGB7Zm9vIFxcYmZzZXJpZXMgeHh9YCAtPiBge2ZvbyBcXHRleHRiZnt4eH19YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kSW5Hcm91cChcbiAgICBncm91cDogQXN0Lkdyb3VwLFxuICAgIGlzU3RyZWFtaW5nQ29tbWFuZDogKG5vZGU6IGFueSkgPT4gbm9kZSBpcyBBc3QuTWFjcm8sXG4gICAgcmVwbGFjZXI6IChcbiAgICAgICAgY29udGVudDogQXN0Lk5vZGVbXSxcbiAgICAgICAgc3RyZWFtaW5nQ29tbWFuZDogQXN0Lk1hY3JvXG4gICAgKSA9PiBBc3QuTm9kZSB8IEFzdC5Ob2RlW11cbik6IEFzdC5Ob2RlW10ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBncm91cC5jb250ZW50O1xuICAgIC8vIElmIHRoZSBncm91cCBzdGFydGVkIHdpdGggYSBzdHJlYW1pbmcgY29tbWFuZCwgd2Ugd2FudCB0byBwb3BcbiAgICAvLyBvdXQgb2YgdGhlIGdyb3VwLiBFLmcuIGB7XFxiZnNlcmllcyBmb299YCAtPiBgXFx0ZXh0YmZ7Zm9vfWAgYW5kIG5vdCBge1xcdGV4dGJme2Zvb319YFxuICAgIGxldCBwb3BGcm9tR3JvdXAgPSBpc1N0cmVhbWluZ0NvbW1hbmQoZmlyc3RTaWduaWZpY2FudE5vZGUoY29udGVudCkpO1xuXG4gICAgbGV0IGlubmVyUHJvY2Vzc2VkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGlzU3RyZWFtaW5nQ29tbWFuZCxcbiAgICAgICAgcmVwbGFjZXJcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIGdyb3VwIGNvbnNpc3RlZCBvZiBqdXN0IHN0cmVhbWluZyBjb21tYW5kcyAoZm9yIHNvbWUgcmVhc29uLi4uKVxuICAgIC8vIGl0IHNob3VsZCBiZSBlbGltaW5hdGVkXG4gICAgaWYgKGlubmVyUHJvY2Vzc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHBvcEZyb21Hcm91cCkge1xuICAgICAgICByZXR1cm4gaW5uZXJQcm9jZXNzZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwiZ3JvdXBcIiwgY29udGVudDogaW5uZXJQcm9jZXNzZWQgfV07XG4gICAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZ3JvdXAgb3IgYSBub2RlIGFycmF5LCBsb29rIGZvciBzdHJlYW1pbmcgY29tbWFuZHMgKGUuZy4sIGBcXGJmc2VyaWVzYCkgYW5kIHJlcGxhY2UgdGhlbVxuICogd2l0aCB0aGUgc3BlY2lmaWVkIG1hY3JvLiBUaGUgXCJhcmd1bWVudHNcIiBvZiB0aGUgc3RyZWFtaW5nIGNvbW1hbmQgYXJlIHBhc3NlZCB0byBgcmVwbGFjZXJgIGFuZCB0aGUgcmV0dXJuXG4gKiB2YWx1ZSBvZiBgcmVwbGFjZXJgIGlzIGluc2VydGVkIGludG8gdGhlIHN0cmVhbS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNvbW1hbmQgd2lsbCBzcGxpdCBhdCBwYXJicmVha3MgKHNpbmNlIGNvbW1hbmRzIGxpa2UgYFxcdGV4dGJmey4uLn0gZG8gbm90IGFjY2VwdCBwYXJicmVha3MgaW4gdGhlaXJcbiAqIGNvbnRlbnRzKSBhbmQgY2FsbCBgcmVwbGFjZXJgIG11bHRpcGxlIHRpbWVzLCBvbmNlIHBlciBwYXJhZ3JhcGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZChcbiAgICBhc3Q6IEFzdC5Hcm91cCB8IEFzdC5Ob2RlW10sXG4gICAgaXNTdHJlYW1pbmdDb21tYW5kOiAobm9kZTogYW55KSA9PiBub2RlIGlzIEFzdC5NYWNybyxcbiAgICByZXBsYWNlcjogKFxuICAgICAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgICAgICBzdHJlYW1pbmdDb21tYW5kOiBBc3QuTWFjcm9cbiAgICApID0+IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXVxuKTogQXN0Lk5vZGVbXSB7XG4gICAgaWYgKHR5cGVvZiBpc1N0cmVhbWluZ0NvbW1hbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJ2lzU3RyZWFtaW5nQ29tbWFuZCcgbXVzdCBiZSBhIGZ1bmN0aW9uLCBub3QgJyR7dHlwZW9mIGlzU3RyZWFtaW5nQ29tbWFuZH0nYFxuICAgICAgICApO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkQ29udGVudDogQXN0Lk5vZGVbXSA9IFtdO1xuICAgIGlmIChtYXRjaC5ncm91cChhc3QpKSB7XG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluR3JvdXAoXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICBpc1N0cmVhbWluZ0NvbW1hbmQsXG4gICAgICAgICAgICByZXBsYWNlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgLy8gU3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgY29tZSBhdCB0aGUgZW5kIG9mIGEgc2VxdWVuY2Ugb2Ygbm9kZXMgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIC8vIFRoZXkgYWxzbyB3aWxsIGNvbnN1bWUgd2hpdGVzcGFjZSwgc28gd2Ugc2hvdWxkIHJlbW92ZSB0aGVtIGFuZCB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSBhc3Q7XG4gICAgICAgIGxldCBzY2FuSW5kZXggPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBzbGljZUluZGV4ID0gc2NhbkluZGV4O1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICBzY2FuSW5kZXggPiAwICYmXG4gICAgICAgICAgICAoaXNTdHJlYW1pbmdDb21tYW5kKG5vZGVzW3NjYW5JbmRleCAtIDFdKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2Uobm9kZXNbc2NhbkluZGV4IC0gMV0pKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHNjYW5JbmRleC0tO1xuICAgICAgICAgICAgaWYgKGlzU3RyZWFtaW5nQ29tbWFuZChub2Rlc1tzY2FuSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIHNsaWNlSW5kZXggPSBzY2FuSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsaWNlSW5kZXggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKHNsaWNlSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNQYXIgPSAobm9kZTogQXN0Lk5vZGUpID0+XG4gICAgICAgICAgICBtYXRjaC5wYXJicmVhayhub2RlKSB8fCBtYXRjaC5tYWNybyhub2RlLCBcInBhclwiKTtcblxuICAgICAgICAvLyBXZSBzcGxpdCBvbiBib3RoIGEgcGFyYnJlYWsgYW5kIGEgbGl0ZXJhbCBgXFxwYXJgLiBCdXQgd2Ugd2lsbFxuICAgICAgICAvLyBub3JtYWxpemUgZXZlcnl0aGluZyB0byBiZSBwYXJicmVha3NcbiAgICAgICAgY29uc3Qgc3BsaXRCeVBhciA9IHNwbGl0T25Db25kaXRpb24obm9kZXMsIGlzUGFyKTtcbiAgICAgICAgc3BsaXRCeVBhci5zZXBhcmF0b3JzID0gc3BsaXRCeVBhci5zZXBhcmF0b3JzLm1hcCgoc2VwKSA9PlxuICAgICAgICAgICAgbWF0Y2gucGFyYnJlYWsoc2VwKSA/IHNlcCA6IHsgdHlwZTogXCJwYXJicmVha1wiIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXBsYWNlcnM6IFJlcGxhY2VyW10gPSBbXTtcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gc3BsaXRCeVBhci5zZWdtZW50cy5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5QWNjdW11bGF0ZWRSZXBsYWNlcnMobm9kZXM6IEFzdC5Ob2RlW10pOiBBc3QuTm9kZVtdIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwU2lnbmlmaWNhbnRDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zZVJlcGxhY2VycyhyZXBsYWNlcnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzIH0gPSByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluQXJyYXkoXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBpc1N0cmVhbWluZ0NvbW1hbmQsXG4gICAgICAgICAgICAgICAgcmVwbGFjZXJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFsbCBzdHJlYW1pbmcgY29tbWFuZHMgaW4gYHNlZ21lbnRgIGhhdmUgbm93IGJlZW4gcmVwbGFjZWQuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBjb21tYW5kcyBmcm9tIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGhzIHRoYXQgc2hvdWxkIHdyYXBcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNlZ21lbnQhXG4gICAgICAgICAgICBjb25zdCByZXQgPSBhcHBseUFjY3VtdWxhdGVkUmVwbGFjZXJzKHNlZ21lbnQpO1xuXG4gICAgICAgICAgICAvLyBBbnkgc3RyZWFtaW5nIGNvbW1hbmRzIGZyb20gdGhpcyBzZWdtZW50IHdpbGwgY2Fycnkgb3ZlciB0byB0aGUgbmV4dCxcbiAgICAgICAgICAgIC8vIHNvIGtlZXAgdHJhY2sgb2YgdGhlbS5cbiAgICAgICAgICAgIGZvdW5kU3RyZWFtaW5nQ29tbWFuZHMuZm9yRWFjaCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICByZXBsYWNlcnMucHVzaCgobm9kZXM6IEFzdC5Ob2RlW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gcmVwbGFjZXIobm9kZXMsIG1hY3JvIGFzIEFzdC5NYWNybyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3JldF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2Ugd2FzIGhvaXN0ZWQgaW4gZnJvbnQvYmFjayBvZiBlYWNoIHJlcGxhY2VyLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSBzZXBhcmF0ZWQgYnkgcGFyYnJlYWtzLCB3ZSBjYW4gc2FmZWx5IHRyaW0gYWxsIHRoYXQgd2hpdGVzcGFjZS5cbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmltRW5kKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gc2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cmltU3RhcnQoc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbShzZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSB1bnNwbGl0T25NYWNybyh7XG4gICAgICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgICAgICBtYWNyb3M6IHNwbGl0QnlQYXIuc2VwYXJhdG9ycyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZENvbnRlbnQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzZXF1ZW5jZSBvZiByZXBsYWNlciBmdW5jdGlvbnMgYFtmLCBnLCBoXWAgcmV0dXJuXG4gKiBgaCBcXGNpcmMgZyBcXGNpcmMgZmBcbiAqXG4gKiBAcGFyYW0geygobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlKVtdfSByZXBsYWNlcnNcbiAqIEByZXR1cm5zIHsobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlfVxuICovXG5mdW5jdGlvbiBjb21wb3NlUmVwbGFjZXJzKHJlcGxhY2VyczogUmVwbGFjZXJbXSk6IFJlcGxhY2VyIHtcbiAgICBpZiAocmVwbGFjZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcG9zZSB6ZXJvIHJlcGxhY2VtZW50IGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIChub2RlczogQXN0Lk5vZGVbXSkgPT4ge1xuICAgICAgICBsZXQgcmV0ID0gbm9kZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVwbGFjZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gcmVwbGFjZXJzW2ldO1xuICAgICAgICAgICAgcmV0ID0gZnVuYyhyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgeyByZXBsYWNlTm9kZUR1cmluZ1Zpc2l0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtbGludC91dGlscy9yZXBsYWNlLW5vZGVcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdFwiO1xuaW1wb3J0IHsgcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQgfSBmcm9tIFwiLi9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHtcbiAgICByZXBsYWNlcnM6IFJlY29yZDxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICAoXG4gICAgICAgICAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgICAgICAgICAgc3RyZWFtaW5nQ29tbWFuZDogQXN0Lk1hY3JvXG4gICAgICAgICkgPT4gQXN0Lk5vZGUgfCBBc3QuTm9kZVtdXG4gICAgPjtcbn07XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gcmVwbGFjZSBhbGwgZm91bmQgc3RyZWFtaW5nIGNvbW1hbmRzIHdpdGggdGhlaXIgYXJndW1lbnQtc3R5bGUgZXF1aXZhbGVudHMuXG4gKiBUaGlzIG9ubHkgYXBwbGllcyB0byBzZWN0aW9ucyBvZiB0aGUgdHJlZSB3aXRoIG5vIG1hdGggYW5jZXN0b3IuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMucmVwbGFjZXIgQSByZWNvcmQgb2YgbWFjcm8gbmFtZXMgYW5kIHJlcGxhY2VyIGZ1bmN0aW9ucy4gQSByZXBsYWNlciBmdW5jdGlvbiBhY2NlcHRzIGNvbnRlbnQgYW5kIHRoZSBvcmlnaW5hbCBzdHJlYW1pbmcgY29tbWFuZCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIHRoZSBhcmd1bWVudC1zdHlsZSBjb21tYW5kLiBJdCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHBlciBzdHJlYW1pbmcgY29tbWFuZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFJlcGxhY2VTdHJlYW1pbmdDb21tYW5kczogUGx1Z2luPFxuICAgIFBsdWdpbk9wdGlvbnNbXSxcbiAgICBBc3QuUm9vdCxcbiAgICBBc3QuUm9vdFxuPiA9IGZ1bmN0aW9uIHVuaWZpZWRMYXRleFJlcGxhY2VTdHJlYW1pbmdDb21tYW5kcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXBsYWNlcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBpc1JlcGxhY2VhYmxlID0gbWF0Y2guY3JlYXRlTWFjcm9NYXRjaGVyKHJlcGxhY2Vycyk7XG4gICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgIHZpc2l0KFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIChncm91cCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgIWdyb3VwLmNvbnRlbnQuc29tZShpc1JlcGxhY2VhYmxlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGZpeGVkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBpc1JlcGxhY2VhYmxlLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudCwgY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2Vyc1tjb21tYW5kLmNvbnRlbnRdKGNvbnRlbnQsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCByZXBsYWNlIHRoZSBub2RlIHVubGVzcyB3ZSBjYW4gYWNjZXNzIHRoZSBjb250YWluaW5nIGFycmF5LlxuICAgICAgICAgICAgICAgIGlmICghaW5mby5jb250YWluaW5nQXJyYXkgfHwgaW5mby5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgZml4ZWRgIG1heSBjb25zaXN0IG9mIG9ubHkgd2hpdGVzcGFjZS4gSWYgdGhpcyBpcyB0aGUgY2FzZSxcbiAgICAgICAgICAgICAgICAvLyBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIG11c3QgdHJpbW1lZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpbmcgdGhlIGdyb3VwJ3MgY29udGVudHMuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRva2VuID0gaW5mby5jb250YWluaW5nQXJyYXlbaW5mby5pbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IGluZm8uY29udGFpbmluZ0FycmF5W2luZm8uaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2VMaWtlKHByZXZUb2tlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gud2hpdGVzcGFjZUxpa2UoZml4ZWRbMF0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaW1TdGFydChmaXhlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gud2hpdGVzcGFjZUxpa2UobmV4dFRva2VuKSAmJlxuICAgICAgICAgICAgICAgICAgICBtYXRjaC53aGl0ZXNwYWNlTGlrZShmaXhlZFtmaXhlZC5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbUVuZChmaXhlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VOb2RlRHVyaW5nVmlzaXQoZml4ZWQsIGluZm8pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdGVzdDogbWF0Y2guZ3JvdXAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZpc2l0KFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIChub2RlcywgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgIW5vZGVzLnNvbWUoaXNSZXBsYWNlYWJsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBpc1JlcGxhY2VhYmxlLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudCwgY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2Vyc1tjb21tYW5kLmNvbnRlbnRdKGNvbnRlbnQsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBiYWNrIGEgZGlmZmVyZW50IGFycmF5IHRoYW4gd2UgaW5wdXQsIHRoZSByZXBsYWNlbWVudCBkaWRcbiAgICAgICAgICAgICAgICAvLyBub3QgaGFwcGVuIGluLXBsYWNlLiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBtYW5pcHVsYXRlIGBub2Rlc2AuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VkICE9PSBub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKC4uLnJlcGxhY2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlQXJyYXlzOiB0cnVlLCB0ZXN0OiBBcnJheS5pc0FycmF5IH1cbiAgICAgICAgKTtcbiAgICB9O1xufTtcbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2Uvbm9uLWNvbW1lbnQgbm9kZSBpbiBgbm9kZXNgLiBJZiB0aGVyZSBpcyBubyBzdWNoXG4gKiBub2RlLCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFNpZ25pZmljYW50Tm9kZShub2RlczogQXN0Lk5vZGVbXSk6IEFzdC5Ob2RlIHwgbnVsbCB7XG4gICAgbGV0IGZpcnN0Tm9kZTogQXN0Lk5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHwgbWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3ROb2RlID0gbm9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0Tm9kZTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcblxuLyoqXG4gKiBJcyB0aGUgbm9kZSBzcGFjZS1saWtlPyBJLmUuLCBpcyBpdCB3aGl0ZXNwYWNlIG9yXG4gKiBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2U/XG4gKi9cbmZ1bmN0aW9uIGlzU3BhY2VMaWtlKG5vZGU6IEFzdC5Ob2RlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbWF0Y2gud2hpdGVzcGFjZShub2RlKSB8fFxuICAgICAgICAobWF0Y2guY29tbWVudChub2RlKSAmJiBCb29sZWFuKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpKVxuICAgICk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgaGVhZC5wdXNoKC4uLnRhaWwpYCBleGNlcHQgdGhhdCB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICogb2YgYHRhaWxgIGFuZCB0aGUgZW5kIG9mIGBoZWFkYCBpcyBjb2xsYXBzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luV2l0aG91dEV4Y2Vzc1doaXRlc3BhY2UoXG4gICAgaGVhZDogQXN0Lk5vZGVbXSxcbiAgICB0YWlsOiBBc3QuTm9kZVtdXG4pOiB2b2lkIHtcbiAgICBpZiAodGFpbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGVhZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaGVhZC5wdXNoKC4uLnRhaWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhlYWRFbmQgPSBoZWFkW2hlYWQubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdGFpbFN0YXJ0ID0gdGFpbFswXTtcbiAgICAvLyBXaGl0ZXNwYWNlIHdlIGNhbiBqdXN0IHRyaW0gb2ZmIGZyb20gZWl0aGVyIGVuZFxuICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKGhlYWRFbmQpICYmIG1hdGNoLndoaXRlc3BhY2UodGFpbFN0YXJ0KSkge1xuICAgICAgICBoZWFkLnB1c2goLi4udGFpbC5zbGljZSgxKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyB3aGl0ZXNwYWNlIGF0IG9uZSBvZiB0aGUgZW5kcywgbm8gbmVlZCB0byB3b3JyeVxuICAgIC8vIHVubGVzcyBgdGFpbFN0YXJ0YCBpcyBhIGNvbW1lbnQsIGluIHdoaWNoIGNhc2UgaXQgc2hvdWxkIFwiZWF0XCJcbiAgICAvLyB0aGUgd2hpdGVzcGFjZVxuICAgIGlmICghaXNTcGFjZUxpa2UoaGVhZEVuZCkgfHwgIWlzU3BhY2VMaWtlKHRhaWxTdGFydCkpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2UoaGVhZEVuZCkgJiYgbWF0Y2guY29tbWVudCh0YWlsU3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50OiBBc3QuQ29tbWVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0YWlsU3RhcnQuY29udGVudCxcbiAgICAgICAgICAgICAgICBzYW1lbGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWlsID0gdGFpbC5zbGljZSgxKTtcbiAgICAgICAgICAgIHRyaW1TdGFydCh0YWlsKTtcbiAgICAgICAgICAgIGhlYWQucG9wKCk7XG4gICAgICAgICAgICBoZWFkLnB1c2goY29tbWVudCwgLi4udGFpbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGVhZC5wdXNoKC4uLnRhaWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaGVyZSwgd2UgaGF2ZSBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gb25lIHNpZGVcbiAgICAvLyBhbmQgd2hpdGVzcGFjZS9jb21tZW50cyBvbiB0aGUgb3RoZXIuXG4gICAgaWYgKG1hdGNoLmNvbW1lbnQoaGVhZEVuZCkgJiYgbWF0Y2guY29tbWVudCh0YWlsU3RhcnQpKSB7XG4gICAgICAgIGlmICh0YWlsU3RhcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgdGFpbFN0YXJ0LnNhbWVsaW5lKSB7XG4gICAgICAgICAgICBoZWFkLnB1c2goXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBcImNvbW1lbnRcIiwgY29udGVudDogdGFpbFN0YXJ0LmNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAuLi50YWlsLnNsaWNlKDEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhlYWQucHVzaCguLi50YWlsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgb25lIHNpZGUgaXMgYSBjb21tZW50LCBzbyB3ZSBzaG91bGQgdHJpbSB0aGUgd2hpdGVzcGFjZSBhbmQga2VlcCB0aGUgY29tbWVudCxcbiAgICAvLyBidXQgbWFrZSBzdXJlIHRoZSBjb21tZW50IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UhXG4gICAgbGV0IGNvbW1lbnQgPSBtYXRjaC5jb21tZW50KGhlYWRFbmQpID8gaGVhZEVuZCA6IHRhaWxTdGFydDtcbiAgICBpZiAoIW1hdGNoLmNvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgY29tbWVudCBidXQgZm91bmQgJHtKU09OLnN0cmluZ2lmeShjb21tZW50KX1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFjb21tZW50LnNhbWVsaW5lKSB7XG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbW1lbnQuY29udGVudCxcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICAgICAgc2FtZWxpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGVhZC5wb3AoKTtcbiAgICBoZWFkLnB1c2goY29tbWVudCwgLi4udGFpbC5zbGljZSgxKSk7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbVwiO1xuaW1wb3J0IHsgam9pbldpdGhvdXRFeGNlc3NXaGl0ZXNwYWNlIH0gZnJvbSBcIi4vam9pbi13aXRob3V0LWV4Y2Vzcy13aGl0ZXNwYWNlXCI7XG5pbXBvcnQgeyB3cmFwU2lnbmlmaWNhbnRDb250ZW50IH0gZnJvbSBcIi4vd3JhcC1zaWduaWZpY2FudC1jb250ZW50XCI7XG5cbi8qKlxuICogUmVwbGFjZSBjb21tYW5kcyBpZGVudGlmaWVkIGJ5IGBpc1N0cmVhbWluZ0NvbW1hbmRgIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiBgcmVwbGFjZXJgLlxuICogRS5nLiwgdGhlIGFycmF5IGBbaGVhZCwgc3RyZWFtaW5nQ29tbWFuZCwgLi4udGFpbF1gIHdpbGwgYmVjb21lIGBbaGVhZCwgcmVwbGFjZXIodGFpbCwgc3RyZWFtaW5nQ29tbWFuZCldYC5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3BsaXQgYmFzZWQgb24gcGFyYnJlYWtzL2V0Yy4uIEl0IGlzIHJpZ2h0LWFzc29jaWF0aXZlIGFuZCByZXR1cm5zXG4gKiB0aGUgc3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgd2VyZSBlbmNvdW50ZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kSW5BcnJheShcbiAgICBub2RlczogQXN0Lk5vZGVbXSxcbiAgICBpc1N0cmVhbWluZ0NvbW1hbmQ6IChub2RlOiBhbnkpID0+IG5vZGUgaXMgQXN0Lk1hY3JvLFxuICAgIHJlcGxhY2VyOiAoXG4gICAgICAgIGNvbnRlbnQ6IEFzdC5Ob2RlW10sXG4gICAgICAgIHN0cmVhbWluZ0NvbW1hbmQ6IEFzdC5NYWNyb1xuICAgICkgPT4gQXN0Lk5vZGUgfCBBc3QuTm9kZVtdXG4pOiB7IGZvdW5kU3RyZWFtaW5nQ29tbWFuZHM6IEFzdC5Ob2RlW10gfSB7XG4gICAgLy8gU3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgY29tZSBhdCB0aGUgZW5kIGRvbid0IGRvIGFueXRoaW5nLFxuICAgIC8vIHNvIHdlIHNob3VsZCByZW1vdmUgdGhlbVxuICAgIHdoaWxlIChub2Rlcy5sZW5ndGggPiAwICYmIGlzU3RyZWFtaW5nQ29tbWFuZChub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgIHRyaW1FbmQobm9kZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvdW5kU3RyZWFtaW5nQ29tbWFuZHM6IEFzdC5Ob2RlW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc1N0cmVhbWluZ0NvbW1hbmQobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoY29udGVudDogQXN0Lk5vZGVbXSkgPT4gcmVwbGFjZXIoY29udGVudCwgbm9kZSk7XG4gICAgICAgICAgICBsZXQgdGFpbCA9IG5vZGVzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIC8vIFN0cmVhbWluZyBjb21tYW5kcyBhcmUgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgd2hpY2ggYmVjb21lcyB1bm5lZWRlZCB3aGVuIHRoZSBjb21tYW5kcyBhcmUgcmVwbGFjZWQuXG4gICAgICAgICAgICB0cmltU3RhcnQodGFpbCk7XG4gICAgICAgICAgICB0YWlsID0gd3JhcFNpZ25pZmljYW50Q29udGVudCh0YWlsLCB3cmFwcGVyKTtcbiAgICAgICAgICAgIGZvdW5kU3RyZWFtaW5nQ29tbWFuZHMucHVzaChub2RlKTtcblxuICAgICAgICAgICAgLy8gVHJpbSBvZmYgd2hhdCB3ZSdyZSBhYm91dCB0byByZXBsYWNlIVxuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGkpO1xuXG4gICAgICAgICAgICBqb2luV2l0aG91dEV4Y2Vzc1doaXRlc3BhY2Uobm9kZXMsIHRhaWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZm91bmRTdHJlYW1pbmdDb21tYW5kcyB9O1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuLyoqXG4gKiBXcmFwcyBgY29udGVudGAgaW4gdGhlIHNwZWNpZmllZCB3cmFwcGVyLiBUaGlzIGNvbW1hbmQgaXMgcm91Z2hseSBlcXVpdmFsZW50IHRvXG4gKiBgd3JhcHBlcihjb250ZW50KWAgZXhjZXB0IHRoYXQgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMgYXJlIGV4dHJhY3RlZFxuICogZnJvbSBgY29udGVudGAgYW5kIG1vdmVkIHRvIHRoZSBmcm9udCBvciBiYWNrIG9mIHRoZSByZXR1cm4gYXJyYXkuIEZvciBleGFtcGxlLFxuICogYFtcIiBcIiwgXCJmb29cIiwgXCJiYXJcIiwgXCIlIHh4eFwiXWAgLT4gYFtcIiBcIiwgd3JhcHBlZChbXCJmb29cIiwgXCJiYXJcIl0pLCBcIiUgeHh4XCJdYC5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwU2lnbmlmaWNhbnRDb250ZW50KFxuICAgIGNvbnRlbnQ6IEFzdC5Ob2RlW10sXG4gICAgd3JhcHBlcjogKGNvbnRlbnQ6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlW10gfCBBc3QuTm9kZVxuKTogQXN0Lk5vZGVbXSB7XG4gICAgbGV0IGhvaXN0VW50aWwgPSAwO1xuICAgIGxldCBob2lzdEFmdGVyID0gY29udGVudC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKGNvbnRlbnRbaV0pIHx8IG1hdGNoLmNvbW1lbnQoY29udGVudFtpXSkpIHtcbiAgICAgICAgICAgIGhvaXN0VW50aWwgPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShjb250ZW50W2pdKSB8fCBtYXRjaC5jb21tZW50KGNvbnRlbnRbal0pKSB7XG4gICAgICAgICAgICBob2lzdEFmdGVyID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChob2lzdFVudGlsID09PSAwICYmIGhvaXN0QWZ0ZXIgPT09IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh3cmFwcGVyKGNvbnRlbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcm9udE1hdHRlciA9IGNvbnRlbnQuc2xpY2UoMCwgaG9pc3RVbnRpbCk7XG4gICAgY29uc3QgbWlkZGxlID0gY29udGVudC5zbGljZShob2lzdFVudGlsLCBob2lzdEFmdGVyKTtcbiAgICBjb25zdCBiYWNrTWF0dGVyID0gY29udGVudC5zbGljZShob2lzdEFmdGVyLCBjb250ZW50Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gZnJvbnRNYXR0ZXIuY29uY2F0KHdyYXBwZXIobWlkZGxlKSwgYmFja01hdHRlcik7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KHg6IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tY29uZGl0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3Vuc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvYXJyYXktam9pblwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgYnJlYWsgYXBhcnQgb3Igam9pbiBhbiBhcnJheSBvZiBub2RlcyBiYXNlZCBvbiBhIGNvbmRpdGlvbi4gRm9yIGV4YW1wbGUsXG4gKiB0aGlzIGlzIHVzZWQgdG8gc3BsaXQgb24gYCZgIGNoYXJhY3RlcnMgaW4gdGhlIGBhbGlnbmAgZW52aXJvbm1lbnQuXG4gKi8iLCIvKipcbiAqIEpvaW5zIGFuIGFycmF5IG9mIGFycmF5cyB3aXRoIHRoZSBpdGVtIGBzZXBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUpvaW48VD4oYXJyYXk6IFRbXVtdLCBzZXA6IFQgfCBUW10pOiBUW10ge1xuICAgIHJldHVybiBhcnJheS5mbGF0TWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXApKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnNlcCwgLi4uaXRlbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NlcCwgLi4uaXRlbV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG4vKipcbiAqIFNwbGl0IGEgbGlzdCBvZiBub2RlcyBiYXNlZCBvbiB3aGV0aGVyIGBzcGxpdEZ1bmNgIHJldHVybnMgYHRydWVgLlxuICogSWYgYG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlYCBpcyBzZXQgdG8gdHJ1ZSBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgdGhlblxuICogdGhlcmUgd2lsbCBiZSBhdCBtb3N0IHR3byBzZWdtZW50cyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T25Db25kaXRpb24oXG4gICAgbm9kZXM6IEFzdC5Ob2RlW10sXG4gICAgc3BsaXRGdW5jOiAobm9kZTogQXN0Lk5vZGUpID0+IGJvb2xlYW4gPSAoKSA9PiBmYWxzZSxcbiAgICBvcHRpb25zPzogeyBvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZT86IGJvb2xlYW4gfVxuKTogeyBzZWdtZW50czogQXN0Lk5vZGVbXVtdOyBzZXBhcmF0b3JzOiBBc3QuTm9kZVtdIH0ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gb25seSBzcGxpdCBhbiBBcnJheSwgbm90ICR7bm9kZXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZSA9IGZhbHNlIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qgc3BsaXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwbGl0RnVuYyhub2Rlc1tpXSkpIHtcbiAgICAgICAgICAgIHNwbGl0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgaWYgKG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHRoZXJlIGlzIG5vIHNwbGl0dGluZyB0byBiZSBkb25lXG4gICAgaWYgKHNwbGl0SW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgc2VnbWVudHM6IFtub2Rlc10sIHNlcGFyYXRvcnM6IFtdIH07XG4gICAgfVxuXG4gICAgbGV0IHNlcGFyYXRvcnMgPSBzcGxpdEluZGljZXMubWFwKChpKSA9PiBub2Rlc1tpXSk7XG4gICAgbGV0IHNlZ21lbnRzID0gc3BsaXRJbmRpY2VzLm1hcCgoc3BsaXRFbmQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGkgPT09IDAgPyAwIDogc3BsaXRJbmRpY2VzW2kgLSAxXSArIDE7XG4gICAgICAgIHJldHVybiBub2Rlcy5zbGljZShzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgfSk7XG4gICAgc2VnbWVudHMucHVzaChcbiAgICAgICAgbm9kZXMuc2xpY2Uoc3BsaXRJbmRpY2VzW3NwbGl0SW5kaWNlcy5sZW5ndGggLSAxXSArIDEsIG5vZGVzLmxlbmd0aClcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgc2VnbWVudHMsIHNlcGFyYXRvcnMgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyBzcGxpdE9uQ29uZGl0aW9uIH0gZnJvbSBcIi4vc3BsaXQtb24tY29uZGl0aW9uXCI7XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXkgb2YgQVNUIG5vZGVzIGJhc2VkIG9uIGEgbWFjcm8uIEFuIG9iamVjdCBge3NlZ21lbnRzOiBbXSwgbWFjcm9zOiBbXX1gXG4gKiBpcyByZXR1cm5lZC4gVGhlIG9yaWdpbmFsIGFycmF5IGlzIHJlY29uc3RydWN0ZWQgYXNcbiAqIGBzZWdtZW50c1swXSArIG1hY3Jvc1swXSArIHNlZ21lbnRzWzFdICsgLi4uYC5cbiAqXG4gKiBAcGFyYW0ge1tvYmplY3RdfSBhc3RcbiAqIEBwYXJhbSB7KHN0cmluZ3xbc3RyaW5nXSl9IG1hY3JvTmFtZVxuICogQHJldHVybnMge3tzZWdtZW50czogW29iamVjdF0sIG1hY3JvczogW29iamVjdF19fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbk1hY3JvKFxuICAgIGFzdDogQXN0Lk5vZGVbXSxcbiAgICBtYWNyb05hbWU6IHN0cmluZyB8IHN0cmluZ1tdXG4pOiB7IHNlZ21lbnRzOiBBc3QuTm9kZVtdW107IG1hY3JvczogQXN0Lk1hY3JvW10gfSB7XG4gICAgaWYgKHR5cGVvZiBtYWNyb05hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWFjcm9OYW1lID0gW21hY3JvTmFtZV07XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShtYWNyb05hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgY29lcmNpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBpc1NlcGFyYXRvciA9IG1hdGNoLmNyZWF0ZU1hY3JvTWF0Y2hlcihtYWNyb05hbWUpO1xuICAgIGNvbnN0IHsgc2VnbWVudHMsIHNlcGFyYXRvcnMgfSA9IHNwbGl0T25Db25kaXRpb24oYXN0LCBpc1NlcGFyYXRvcik7XG4gICAgcmV0dXJuIHsgc2VnbWVudHMsIG1hY3Jvczogc2VwYXJhdG9ycyBhcyBBc3QuTWFjcm9bXSB9O1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbi8qKlxuICogRG9lcyB0aGUgcmV2ZXJzZSBvZiBgc3BsaXRPbk1hY3JvYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zcGxpdE9uTWFjcm8oe1xuICAgIHNlZ21lbnRzLFxuICAgIG1hY3Jvcyxcbn06IHtcbiAgICBzZWdtZW50czogQXN0Lk5vZGVbXVtdO1xuICAgIG1hY3JvczogQXN0Lk5vZGVbXSB8IEFzdC5Ob2RlW11bXTtcbn0pIHtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRyeWluZyB0byBqb2luIHplcm8gc2VnbWVudHNcIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAhPT0gbWFjcm9zLmxlbmd0aCArIDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJNaXNtYXRjaCBiZXR3ZWVuIGxlbmd0aHMgb2YgbWFjcm9zIGFuZCBzZWdtZW50cyB3aGVuIHRyeWluZyB0byB1bnNwbGl0XCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0ID0gc2VnbWVudHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYWNyb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIHR5cGUgb2YgbWFjcm9zW2ldIGlzIG5vZGUgYW5kIG5vdCBhcnJheSxcbiAgICAgICAgLy8gQXJyYXkuY29uY2F0IHN0aWxsIHdvcmtzXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQobWFjcm9zW2ldKS5jb25jYXQoc2VnbWVudHNbaSArIDFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy90cmltXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3VuaWZpZWQtbGF0ZXgtdHJpbS1lbnZpcm9ubWVudC1jb250ZW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tcm9vdFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy9oYXMtd2hpdGVzcGFjZS1lcXVpdmFsZW50XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gaGVscCBtb2RpZnkgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmRzIG9mIGFuIGFycmF5IG9mIG5vZGVzLlxuICpcbiAqIE5vdGUgdGhhdCB3aGl0ZXNwYWNlIGNhbiBjb21lIGZyb20gYSBgQXN0LldoaXRlc3BhY2VgIG5vZGUgb3IgZnJvbSBhblxuICogYEFzdC5Db21tZW50YCBub2RlIHRoYXQgaGFzIGxlYWRpbmcgd2hpdGVzcGFjZS4gVGhlc2UgZnVuY3Rpb25zIHRha2UgY2FyZVxuICogdG8gZGVhbCB3aXRoIGJvdGggc2l0dWF0aW9ucy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFycmF5IGhhcyB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydC9lbmQuIENvbW1lbnRzIHdpdGggYGxlYWRpbmdXaGl0ZXNwYWNlID09PSB0cnVlYFxuICogYXJlIGNvdW50ZWQgYXMgd2hpdGVzcGFjZS4gT3RoZXIgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNXaGl0ZXNwYWNlRXF1aXZhbGVudChub2RlczogQXN0Lk5vZGVbXSk6IHtcbiAgICBzdGFydDogYm9vbGVhbjtcbiAgICBlbmQ6IGJvb2xlYW47XG59IHtcbiAgICBsZXQgc3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChtYXRjaC5jb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2Ugd2lsbCByZW5kZXIgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UsXG4gICAgICAgICAgICAvLyBzbyBpZiB3ZSBlbmNvdW50ZXIgb25lLCB3ZSBzaG91bGQgY29uc2lkZXIgb3Vyc2VsdmVzIHRvIGhhdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShub2RlKSkge1xuICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gbm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICBpZiAobWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogVHJpbXMgd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmRcbiAqIG9mIGFuIGFycmF5LiBUaGUgbnVtYmVyIG9mIHRyaW1tZWQgbm9kZXMgaXMgcmV0dXJuZWQuXG4gKiBTcGVjaWFsIGNhcmUgaXMgdGFrZW4gdG8gcHJlc2VydmUgY29tbWVudHMsIHRob3VnaCBhbnkgd2hpdGVzcGFjZVxuICogYmVmb3JlIHRoZSBmaXJzdCBjb21tZW50KHMpIG9yIGFmdGVyIHRoZSBsYXN0IGNvbW1lbnQocykgaXMgdHJpbW1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0obm9kZXM6IEFzdC5Ob2RlW10pOiB7XG4gICAgdHJpbW1lZFN0YXJ0OiBudW1iZXI7XG4gICAgdHJpbW1lZEVuZDogbnVtYmVyO1xufSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gdHJpbSBhIG5vbi1hcnJheSBhc3RcIiwgbm9kZXMpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2Rlcyk7XG4gICAgY29uc3QgeyB0cmltbWVkRW5kIH0gPSB0cmltRW5kKG5vZGVzKTtcblxuICAgIHJldHVybiB7IHRyaW1tZWRTdGFydCwgdHJpbW1lZEVuZCB9O1xufVxuXG4vKipcbiAqIFRyaW0gd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIGxlZnQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnQobm9kZXM6IEFzdC5Ob2RlW10pOiB7IHRyaW1tZWRTdGFydDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgc3RhcnQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2UoMCwgc3RhcnQpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNvbW1lbnRzIGF0IHRoZSBzdGFydCwgdGhleSBtaWdodCBoYXZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAvLyBUaGlzIGxlYWRpbmcgd2hpdGVzcGFjZSBzaG91bGQgYmUgdHJpbW1lZFxuICAgIGZvciAoY29uc3QgbGVhZGluZ1Rva2VuIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmICghbWF0Y2guY29tbWVudChsZWFkaW5nVG9rZW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlIHx8IGxlYWRpbmdUb2tlbi5zYW1lbGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhpcyB0b2tlbiB0byBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGVkaXRlZCBpdFxuICAgICAgICAgICAgZGVsZXRlIGxlYWRpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIGNhcmUgbXVzdCBiZSB0YWtlbi4gSWYgdGhlIGNvbW1lbnQgd2FzIG9uIHRoZSBzYW1lIGxpbmUgYXMgYVxuICAgICAgICAvLyBwYXJza2lwLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBvbiB0aGUgc2FtZSBsaW5lIGFmdGVyIHRoZSB0cmltbWluZy5cbiAgICAgICAgLy8gVGh1cywgd2UgbXVzdCBtb2RpZnkgdGhlIGNvbW1lbnQuXG4gICAgICAgIGlmIChzdGFydCA+IDAgJiYgbGVhZGluZ1Rva2VuLnNhbWVsaW5lKSB7XG4gICAgICAgICAgICBsZWFkaW5nVG9rZW4uc2FtZWxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFkaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmltbWVkU3RhcnQ6IHN0YXJ0IH07XG59XG5cbi8qKlxuICogVHJpbSB3aGl0ZXNwYWNlIGFuZCBwYXJicmVha3MgZnJvbSB0aGUgcmlnaHQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltRW5kKG5vZGVzOiBBc3QuTm9kZVtdKTogeyB0cmltbWVkRW5kOiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBlbmQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2Uobm9kZXMubGVuZ3RoIC0gZW5kLCBlbmQpO1xuXG4gICAgLy8gVHJpbSBvZmYgYW55IHNwYWNlcyBiZWxvbmdpbmcgdG8gdHJhaWxpbmcgY29tbWVudHNcbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdUb2tlbiA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQodHJhaWxpbmdUb2tlbikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IHRyaW0gc3BhY2VzIGJlZm9yZSB0cmFpbGluZyBzYW1lLWxpbmUgY29tbWVudHMuIFRoaXMgaXMgYSBzdHlsaXN0aWMgY2hvaWNlXG4gICAgICAgIC8vIHNvIHRoYXRcbiAgICAgICAgLy8gYGZvbyAleHh4YCBkb2VzIG5vdCBiZWNvbWUgYGZvbyV4eHhgLlxuICAgICAgICAvLyBUaGUgbGF0dGVyIGlzIHN0cmljdGx5IFwiY29ycmVjdFwiIGZvciBhIHRyaW0gZnVuY3Rpb24sIGJ1dCBpdCBpcyBwcmV0dGllciB0byBmb3JtYXRcbiAgICAgICAgLy8gY29kZSBwcmVzZXJ2aW5nIHRoZSBzcGFjZSBiZWZvcmUgdGhlIHNhbWVsaW5lIGNvbW1lbnRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbWF0Y2guY29tbWVudCh0cmFpbGluZ1Rva2VuKSAmJlxuICAgICAgICAgICAgdHJhaWxpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSAmJlxuICAgICAgICAgICAgIXRyYWlsaW5nVG9rZW4uc2FtZWxpbmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmFpbGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdHJhaWxpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRyaW1tZWRFbmQ6IGVuZCB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3aGl0ZXNwYWNlL3BhcmJyZWFrIG5vZGVzIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2UoYXN0OiBBc3QuTm9kZVtdKToge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59IHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhc3QpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHwgbWF0Y2gucGFyYnJlYWsobm9kZSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gYXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kOiAwIH07XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgcGFkZGluZyBvbiB0aGUgcmlnaHRcbiAgICBmb3IgKGxldCBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhc3RbaV07XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLnBhcmJyZWFrKG5vZGUpKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuIiwiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcInVuaWZpZWRcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcbmltcG9ydCB7IHRyaW0sIHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuL3RyaW1cIjtcblxudHlwZSBQbHVnaW5PcHRpb25zID0gdm9pZDtcblxuLyoqXG4gKiBVbmlmaWVkIHBsdWdpbiB0byB0cmltIHRoZSB3aGl0ZXNwYWNlIGZyb20gdGhlIHN0YXJ0L2VuZCBvZiBhbnkgZW52aXJvbm1lbnRzLCBpbmNsdWRpbmdcbiAqIG1hdGggZW52aXJvbm1lbnRzLlxuICovXG5leHBvcnQgY29uc3QgdW5pZmllZExhdGV4VHJpbUVudmlyb25tZW50Q29udGVudHM6IFBsdWdpbjxcbiAgICBQbHVnaW5PcHRpb25zW10sXG4gICAgQXN0LlJvb3QsXG4gICAgQXN0LlJvb3Rcbj4gPSBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltRW52aXJvbm1lbnRDb250ZW50cygpIHtcbiAgICByZXR1cm4gKHRyZWUpID0+IHtcbiAgICAgICAgdmlzaXQodHJlZSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKG1hdGNoLm1hdGgobm9kZSkgfHwgbWF0Y2guYW55RW52aXJvbm1lbnQobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgdGhpbmcgaW4gdGhlIGVudmlyb25tZW50IGlzIGEgc2FtZWxpbmUgY29tbWVudCxcbiAgICAgICAgICAgIC8vIHdlIGFjdHVhbGx5IHdhbnQgdG8gc3RhcnQgdHJpbW1pbmcgKmFmdGVyKiBpdC5cbiAgICAgICAgICAgIGxldCBmaXJzdE5vZGUgPSBub2RlLmNvbnRlbnRbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2guY29tbWVudChmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zdWZmaXhQYXJicmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyaW1FbmQobm9kZS5jb250ZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHBsYXkgYSBuYXN0eSB0cmljayBoZXJlLiBUaGlzIGNhbGwgdG8gYHRyaW1TdGFydGBcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGFjdHVhbGx5IG1vZGlmeSBgbm9kZS5jb250ZW50YCBpZiBgbm9kZS5jb250ZW50LnNsaWNlKDEpYCBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGEgY29tbWVudCB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UgKGl0IHdpbGwgcmVtb3ZlIHRoYXQgd2hpdGVzcGFjZSkuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaXQgd29uJ3QgcmVtb3ZlIGFueSBlbGVtZW50cyBmcm9tIGBub2RlLmNvbnRlbnRgOyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gZG8gdGhhdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2RlLmNvbnRlbnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudC5zcGxpY2UoMSwgdHJpbW1lZFN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpbShub2RlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHRyaW0gfSBmcm9tIFwiLi90cmltXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHZvaWQ7XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydC9lbmQgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFRyaW1Sb290OiBQbHVnaW48UGx1Z2luT3B0aW9uc1tdLCBBc3QuUm9vdCwgQXN0LlJvb3Q+ID1cbiAgICBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgICAgICB0cmltKHRyZWUuY29udGVudCk7XG4gICAgICAgIH07XG4gICAgfTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdmlzaXRcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byB0cmF2ZXJzZSBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS4gYHZpc2l0YCBpc1xuICogdmVyeSBzaW1pbGFyIHRvIFtlc3RyZWUtdXRpbC12aXNpdF0oaHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2VzdHJlZS11dGlsLXZpc2l0KS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJlcGxhY2UgcGFydGljdWxhciBBU1Qgbm9kZXMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogTGlzdCBhbGwgcHJvcHMgb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IHNob3VsZCBiZSBwcm9jZXNzZWRcbiAqIGluIG1hdGggbW9kZSBvciBub3QgaW4gbWF0aCBtb2RlLiBJZiBtYXRoIG1vZGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbm9kZSdzIHJlbmRlclxuICogaW5mbywgZW1wdHkgbGlzdHMgYXJlIHJldHVybmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGBcXHRleHR7Zm9vfWAgd2lsbCByZXBvcnQgdGhhdCBgYXJnc2Agc2hvdWxkICpub3QqIGJlIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUsXG4gKiBzaW5jZSBpdCdzIGNvbnRlbnRzIHNob3VsZCBhbHdheXMgYmUgcHJvY2Vzc2VkIGluIHRleHQgbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNYXRoQ2hpbGRyZW4obm9kZTogQXN0LkFzdCk6IHtcbiAgICBlbnRlcjogc3RyaW5nW107XG4gICAgbGVhdmU6IHN0cmluZ1tdO1xufSB7XG4gICAgY29uc3QgTlVMTF9SRVRVUk4gPSB7IGVudGVyOiBbXSwgbGVhdmU6IFtdIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWF0aChub2RlKSkge1xuICAgICAgICAvLyBXaGVuIHdlIGVudGVyIGEgbWF0aCBlbnZpcm9ubWVudCwgb3VyIGNvbnRlbnQgaXMgYWx3YXlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgbWF0aCBtb2RlXG4gICAgICAgIHJldHVybiB7IGVudGVyOiBbXCJjb250ZW50XCJdLCBsZWF2ZTogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJJbmZvOiB7IGluTWF0aE1vZGU/OiBib29sZWFuIH0gPSBub2RlLl9yZW5kZXJJbmZvIHx8IHt9O1xuICAgIGlmIChyZW5kZXJJbmZvLmluTWF0aE1vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTlVMTF9SRVRVUk47XG4gICAgfVxuICAgIGlmIChtYXRjaC5tYWNybyhub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiYXJnc1wiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiYXJnc1wiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaC5lbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW10sIGxlYXZlOiBbXCJjb250ZW50XCJdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfUkVUVVJOO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBsaXN0TWF0aENoaWxkcmVuIH0gZnJvbSBcIi4vbGlzdC1tYXRoLWNoaWxkcmVuXCI7XG5cbmV4cG9ydCB0eXBlIFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBub2RlIGlzIGEgZGlyZWN0b3Igb3IgaW5kaXJlY3QgY2hpbGRcbiAgICAgKiBvZiBhIG1hdGggZW52aXJvbm1lbnQgKGUuZy4gYCRhYmMkYCksIGJ1dCBub3Qgd2hlbiBhbiBlbnZpcm9ubWVudFxuICAgICAqIHJlLWVzdGFibGlzaGVzIHRleHQgbW9kZSAoZS5nLiBgJFxcdGV4dHthYmN9JGApXG4gICAgICovXG4gICAgaW5NYXRoTW9kZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbm9kZSBoYXMgYW55IGFuY2VzdG9yIHRoYXQgaXMgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKi9cbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgR2V0R3VhcmQ8VD4gPSBUIGV4dGVuZHMgKHg6IGFueSkgPT4geCBpcyBpbmZlciBSID8gUiA6IG5ldmVyO1xuLyoqXG4gKiBHZXRzIHRoZSB0eXBlIHRoYXQgYSB0eXBlLWd1YXJkIGZ1bmN0aW9uIGlzIGd1YXJkaW5nLiBJZlxuICogdGhlIGd1YXJkIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQsIHRoZSBpbnB1dCB0eXBlIGlzIHJldHVybmVkLlxuICovXG50eXBlIEd1YXJkVHlwZU9mPFQgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuPiA9IEdldEd1YXJkPFQ+IGV4dGVuZHMgbmV2ZXJcbiAgICA/IFQgZXh0ZW5kcyAoeDogaW5mZXIgQSkgPT4gYW55XG4gICAgICAgID8gQVxuICAgICAgICA6IG5ldmVyXG4gICAgOiBHZXRHdWFyZDxUPjtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZ3VhcmQgdHlwZSBmcm9tIHRoZSBgdGVzdGAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYVxuICogYFZpc2l0T3B0aW9uc2AgYXJndW1lbnQuXG4gKi9cbnR5cGUgR3VhcmRGcm9tT3B0aW9uczxcbiAgICBPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zLFxuICAgIFBvc3NpYmxlVHlwZXMgPSBBc3QuQXN0XG4+ID0gT3B0cyBleHRlbmRzIHtcbiAgICB0ZXN0OiBpbmZlciBSO1xufVxuICAgID8gUiBleHRlbmRzICh4OiBhbnkpID0+IGJvb2xlYW5cbiAgICAgICAgPyAvLyBBIGd1YXJkIGxpa2UgYHR5cGVvZiBBcnJheS5pc0FycmF5YCB3aWxsIHJldHVybiBgYW55W11gIGFzIHRoZSB0eXBlLlxuICAgICAgICAgIC8vIFRoaXMgdHlwZSBjYW5ub3QgYmUgbmFycm93ZWQsIHNvIGluc3RlYWQgd2UgdXNlIGl0IHRvIHBpY2sgZnJvbVxuICAgICAgICAgIC8vIHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHR5cGVzLlxuICAgICAgICAgIEV4dHJhY3Q8UG9zc2libGVUeXBlcywgR3VhcmRUeXBlT2Y8Uj4+XG4gICAgICAgIDogUG9zc2libGVUeXBlc1xuICAgIDogUG9zc2libGVUeXBlcztcblxuLyoqXG4gKiBOYXJyb3cgdGhlIHR5cGUgYFRgIGJhc2VkIG9uIHRoZSBgVmlzaXRPcHRpb25zYCBzdXBwbGllZC4gSWYgYHtpbmNsdWRlQXJyYXlzOiBmYWxzZX1gXG4gKiBpcyBzcGVjaWZpZWQgaW4gdGhlIGBWaXNpdE9wdGlvbnNgLCB0aGVuIGFycmF5cyBhcmUgZXhjbHVkZWQgZnJvbSBgVGAuXG4gKi9cbnR5cGUgTmFycm93QXJyYXlzQmFzZWRPbk9wdGlvbnM8VCwgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPSBPcHRzIGV4dGVuZHMge1xuICAgIGluY2x1ZGVBcnJheXM6IGluZmVyIEE7XG59XG4gICAgPyBBIGV4dGVuZHMgdHJ1ZVxuICAgICAgICA/IFRcbiAgICAgICAgOiBFeGNsdWRlPFQsIGFueVtdPlxuICAgIDogRXhjbHVkZTxULCBhbnlbXT47XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gdGhlIGBWaXNpdG9yYCBmdW5jdGlvbiBiYXNlZCBvbiB0aGVcbiAqIGBWaXNpdE9wdGlvbnNgIHRoYXQgYXJlIHN1cHBsaWVkLlxuICovXG50eXBlIFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPVxuICAgIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPEd1YXJkRnJvbU9wdGlvbnM8T3B0cz4sIE9wdHM+O1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFN5bWJvbChcImNvbnRpbnVlXCIpO1xuLyoqXG4gKiBEbyBub3QgdHJhdmVyc2UgdGhpcyBub2Rl4oCZcyBjaGlsZHJlblxuICovXG5leHBvcnQgY29uc3QgU0tJUCA9IFN5bWJvbChcInNraXBcIik7XG4vKipcbiAqIFN0b3AgdHJhdmVyc2luZyBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IFN5bWJvbChcImV4aXRcIik7XG5cbnR5cGUgQWN0aW9uID0gdHlwZW9mIENPTlRJTlVFIHwgdHlwZW9mIFNLSVAgfCB0eXBlb2YgRVhJVDtcbnR5cGUgSW5kZXggPSBudW1iZXI7XG50eXBlIEFjdGlvblR1cGxlID0gW0FjdGlvbl0gfCBbdHlwZW9mIFNLSVAsIEluZGV4XSB8IFt0eXBlb2YgQ09OVElOVUUsIEluZGV4XTtcblxuLyoqXG4gKiBBIHZpc2l0b3IgdGFrZXMgYSBgbm9kZWAsIGBrZXlgLCBgaW5kZXhgLCBhbmQgLi4uXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmVudCB0aGF0IHdlIHdlcmUgYWNjZXNzZWQgdGhyb3VnaC5cbiAqL1xudHlwZSBWaXNpdG9yPFQ+ID0gKFxuICAgIG5vZGU6IFQsXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pID0+IG51bGwgfCB1bmRlZmluZWQgfCBBY3Rpb24gfCBJbmRleCB8IEFjdGlvblR1cGxlIHwgdm9pZDtcbnR5cGUgVmlzaXRvcnM8VD4gPSB7IGVudGVyPzogVmlzaXRvcjxUPjsgbGVhdmU/OiBWaXNpdG9yPFQ+IH07XG5cbnR5cGUgVmlzaXRPcHRpb25zID0ge1xuICAgIHN0YXJ0aW5nQ29udGV4dD86IFZpc2l0b3JDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHR5cGVzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHRlc3Q/OiAobm9kZTogQXN0LkFzdCwgaW5mbzogVmlzaXRJbmZvKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXJyYXlzIHdpbGwgYmUgc2VudCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLiBJZiBmYWxzeSxcbiAgICAgKiBvbmx5IG5vZGVzIHdpbGwgYmUgcGFzdCB0byBgdmlzaXRvcmAuXG4gICAgICovXG4gICAgaW5jbHVkZUFycmF5cz86IGJvb2xlYW47XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFQ6IFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIGluTWF0aE1vZGU6IGZhbHNlLFxuICAgIGhhc01hdGhNb2RlQW5jZXN0b3I6IGZhbHNlLFxufTtcblxuZXhwb3J0IHR5cGUgVmlzaXRJbmZvID0ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCB2aWEgYW4gYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlIGtleSBpcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgaW5kZXggaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFuY2VzdG9yIG5vZGVzLCBgW3BhcmVudCwgZ3JhbmRwYXJlbnQsIGdyZWF0LWdyYW5kcGFyZW50LCAuLi5dYFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBhcmVudHM6IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgaW4gYW4gYXJyYXksIHRoZSBhcnJheSB0aGF0IGl0IGlzIHBhcnQgb2YuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGFpbmluZ0FycmF5OiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIExhVGVYIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogVmlzaXRvckNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFZpc2l0IGNoaWxkcmVuIG9mIHRyZWUgd2hpY2ggcGFzcyBhIHRlc3RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWUgQWJzdHJhY3Qgc3ludGF4IHRyZWUgdG8gd2Fsa1xuICogQHBhcmFtIHtWaXNpdG9yfFZpc2l0b3JzfSBbdmlzaXRvcl0gRnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0PE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+KFxuICAgIHRyZWU6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjpcbiAgICAgICAgfCBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+XG4gICAgICAgIHwgVmlzaXRvcnM8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4sXG4gICAgb3B0aW9ucz86IE9wdHNcbikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRpbmdDb250ZXh0ID0gREVGQVVMVF9DT05URVhULFxuICAgICAgICB0ZXN0ID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUFycmF5cyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCBlbnRlcjogVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PiB8IHVuZGVmaW5lZDtcbiAgICBsZXQgbGVhdmU6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3I7XG4gICAgfSBlbHNlIGlmICh2aXNpdG9yICYmIHR5cGVvZiB2aXNpdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVudGVyID0gdmlzaXRvci5lbnRlcjtcbiAgICAgICAgbGVhdmUgPSB2aXNpdG9yLmxlYXZlO1xuICAgIH1cblxuICAgIHdhbGsodHJlZSwge1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyZW50czogW10sXG4gICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB7IC4uLnN0YXJ0aW5nQ29udGV4dCB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IHBhcmVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YWxrKFxuICAgICAgICBub2RlOiBBc3QuQXN0LFxuICAgICAgICB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9OiBWaXNpdEluZm9cbiAgICApOiBBY3Rpb25UdXBsZSB7XG4gICAgICAgIGNvbnN0IG5vZGVQYXNzZXNUZXN0ID0gaW5jbHVkZUFycmF5c1xuICAgICAgICAgICAgPyB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pXG4gICAgICAgICAgICA6ICFBcnJheS5pc0FycmF5KG5vZGUpICYmXG4gICAgICAgICAgICAgIHRlc3Qobm9kZSwgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBY3Rpb25UdXBsZSA9XG4gICAgICAgICAgICBlbnRlciAmJiBub2RlUGFzc2VzVGVzdFxuICAgICAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgICAgZW50ZXIobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBbQ09OVElOVUVdO1xuXG4gICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBTS0lQKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGxlYXZlKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgdmFsdWVgIGFycmF5IG1pZ2h0IGJlIG1vZGlmaWVkIGluIHBsYWNlIGFzIHdlIHRyYXZlcnNlIGl0LCBzb1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgdHJhZGl0aW9uYWwgZm9yIGxvb3AuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ID4gLTEgJiYgaW5kZXggPCBub2RlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5OiBub2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvciBsb29wIHdpbGwgaW5jcmVtZW50IGkgZXZlcnkgcGFzcy4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5kZXggd2FzIHJldHVybmVkLCB0aGF0J3Mgd2hlcmUgd2Ugd2FudCB0byBzdGFydCBuZXh0IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0WzFdIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIHRoZSBgY29udGVudGBcbiAgICAgICAgICAgIC8vIG9mIGFsbCB0eXBlcyAoZS5nLiwgY29tbWVudHMgYW5kIG1hY3JvcyksIHNvIHNwZWNpZnlcbiAgICAgICAgICAgIC8vIGEgYmxhY2tsaXN0LlxuICAgICAgICAgICAgbGV0IGNoaWxkUHJvcHM6IChcImNvbnRlbnRcIiB8IFwiYXJnc1wiKVtdID0gW1wiY29udGVudFwiLCBcImFyZ3NcIl07XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gW1wiYXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWF0aE1vZGVQcm9wcyA9IGxpc3RNYXRoQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleSBhcyBrZXlvZiB0eXBlb2Ygbm9kZV0gYXNcbiAgICAgICAgICAgICAgICAgICAgfCBBc3QuQXN0XG4gICAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYW5kcGFyZW50cyA9IFtub2RlXS5jb25jYXQocGFyZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgc3dpdGNoIGluL291dCBvZiBtYXRoIG1vZGUgYXMgd2UgcGFzcyB0byBub2RlW2tleV1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0geyAuLi5jb250ZXh0IH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhNb2RlUHJvcHMuZW50ZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0aE1vZGVQcm9wcy5sZWF2ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuaW5NYXRoTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbGsodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBncmFuZHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG5ld0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYSByZXN1bHQgaXMgYW4gYEFjdGlvblR1cGxlYHNcbiAqL1xuZnVuY3Rpb24gdG9SZXN1bHQoXG4gICAgdmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZVxuKTogQWN0aW9uVHVwbGUge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbQ09OVElOVUVdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt2YWx1ZV07XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvcmVwbGFjZS1ub2RlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3VuaWZpZWQtbGF0ZXgtc3RyZWFtaW5nLWNvbW1hbmRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvcmVwbGFjZS1zdHJlYW1pbmctY29tbWFuZFwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgbW9kaWZ5IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcmVjdXJzaXZlbHkgcmVwbGFjZSBwYXJ0aWN1bGFyIEFTVCBub2Rlcy5cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9