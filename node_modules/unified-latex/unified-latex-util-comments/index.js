/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-lint/utils/replace-node.ts":
/*!**************************************************!*\
  !*** ./unified-latex-lint/utils/replace-node.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNodeDuringVisit": () => (/* binding */ replaceNodeDuringVisit)
/* harmony export */ });
/**
 * Replaces the current node with `replacement`. It is assumed that the current
 * node is in an array that is a child of a parent element. If this is not the case,
 * the function will error.
 */
function replaceNodeDuringVisit(replacement, info) {
    const parent = info.parents[0];
    if (!parent) {
        throw new Error(`Cannot replace node: parent not found`);
    }
    const container = parent[info.key];
    if (!Array.isArray(container)) {
        throw new Error(`Cannot replace node: containing array not found`);
    }
    if (info.index == null) {
        throw new Error(`Cannot replace node: node index undefined`);
    }
    if (!Array.isArray(replacement)) {
        container[info.index] = replacement;
    }
    else {
        container.splice(info.index, 1, ...replacement);
    }
}


/***/ }),

/***/ "./unified-latex-util-comments/libs/delete-comments.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-comments/libs/delete-comments.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteComments": () => (/* binding */ deleteComments)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-replace */ "./unified-latex-util-replace/index.ts");


/**
 * Returns a new AST with all comments removed. Care is taken to preserve whitespace.
 * For example
 * ```
 * x%
 * y
 * ```
 * becomes `xy` but
 * ```
 * x %
 * y
 * ```
 * becomes `x y`
 */
function deleteComments(ast) {
    return (0,_unified_latex_util_replace__WEBPACK_IMPORTED_MODULE_1__.replaceNode)(ast, (node) => {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            return;
        }
        if (node.leadingWhitespace) {
            return { type: "whitespace" };
        }
        return null;
    });
}


/***/ }),

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-replace/index.ts":
/*!*********************************************!*\
  !*** ./unified-latex-util-replace/index.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* reexport safe */ _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNode),
/* harmony export */   "replaceStreamingCommand": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommandInGroup),
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* reexport safe */ _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/replace-node */ "./unified-latex-util-replace/libs/replace-node.ts");
/* harmony import */ var _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-streaming-command */ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts");
/* harmony import */ var _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");



// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-node.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-node.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* binding */ replaceNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");

/**
 * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If
 * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.
 * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.
 */
function replaceNode(ast, visitor) {
    (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, (node, info) => {
        let replacement = visitor(node, info.context);
        // Returning `undefined` or the same node means we shouldn't replace that node
        if (typeof replacement === "undefined" || replacement === node) {
            return;
        }
        if (!info.containingArray || info.index == null) {
            throw new Error("Trying to delete node, but cannot find containing array");
        }
        if (replacement === null ||
            (Array.isArray(replacement) && replacement.length === 0)) {
            // A null return means that we delete the current node
            info.containingArray.splice(info.index, 1);
            return info.index;
        }
        if (!Array.isArray(replacement)) {
            replacement = [replacement];
        }
        info.containingArray.splice(info.index, 1, ...replacement);
        // We don't want to *reprocess* the nodes we just inserted into the array,
        // lest we get stuck in a recursive loop if the replacement contains the original.
        // Thus we jump to the index after our replacements.
        return info.index + replacement.length;
    });
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-streaming-command.ts":
/*!**********************************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-streaming-command.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommand": () => (/* binding */ replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* binding */ replaceStreamingCommandInGroup)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-split */ "./unified-latex-util-split/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/first-significant-node */ "./unified-latex-util-replace/libs/utils/first-significant-node.ts");
/* harmony import */ var _utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/replace-streaming-command-in-array */ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts");
/* harmony import */ var _utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");






/**
 * Process streaming commands in a group. If needed, "escape" the group.
 * For example, `{\bfseries xx}` -> `\textbf{xx}`, but `{foo \bfseries xx}` -> `{foo \textbf{xx}}`.
 */
function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer) {
    const content = group.content;
    // If the group started with a streaming command, we want to pop
    // out of the group. E.g. `{\bfseries foo}` -> `\textbf{foo}` and not `{\textbf{foo}}`
    let popFromGroup = isStreamingCommand((0,_utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__.firstSignificantNode)(content));
    let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer);
    // If the group consisted of just streaming commands (for some reason...)
    // it should be eliminated
    if (innerProcessed.length === 0) {
        return [];
    }
    if (popFromGroup) {
        return innerProcessed;
    }
    else {
        return [{ type: "group", content: innerProcessed }];
    }
}
/**
 * Given a group or a node array, look for streaming commands (e.g., `\bfseries`) and replace them
 * with the specified macro. The "arguments" of the streaming command are passed to `replacer` and the return
 * value of `replacer` is inserted into the stream.
 *
 * By default, this command will split at parbreaks (since commands like `\textbf{...} do not accept parbreaks in their
 * contents) and call `replacer` multiple times, once per paragraph.
 */
function replaceStreamingCommand(ast, isStreamingCommand, replacer) {
    if (typeof isStreamingCommand !== "function") {
        throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);
    }
    let processedContent = [];
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.group(ast)) {
        processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);
    }
    if (Array.isArray(ast)) {
        // Streaming commands that come at the end of a sequence of nodes don't do anything.
        // They also will consume whitespace, so we should remove them and the whitespace.
        const nodes = ast;
        let scanIndex = nodes.length;
        let sliceIndex = scanIndex;
        while (scanIndex > 0 &&
            (isStreamingCommand(nodes[scanIndex - 1]) ||
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(nodes[scanIndex - 1]))) {
            scanIndex--;
            if (isStreamingCommand(nodes[scanIndex])) {
                sliceIndex = scanIndex;
            }
        }
        if (sliceIndex !== nodes.length) {
            nodes.splice(sliceIndex);
        }
        const isPar = (node) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node, "par");
        // We split on both a parbreak and a literal `\par`. But we will
        // normalize everything to be parbreaks
        const splitByPar = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(nodes, isPar);
        splitByPar.separators = splitByPar.separators.map((sep) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(sep) ? sep : { type: "parbreak" });
        const replacers = [];
        let segments = splitByPar.segments.map((segment) => {
            function applyAccumulatedReplacers(nodes) {
                if (replacers.length === 0) {
                    return nodes;
                }
                return (0,_utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__.wrapSignificantContent)(nodes, composeReplacers(replacers));
            }
            const { foundStreamingCommands } = (0,_utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommandInArray)(segment, isStreamingCommand, replacer);
            // All streaming commands in `segment` have now been replaced. However,
            // there might be commands from the previous paragraphs that should wrap
            // the current segment!
            const ret = applyAccumulatedReplacers(segment);
            // Any streaming commands from this segment will carry over to the next,
            // so keep track of them.
            foundStreamingCommands.forEach((macro) => {
                replacers.push((nodes) => {
                    const ret = replacer(nodes, macro);
                    if (!Array.isArray(ret)) {
                        return [ret];
                    }
                    return ret;
                });
            });
            return ret;
        });
        // Leading/trailing whitespace was hoisted in front/back of each replacer.
        // Since we're separated by parbreaks, we can safely trim all that whitespace.
        if (segments.length > 1) {
            segments.forEach((segment, i) => {
                if (i === 0) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(segment);
                }
                else if (i === segments.length - 1) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(segment);
                }
                else {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(segment);
                }
            });
        }
        processedContent = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.unsplitOnMacro)({
            segments: segments,
            macros: splitByPar.separators,
        });
    }
    return processedContent;
}
/**
 * Given a sequence of replacer functions `[f, g, h]` return
 * `h \circ g \circ f`
 *
 * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers
 * @returns {(nodes: Ast.Node[]) => Ast.Node}
 */
function composeReplacers(replacers) {
    if (replacers.length === 0) {
        throw new Error("Cannot compose zero replacement functions");
    }
    return (nodes) => {
        let ret = nodes;
        for (let i = 0; i < replacers.length; i++) {
            const func = replacers[i];
            ret = func(ret);
        }
        return ret;
    };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts":
/*!****************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/unified-latex-streaming-command.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* binding */ unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-lint/utils/replace-node */ "./unified-latex-lint/utils/replace-node.ts");
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");





/**
 * Unified plugin to replace all found streaming commands with their argument-style equivalents.
 * This only applies to sections of the tree with no math ancestor.
 *
 * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.
 */
const unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands(options) {
    const { replacers = {} } = options || {};
    const isReplaceable = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.createMacroMatcher(replacers);
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (group, info) => {
            if (info.context.hasMathModeAncestor ||
                !group.content.some(isReplaceable)) {
                return;
            }
            let fixed = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(group, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // We cannot replace the node unless we can access the containing array.
            if (!info.containingArray || info.index == null) {
                return;
            }
            // `fixed` may consist of only whitespace. If this is the case,
            // surrounding whitespace must trimmed before
            // inserting the group's contents.
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(prevToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[0])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(fixed);
            }
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(nextToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[fixed.length - 1])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(fixed);
            }
            (0,_unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNodeDuringVisit)(fixed, info);
        }, { test: _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.group });
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (nodes, info) => {
            if (info.context.hasMathModeAncestor ||
                !nodes.some(isReplaceable)) {
                return;
            }
            const replaced = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(nodes, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // If we get back a different array than we input, the replacement did
            // not happen in-place. In this case we need to manipulate `nodes`.
            if (replaced !== nodes) {
                nodes.length = 0;
                nodes.push(...replaced);
            }
        }, { includeArrays: true, test: Array.isArray });
    };
};


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/first-significant-node.ts":
/*!*************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/first-significant-node.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "firstSignificantNode": () => (/* binding */ firstSignificantNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such
 * node, `null` is returned.
 */
function firstSignificantNode(nodes) {
    let firstNode = null;
    for (const node of nodes) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            continue;
        }
        firstNode = node;
        break;
    }
    return firstNode;
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "joinWithoutExcessWhitespace": () => (/* binding */ joinWithoutExcessWhitespace)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");


/**
 * Is the node space-like? I.e., is it whitespace or
 * a comment with leading whitespace?
 */
function isSpaceLike(node) {
    return (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) ||
        (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node) && Boolean(node.leadingWhitespace)));
}
/**
 * Similar to `head.push(...tail)` except that whitespace at the start
 * of `tail` and the end of `head` is collapsed.
 */
function joinWithoutExcessWhitespace(head, tail) {
    if (tail.length === 0) {
        return;
    }
    if (head.length === 0) {
        head.push(...tail);
        return;
    }
    const headEnd = head[head.length - 1];
    const tailStart = tail[0];
    // Whitespace we can just trim off from either end
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(tailStart)) {
        head.push(...tail.slice(1));
        return;
    }
    // If there's no whitespace at one of the ends, no need to worry
    // unless `tailStart` is a comment, in which case it should "eat"
    // the whitespace
    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
            const comment = {
                type: "comment",
                content: tailStart.content,
                sameline: true,
                leadingWhitespace: true,
            };
            tail = tail.slice(1);
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__.trimStart)(tail);
            head.pop();
            head.push(comment, ...tail);
            return;
        }
        head.push(...tail);
        return;
    }
    // If we're here, we have a comment with leading whitespace on one side
    // and whitespace/comments on the other.
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
        if (tailStart.leadingWhitespace || tailStart.sameline) {
            head.push({ type: "comment", content: tailStart.content }, ...tail.slice(1));
            return;
        }
        head.push(...tail);
        return;
    }
    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,
    // but make sure the comment has leading whitespace!
    let comment = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) ? headEnd : tailStart;
    if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(comment)) {
        throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);
    }
    if (!comment.leadingWhitespace || !comment.sameline) {
        comment = {
            type: "comment",
            content: comment.content,
            leadingWhitespace: true,
            sameline: true,
        };
    }
    head.pop();
    head.push(comment, ...tail.slice(1));
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts":
/*!*************************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommandInArray": () => (/* binding */ replaceStreamingCommandInArray)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./join-without-excess-whitespace */ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts");
/* harmony import */ var _wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");



/**
 * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.
 * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.
 * This function does not split based on parbreaks/etc.. It is right-associative and returns
 * the streaming commands that were encountered.
 */
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
    // Streaming commands that come at the end don't do anything,
    // so we should remove them
    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
        nodes.pop();
        (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd)(nodes);
    }
    const foundStreamingCommands = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (isStreamingCommand(node)) {
            const wrapper = (content) => replacer(content, node);
            let tail = nodes.slice(i + 1);
            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart)(tail);
            tail = (0,_wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__.wrapSignificantContent)(tail, wrapper);
            foundStreamingCommands.push(node);
            // Trim off what we're about to replace!
            nodes.splice(i);
            (0,_join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__.joinWithoutExcessWhitespace)(nodes, tail);
        }
    }
    return { foundStreamingCommands };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts":
/*!***************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/wrap-significant-content.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrapSignificantContent": () => (/* binding */ wrapSignificantContent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Wraps `content` in the specified wrapper. This command is roughly equivalent to
 * `wrapper(content)` except that leading and trailing whitespace and comments are extracted
 * from `content` and moved to the front or back of the return array. For example,
 * `[" ", "foo", "bar", "% xxx"]` -> `[" ", wrapped(["foo", "bar"]), "% xxx"]`.
 *
 */
function wrapSignificantContent(content, wrapper) {
    let hoistUntil = 0;
    let hoistAfter = content.length;
    for (let i = 0; i < content.length; i++) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[i]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[i])) {
            hoistUntil = i + 1;
            continue;
        }
        break;
    }
    for (let j = content.length - 1; j >= 0; j--) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[j]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[j])) {
            hoistAfter = j;
            continue;
        }
        break;
    }
    if (hoistUntil === 0 && hoistAfter === content.length) {
        return ensureArray(wrapper(content));
    }
    const frontMatter = content.slice(0, hoistUntil);
    const middle = content.slice(hoistUntil, hoistAfter);
    const backMatter = content.slice(hoistAfter, content.length);
    return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
    if (!Array.isArray(x)) {
        return [x];
    }
    return x;
}


/***/ }),

/***/ "./unified-latex-util-split/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-split/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* reexport safe */ _libs_array_join__WEBPACK_IMPORTED_MODULE_3__.arrayJoin),
/* harmony export */   "splitOnCondition": () => (/* reexport safe */ _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition),
/* harmony export */   "splitOnMacro": () => (/* reexport safe */ _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__.splitOnMacro),
/* harmony export */   "unsplitOnMacro": () => (/* reexport safe */ _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__.unsplitOnMacro)
/* harmony export */ });
/* harmony import */ var _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/split-on-macro */ "./unified-latex-util-split/libs/split-on-macro.ts");
/* harmony import */ var _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");
/* harmony import */ var _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unsplit-on-macro */ "./unified-latex-util-split/libs/unsplit-on-macro.ts");
/* harmony import */ var _libs_array_join__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/array-join */ "./unified-latex-util-split/libs/array-join.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to manipulate `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want break apart or join an array of nodes based on a condition. For example,
 * this is used to split on `&` characters in the `align` environment.
 */ 


/***/ }),

/***/ "./unified-latex-util-split/libs/array-join.ts":
/*!*****************************************************!*\
  !*** ./unified-latex-util-split/libs/array-join.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* binding */ arrayJoin)
/* harmony export */ });
/**
 * Joins an array of arrays with the item `sep`
 */
function arrayJoin(array, sep) {
    return array.flatMap((item, i) => {
        if (i === 0) {
            return item;
        }
        if (Array.isArray(sep)) {
            return [...sep, ...item];
        }
        else {
            return [sep, ...item];
        }
    });
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-condition.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-condition.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnCondition": () => (/* binding */ splitOnCondition)
/* harmony export */ });
/**
 * Split a list of nodes based on whether `splitFunc` returns `true`.
 * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then
 * there will be at most two segments returned.
 */
function splitOnCondition(nodes, splitFunc = () => false, options) {
    if (!Array.isArray(nodes)) {
        throw new Error(`Can only split an Array, not ${nodes}`);
    }
    const { onlySplitOnFirstOccurrence = false } = options || {};
    const splitIndices = [];
    for (let i = 0; i < nodes.length; i++) {
        if (splitFunc(nodes[i])) {
            splitIndices.push(i);
            if (onlySplitOnFirstOccurrence) {
                break;
            }
        }
    }
    // Short circuit if there is no splitting to be done
    if (splitIndices.length === 0) {
        return { segments: [nodes], separators: [] };
    }
    let separators = splitIndices.map((i) => nodes[i]);
    let segments = splitIndices.map((splitEnd, i) => {
        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
        return nodes.slice(splitStart, splitEnd);
    });
    segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
    return { segments, separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-macro.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-macro.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnMacro": () => (/* binding */ splitOnMacro)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");


/**
 * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`
 * is returned. The original array is reconstructed as
 * `segments[0] + macros[0] + segments[1] + ...`.
 *
 * @param {[object]} ast
 * @param {(string|[string])} macroName
 * @returns {{segments: [object], macros: [object]}}
 */
function splitOnMacro(ast, macroName) {
    if (typeof macroName === "string") {
        macroName = [macroName];
    }
    if (!Array.isArray(macroName)) {
        throw new Error("Type coercion failed");
    }
    const isSeparator = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.createMacroMatcher(macroName);
    const { segments, separators } = (0,_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(ast, isSeparator);
    return { segments, macros: separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/unsplit-on-macro.ts":
/*!***********************************************************!*\
  !*** ./unified-latex-util-split/libs/unsplit-on-macro.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsplitOnMacro": () => (/* binding */ unsplitOnMacro)
/* harmony export */ });
/**
 * Does the reverse of `splitOnMacro`
 */
function unsplitOnMacro({ segments, macros, }) {
    if (segments.length === 0) {
        console.warn("Trying to join zero segments");
        return [];
    }
    if (segments.length !== macros.length + 1) {
        console.warn("Mismatch between lengths of macros and segments when trying to unsplit");
    }
    let ret = segments[0];
    for (let i = 0; i < macros.length; i++) {
        // Even though the type of macros[i] is node and not array,
        // Array.concat still works
        ret = ret.concat(macros[i]).concat(segments[i + 1]);
    }
    return ret;
}


/***/ }),

/***/ "./unified-latex-util-trim/index.ts":
/*!******************************************!*\
  !*** ./unified-latex-util-trim/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* reexport safe */ _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__.hasWhitespaceEquivalent),
/* harmony export */   "trim": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trim),
/* harmony export */   "trimEnd": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd),
/* harmony export */   "trimStart": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart),
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* reexport safe */ _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexTrimEnvironmentContents),
/* harmony export */   "unifiedLatexTrimRoot": () => (/* reexport safe */ _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__.unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _libs_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/trim */ "./unified-latex-util-trim/libs/trim.ts");
/* harmony import */ var _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-trim-environment-contents */ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts");
/* harmony import */ var _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unified-latex-trim-root */ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts");
/* harmony import */ var _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/has-whitespace-equivalent */ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to remove whitespace from the ends of an array of nodes.
 *
 * Note that whitespace can come from a `Ast.Whitespace` node or from an
 * `Ast.Comment` node that has leading whitespace. These functions take care
 * to deal with both situations.
 */


/***/ }),

/***/ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts":
/*!*******************************************************************!*\
  !*** ./unified-latex-util-trim/libs/has-whitespace-equivalent.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* binding */ hasWhitespaceEquivalent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`
 * are counted as whitespace. Other comments are ignored.
 */
function hasWhitespaceEquivalent(nodes) {
    let start = false;
    let end = false;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            // A comment with leading whitespace will render with leading whitespace,
            // so if we encounter one, we should consider ourselves to have leading whitespace.
            if (node.leadingWhitespace) {
                start = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            start = true;
        }
        break;
    }
    for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            if (node.leadingWhitespace) {
                end = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            end = true;
        }
        break;
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/trim.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-trim/libs/trim.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "trimEnd": () => (/* binding */ trimEnd),
/* harmony export */   "trimStart": () => (/* binding */ trimStart)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Trims whitespace and parbreaks from the start and end
 * of an array. The number of trimmed nodes is returned.
 * Special care is taken to preserve comments, though any whitespace
 * before the first comment(s) or after the last comment(s) is trimmed.
 */
function trim(nodes) {
    if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
}
/**
 * Trim whitespace and parbreaks from the left of an array.
 */
function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    // If there are comments at the start, they might have leading whitespace.
    // This leading whitespace should be trimmed
    for (const leadingToken of nodes) {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(leadingToken)) {
            break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
            // We remove the position information from this token to indicate that we've edited it
            delete leadingToken.position;
        }
        // Special care must be taken. If the comment was on the same line as a
        // parskip, it will no longer be on the same line after the trimming.
        // Thus, we must modify the comment.
        if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
            delete leadingToken.position;
        }
    }
    return { trimmedStart: start };
}
/**
 * Trim whitespace and parbreaks from the right of an array.
 */
function trimEnd(nodes) {
    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end, end);
    // Trim off any spaces belonging to trailing comments
    for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken)) {
            break;
        }
        // We don't trim spaces before trailing same-line comments. This is a stylistic choice
        // so that
        // `foo %xxx` does not become `foo%xxx`.
        // The latter is strictly "correct" for a trim function, but it is prettier to format
        // code preserving the space before the sameline comment
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken) &&
            trailingToken.leadingWhitespace &&
            !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
            delete trailingToken.position;
        }
    }
    return { trimmedEnd: end };
}
/**
 * Returns the number of whitespace/parbreak nodes at the start and end of an array.
 */
function amountOfLeadingAndTrailingWhitespace(ast) {
    let start = 0;
    let end = 0;
    for (const node of ast) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            start++;
        }
        else {
            break;
        }
    }
    if (start === ast.length) {
        return { start, end: 0 };
    }
    // Find the padding on the right
    for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            end++;
        }
        else {
            break;
        }
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* binding */ unifiedLatexTrimEnvironmentContents)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");



/**
 * Unified plugin to trim the whitespace from the start/end of any environments, including
 * math environments.
 */
const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents() {
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
            if (!(_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.anyEnvironment(node))) {
                return;
            }
            // If the first thing in the environment is a sameline comment,
            // we actually want to start trimming *after* it.
            let firstNode = node.content[0];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(firstNode) && firstNode.sameline) {
                firstNode.suffixParbreak = false;
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(node.content);
                // We play a nasty trick here. This call to `trimStart`
                // will actually modify `node.content` if `node.content.slice(1)` starts
                // with a comment that has leading whitespace (it will remove that whitespace).
                // However, it won't remove any elements from `node.content`; we need
                // to do that ourselves.
                const { trimmedStart } = (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(node.content.slice(1));
                node.content.splice(1, trimmedStart);
            }
            else {
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(node.content);
            }
        });
    };
};


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts":
/*!*****************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-root.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimRoot": () => (/* binding */ unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");

/**
 * Unified plugin to trim the whitespace from the start/end of the root element.
 */
const unifiedLatexTrimRoot = function unifiedLatexTrimRoot() {
    return (tree) => {
        (0,_trim__WEBPACK_IMPORTED_MODULE_0__.trim)(tree.content);
    };
};


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this node’s children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************************************!*\
  !*** ./unified-latex-util-comments/index.ts ***!
  \**********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteComments": () => (/* reexport safe */ _libs_delete_comments__WEBPACK_IMPORTED_MODULE_0__.deleteComments)
/* harmony export */ });
/* harmony import */ var _libs_delete_comments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/delete-comments */ "./unified-latex-util-comments/libs/delete-comments.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify comments in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to process comments in a `unified-latex` AST.
 */

})();

var __webpack_exports__deleteComments = __webpack_exports__.deleteComments;
export { __webpack_exports__deleteComments as deleteComments };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aW50L3V0aWxzL3JlcGxhY2Utbm9kZS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLWNvbW1lbnRzL2xpYnMvZGVsZXRlLWNvbW1lbnRzLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9saWJzL21hdGNoLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3L2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3L2xpYnMvcHJpbnQtcmF3LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy9yZXBsYWNlLW5vZGUudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvcmVwbGFjZS1zdHJlYW1pbmctY29tbWFuZC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy91bmlmaWVkLWxhdGV4LXN0cmVhbWluZy1jb21tYW5kLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL2ZpcnN0LXNpZ25pZmljYW50LW5vZGUudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvdXRpbHMvam9pbi13aXRob3V0LWV4Y2Vzcy13aGl0ZXNwYWNlLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL3JlcGxhY2Utc3RyZWFtaW5nLWNvbW1hbmQtaW4tYXJyYXkudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvdXRpbHMvd3JhcC1zaWduaWZpY2FudC1jb250ZW50LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL2FycmF5LWpvaW4udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3NwbGl0LW9uLWNvbmRpdGlvbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNwbGl0L2xpYnMvc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3Vuc3BsaXQtb24tbWFjcm8udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL2hhcy13aGl0ZXNwYWNlLWVxdWl2YWxlbnQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdHJpbS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXRyaW0vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHMudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3QudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvbGlzdC1tYXRoLWNoaWxkcmVuLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvbGlicy92aXNpdC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1jb21tZW50cy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaXNpdEluZm8gfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgY3VycmVudCBub2RlIHdpdGggYHJlcGxhY2VtZW50YC4gSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBjdXJyZW50XG4gKiBub2RlIGlzIGluIGFuIGFycmF5IHRoYXQgaXMgYSBjaGlsZCBvZiBhIHBhcmVudCBlbGVtZW50LiBJZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSxcbiAqIHRoZSBmdW5jdGlvbiB3aWxsIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGVEdXJpbmdWaXNpdChcbiAgICByZXBsYWNlbWVudDogQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10sXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pIHtcbiAgICBjb25zdCBwYXJlbnQgPSBpbmZvLnBhcmVudHNbMF07XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlOiBwYXJlbnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudFtpbmZvLmtleSBhcyBrZXlvZiB0eXBlb2YgcGFyZW50XSBhcyAoXG4gICAgICAgIHwgQXN0Lk5vZGVcbiAgICAgICAgfCBBc3QuQXJndW1lbnRcbiAgICApW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlOiBjb250YWluaW5nIGFycmF5IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoaW5mby5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZTogbm9kZSBpbmRleCB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgICAgICBjb250YWluZXJbaW5mby5pbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3BsaWNlKGluZm8uaW5kZXgsIDEsIC4uLnJlcGxhY2VtZW50KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgcmVwbGFjZU5vZGUgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2VcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IEFTVCB3aXRoIGFsbCBjb21tZW50cyByZW1vdmVkLiBDYXJlIGlzIHRha2VuIHRvIHByZXNlcnZlIHdoaXRlc3BhY2UuXG4gKiBGb3IgZXhhbXBsZVxuICogYGBgXG4gKiB4JVxuICogeVxuICogYGBgXG4gKiBiZWNvbWVzIGB4eWAgYnV0XG4gKiBgYGBcbiAqIHggJVxuICogeVxuICogYGBgXG4gKiBiZWNvbWVzIGB4IHlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVDb21tZW50cyhhc3Q6IEFzdC5Bc3QpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5vZGUoYXN0LCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIndoaXRlc3BhY2VcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuL2xpYnMvbWF0Y2hcIjtcblxuZXhwb3J0IHsgbWF0Y2ggfTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgICBhbnlFbnZpcm9ubWVudCxcbiAgICBhbnlNYWNybyxcbiAgICBhbnlTdHJpbmcsXG4gICAgYXJndW1lbnQsXG4gICAgYmxhbmtBcmd1bWVudCxcbiAgICBjb21tZW50LFxuICAgIGVudmlyb25tZW50LFxuICAgIGdyb3VwLFxuICAgIG1hY3JvLFxuICAgIG1hdGgsXG4gICAgcGFyYnJlYWssXG4gICAgc3RyaW5nLFxuICAgIHdoaXRlc3BhY2UsXG59ID0gbWF0Y2g7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IGBBc3QuTm9kZWAgdHlwZXMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UgbmVlZCBhIHR5cGUtZ3VhcmQgdG8gZW5zdXJlIGEgbm9kZSBpcyBvZiBhIGNlcnRhaW4gdHlwZTsgZm9yIGV4YW1wbGUsIGR1cmluZyBhIGNhbGwgdG8gYHVuaWZpZWQtbGF0ZXgtdW50aWwtdmlzaXRgLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IEVudkluZm8sIE1hY3JvSW5mbywgTWFjcm9JbmZvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNyb01hdGNoZXIoXG4gICAgbWFjcm9zOiBBc3QuTWFjcm9bXSB8IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgbWFjcm9zSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IG1hY3Jvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHR5cGVvZiBtYWNyb3NbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8sIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjcm8uZXNjYXBlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXNjYXBlVG9rZW46IG1hY3JvLmVzY2FwZVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNyby5jb250ZW50LCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RNYWNyb3Mobm9kZTogYW55IHwgQXN0Lk1hY3JvKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS50eXBlICE9PSBcIm1hY3JvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSBtYWNybyB0eXBlXG4gICAgICAgIGNvbnN0IHNwZWMgPSBtYWNyb3NIYXNoW25vZGUuY29udGVudF07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcIm9iamVjdFwiICYmIFwiZXNjYXBlVG9rZW5cIiBpbiBzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT09IG5vZGUuZXNjYXBlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5NYWNybz47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyKG1hY3Jvczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgZW52aXJvbm1lbnRzSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgbWFjcm9zLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N0ciwge31dIGFzIFtzdHJpbmcsIEVudkluZm9dO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0RW52aXJvbm1lbnRzKG5vZGU6IGFueSB8IEFzdC5FbnZpcm9ubWVudCkge1xuICAgICAgICBpZiAoIW1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuIGVudmlyb25tZW50IHR5cGVcbiAgICAgICAgY29uc3QgZW52TmFtZSA9IHByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgY29uc3Qgc3BlYyA9IGVudmlyb25tZW50c0hhc2hbZW52TmFtZV07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5FbnZpcm9ubWVudD47XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCB0eXBlcyBvZiBub2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0ge1xuICAgIG1hY3JvKG5vZGU6IGFueSwgbWFjcm9OYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJtYWNyb1wiICYmXG4gICAgICAgICAgICAobWFjcm9OYW1lID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSBtYWNyb05hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlNYWNybyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5tYWNybyhub2RlKTtcbiAgICB9LFxuICAgIGVudmlyb25tZW50KG5vZGU6IGFueSwgZW52TmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcImVudmlyb25tZW50XCIgfHwgbm9kZS50eXBlID09PSBcIm1hdGhlbnZcIikgJiZcbiAgICAgICAgICAgIChlbnZOYW1lID09IG51bGwgfHwgcHJpbnRSYXcobm9kZS5lbnYpID09PSBlbnZOYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55RW52aXJvbm1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICByZXR1cm4gbWF0Y2guZW52aXJvbm1lbnQobm9kZSk7XG4gICAgfSxcbiAgICBjb21tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkNvbW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gICAgfSxcbiAgICBwYXJicmVhayhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5QYXJicmVhayB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInBhcmJyZWFrXCI7XG4gICAgfSxcbiAgICB3aGl0ZXNwYWNlKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2Uge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VMaWtlKFxuICAgICAgICBub2RlOiBhbnlcbiAgICApOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHwgKEFzdC5Db21tZW50ICYgeyBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiB8fFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHN0cmluZyhub2RlOiBhbnksIHZhbHVlPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHZhbHVlID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueVN0cmluZyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICByZXR1cm4gbWF0Y2guc3RyaW5nKG5vZGUpO1xuICAgIH0sXG4gICAgZ3JvdXAobm9kZTogYW55KTogbm9kZSBpcyBBc3QuR3JvdXAge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJncm91cFwiO1xuICAgIH0sXG4gICAgYXJndW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQXJndW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJhcmd1bWVudFwiO1xuICAgIH0sXG4gICAgYmxhbmtBcmd1bWVudChub2RlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hcmd1bWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLm9wZW5NYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNsb3NlTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jb250ZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH0sXG4gICAgbWF0aChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5EaXNwbGF5TWF0aCB8IEFzdC5JbmxpbmVNYXRoIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZGlzcGxheW1hdGhcIiB8fCBub2RlLnR5cGUgPT09IFwiaW5saW5lbWF0aFwiO1xuICAgIH0sXG4gICAgY3JlYXRlTWFjcm9NYXRjaGVyLFxuICAgIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcixcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3ByaW50LXJhd1wiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIHByaW50IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpIHRvIGEgc3RyaW5nLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gZGlyZWN0bHkgcHJpbnQgYW4gYEFzdC5Bc3RgIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZyBvciBmb3JtYXR0aW5nLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxudHlwZSBQcmludGFibGUgPSBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCB8IHN0cmluZztcbnR5cGUgUHJpbnRUb2tlbiA9IHN0cmluZyB8IHR5cGVvZiBsaW5lYnJlYWs7XG5cbmV4cG9ydCBjb25zdCBsaW5lYnJlYWsgPSBTeW1ib2woXCJsaW5lYnJlYWtcIik7XG5jb25zdCBFU0NBUEUgPSBcIlxcXFxcIjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYW4gYXJyYXkgaW5zZXJ0aW5nIGBsaW5lYnJlYWtgIHdoZXJlIG5lZWRlZDtcbiAqIFRoaXMgYXJyYXkgbWF5IGJlIG5lc3RlZC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqL1xuZnVuY3Rpb24gX3ByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdKTogUHJpbnRUb2tlbltdIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIChbXSBhcyBQcmludFRva2VuW10pLmNvbmNhdChcbiAgICAgICAgICAgIC4uLm5vZGUubWFwKChuOiBQcmludGFibGUpID0+IF9wcmludFJhdyhuKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gdG1wIHZhcmlhYmxlc1xuICAgIGxldCBhcmdzU3RyaW5nLCBlc2NhcGU7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICAgIHJldHVybiBfcHJpbnRSYXcobm9kZS5jb250ZW50KTtcbiAgICAgICAgY2FzZSBcImFyZ3VtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUub3Blbk1hcmssIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBub2RlLmNsb3NlTWFya107XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gbm9kZS5zdWZmaXhQYXJicmVhayA/IFwiXCIgOiBsaW5lYnJlYWs7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgaXMgcmVzcG9uc2libGUgZm9yIHByaW50aW5nIGl0cyBvd24gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBcIiVcIixcbiAgICAgICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIFwiJVwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgc3VmZml4XTtcbiAgICAgICAgY2FzZSBcImVudmlyb25tZW50XCI6XG4gICAgICAgIGNhc2UgXCJtYXRoZW52XCI6XG4gICAgICAgIGNhc2UgXCJ2ZXJiYXRpbVwiOlxuICAgICAgICAgICAgdmFyIGVudiA9IF9wcmludFJhdyhub2RlLmVudik7XG4gICAgICAgICAgICB2YXIgZW52U3RhcnQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImJlZ2lue1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIHZhciBlbnZFbmQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImVuZHtcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICBhcmdzU3RyaW5nID1cbiAgICAgICAgICAgICAgICAobm9kZSBhcyBhbnkpLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KChub2RlIGFzIGFueSkuYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmVudlN0YXJ0LFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NTdHJpbmcsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgLi4uZW52RW5kLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcImRpc3BsYXltYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW0VTQ0FQRSArIFwiW1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgRVNDQVBFICsgXCJdXCJdO1xuICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCJ7XCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIn1cIl07XG4gICAgICAgIGNhc2UgXCJpbmxpbmVtYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiJFwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCIkXCJdO1xuICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPSBub2RlLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KG5vZGUuYXJncyk7XG4gICAgICAgICAgICBlc2NhcGUgPSBub2RlLmVzY2FwZVRva2VuID09IG51bGwgPyBFU0NBUEUgOiBub2RlLmVzY2FwZVRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIFtlc2NhcGUsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCAuLi5hcmdzU3RyaW5nXTtcbiAgICAgICAgY2FzZSBcInBhcmJyZWFrXCI6XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgbGluZWJyZWFrXTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBjYXNlIFwidmVyYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBFU0NBUEUsXG4gICAgICAgICAgICAgICAgbm9kZS5lbnYsXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwid2hpdGVzcGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiBcIl07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmaW5kIHJlbmRlciBmb3Igbm9kZSBcIixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGAob2YgdHlwZSAke3R5cGVvZiBub2RlfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFtcIlwiICsgbm9kZV07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgLSBTZXR0aW5nIGBhc0FycmF5YCB0byBgdHJ1ZWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdGhlIHN5bWJvbCBgbGluZWJyZWFrYCwgc28gdGhhdCBwcmludGluZyBjYW4gYmUgY3VzdG9taXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM/OiB7IGFzQXJyYXk6IGZhbHNlIH1cbik6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zOiB7IGFzQXJyYXk6IHRydWUgfVxuKTogUHJpbnRUb2tlbltdO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLCBvcHRpb25zPzogb2JqZWN0KTogYW55IHtcbiAgICBjb25zdCBhc0FycmF5ID0gb3B0aW9ucyAhPSBudWxsID8gKG9wdGlvbnMgYXMgYW55KS5hc0FycmF5IDogZmFsc2U7XG4gICAgY29uc3QgcHJpbnRlZFRva2VucyA9IF9wcmludFJhdyhub2RlKTtcbiAgICBpZiAoYXNBcnJheSkge1xuICAgICAgICByZXR1cm4gcHJpbnRlZFRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIHByaW50ZWRUb2tlbnMubWFwKCh4KSA9PiAoeCA9PT0gbGluZWJyZWFrID8gXCJcXG5cIiA6IHgpKS5qb2luKFwiXCIpO1xufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9yZXBsYWNlLW5vZGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdW5pZmllZC1sYXRleC1zdHJlYW1pbmctY29tbWFuZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kXCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gaGVscCBtb2RpZnkgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZWN1cnNpdmVseSByZXBsYWNlIHBhcnRpY3VsYXIgQVNUIG5vZGVzLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHZpc2l0LCBWaXNpdG9yQ29udGV4dCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIG5vZGVzIGluIGBhc3RgLiBUaGUgYHZpc2l0b3JgIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIG5vZGUuIElmXG4gKiBgdmlzaXRvcmAgcmV0dXJucyBhIG5vZGUgb3IgYW4gYXJyYXkgb2Ygbm9kZXMsIHRob3NlIG5vZGVzIHJlcGxhY2UgdGhlIG5vZGUgcGFzc2VkIHRvIGB2aXNpdG9yYC5cbiAqIElmIGBudWxsYCBpcyByZXR1cm5lZCwgdGhlIG5vZGUgaXMgZGVsZXRlZC4gSWYgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQsIG5vIHJlcGxhY2VtZW50IGhhcHBlbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlTm9kZShcbiAgICBhc3Q6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjogKFxuICAgICAgICBub2RlOiBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCxcbiAgICAgICAgY29udGV4dDogVmlzaXRvckNvbnRleHRcbiAgICApID0+XG4gICAgICAgIHwgQXN0Lk5vZGVcbiAgICAgICAgfCBBc3QuQXJndW1lbnRcbiAgICAgICAgfCAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW11cbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgIHwgdm9pZFxuKSB7XG4gICAgdmlzaXQoYXN0LCAobm9kZSwgaW5mbykgPT4ge1xuICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB2aXNpdG9yKG5vZGUsIGluZm8uY29udGV4dCk7XG4gICAgICAgIC8vIFJldHVybmluZyBgdW5kZWZpbmVkYCBvciB0aGUgc2FtZSBub2RlIG1lYW5zIHdlIHNob3VsZG4ndCByZXBsYWNlIHRoYXQgbm9kZVxuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcInVuZGVmaW5lZFwiIHx8IHJlcGxhY2VtZW50ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluZm8uY29udGFpbmluZ0FycmF5IHx8IGluZm8uaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVHJ5aW5nIHRvIGRlbGV0ZSBub2RlLCBidXQgY2Fubm90IGZpbmQgY29udGFpbmluZyBhcnJheVwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSAmJiByZXBsYWNlbWVudC5sZW5ndGggPT09IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gQSBudWxsIHJldHVybiBtZWFucyB0aGF0IHdlIGRlbGV0ZSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICBpbmZvLmNvbnRhaW5pbmdBcnJheS5zcGxpY2UoaW5mby5pbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gaW5mby5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gW3JlcGxhY2VtZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm8uY29udGFpbmluZ0FycmF5LnNwbGljZShpbmZvLmluZGV4LCAxLCAuLi5yZXBsYWNlbWVudCk7XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gKnJlcHJvY2VzcyogdGhlIG5vZGVzIHdlIGp1c3QgaW5zZXJ0ZWQgaW50byB0aGUgYXJyYXksXG4gICAgICAgIC8vIGxlc3Qgd2UgZ2V0IHN0dWNrIGluIGEgcmVjdXJzaXZlIGxvb3AgaWYgdGhlIHJlcGxhY2VtZW50IGNvbnRhaW5zIHRoZSBvcmlnaW5hbC5cbiAgICAgICAgLy8gVGh1cyB3ZSBqdW1wIHRvIHRoZSBpbmRleCBhZnRlciBvdXIgcmVwbGFjZW1lbnRzLlxuICAgICAgICByZXR1cm4gaW5mby5pbmRleCArIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICB9KTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQge1xuICAgIHNwbGl0T25Db25kaXRpb24sXG4gICAgdW5zcGxpdE9uTWFjcm8sXG59IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXRcIjtcbmltcG9ydCB7IHRyaW0sIHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbVwiO1xuaW1wb3J0IHsgZmlyc3RTaWduaWZpY2FudE5vZGUgfSBmcm9tIFwiLi91dGlscy9maXJzdC1zaWduaWZpY2FudC1ub2RlXCI7XG5pbXBvcnQgeyByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluQXJyYXkgfSBmcm9tIFwiLi91dGlscy9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kLWluLWFycmF5XCI7XG5pbXBvcnQgeyB3cmFwU2lnbmlmaWNhbnRDb250ZW50IH0gZnJvbSBcIi4vdXRpbHMvd3JhcC1zaWduaWZpY2FudC1jb250ZW50XCI7XG5cbnR5cGUgUmVwbGFjZXIgPSAobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlW107XG5cbi8qKlxuICogUHJvY2VzcyBzdHJlYW1pbmcgY29tbWFuZHMgaW4gYSBncm91cC4gSWYgbmVlZGVkLCBcImVzY2FwZVwiIHRoZSBncm91cC5cbiAqIEZvciBleGFtcGxlLCBge1xcYmZzZXJpZXMgeHh9YCAtPiBgXFx0ZXh0YmZ7eHh9YCwgYnV0IGB7Zm9vIFxcYmZzZXJpZXMgeHh9YCAtPiBge2ZvbyBcXHRleHRiZnt4eH19YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kSW5Hcm91cChcbiAgICBncm91cDogQXN0Lkdyb3VwLFxuICAgIGlzU3RyZWFtaW5nQ29tbWFuZDogKG5vZGU6IGFueSkgPT4gbm9kZSBpcyBBc3QuTWFjcm8sXG4gICAgcmVwbGFjZXI6IChcbiAgICAgICAgY29udGVudDogQXN0Lk5vZGVbXSxcbiAgICAgICAgc3RyZWFtaW5nQ29tbWFuZDogQXN0Lk1hY3JvXG4gICAgKSA9PiBBc3QuTm9kZSB8IEFzdC5Ob2RlW11cbik6IEFzdC5Ob2RlW10ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBncm91cC5jb250ZW50O1xuICAgIC8vIElmIHRoZSBncm91cCBzdGFydGVkIHdpdGggYSBzdHJlYW1pbmcgY29tbWFuZCwgd2Ugd2FudCB0byBwb3BcbiAgICAvLyBvdXQgb2YgdGhlIGdyb3VwLiBFLmcuIGB7XFxiZnNlcmllcyBmb299YCAtPiBgXFx0ZXh0YmZ7Zm9vfWAgYW5kIG5vdCBge1xcdGV4dGJme2Zvb319YFxuICAgIGxldCBwb3BGcm9tR3JvdXAgPSBpc1N0cmVhbWluZ0NvbW1hbmQoZmlyc3RTaWduaWZpY2FudE5vZGUoY29udGVudCkpO1xuXG4gICAgbGV0IGlubmVyUHJvY2Vzc2VkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGlzU3RyZWFtaW5nQ29tbWFuZCxcbiAgICAgICAgcmVwbGFjZXJcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIGdyb3VwIGNvbnNpc3RlZCBvZiBqdXN0IHN0cmVhbWluZyBjb21tYW5kcyAoZm9yIHNvbWUgcmVhc29uLi4uKVxuICAgIC8vIGl0IHNob3VsZCBiZSBlbGltaW5hdGVkXG4gICAgaWYgKGlubmVyUHJvY2Vzc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHBvcEZyb21Hcm91cCkge1xuICAgICAgICByZXR1cm4gaW5uZXJQcm9jZXNzZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwiZ3JvdXBcIiwgY29udGVudDogaW5uZXJQcm9jZXNzZWQgfV07XG4gICAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZ3JvdXAgb3IgYSBub2RlIGFycmF5LCBsb29rIGZvciBzdHJlYW1pbmcgY29tbWFuZHMgKGUuZy4sIGBcXGJmc2VyaWVzYCkgYW5kIHJlcGxhY2UgdGhlbVxuICogd2l0aCB0aGUgc3BlY2lmaWVkIG1hY3JvLiBUaGUgXCJhcmd1bWVudHNcIiBvZiB0aGUgc3RyZWFtaW5nIGNvbW1hbmQgYXJlIHBhc3NlZCB0byBgcmVwbGFjZXJgIGFuZCB0aGUgcmV0dXJuXG4gKiB2YWx1ZSBvZiBgcmVwbGFjZXJgIGlzIGluc2VydGVkIGludG8gdGhlIHN0cmVhbS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNvbW1hbmQgd2lsbCBzcGxpdCBhdCBwYXJicmVha3MgKHNpbmNlIGNvbW1hbmRzIGxpa2UgYFxcdGV4dGJmey4uLn0gZG8gbm90IGFjY2VwdCBwYXJicmVha3MgaW4gdGhlaXJcbiAqIGNvbnRlbnRzKSBhbmQgY2FsbCBgcmVwbGFjZXJgIG11bHRpcGxlIHRpbWVzLCBvbmNlIHBlciBwYXJhZ3JhcGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZChcbiAgICBhc3Q6IEFzdC5Hcm91cCB8IEFzdC5Ob2RlW10sXG4gICAgaXNTdHJlYW1pbmdDb21tYW5kOiAobm9kZTogYW55KSA9PiBub2RlIGlzIEFzdC5NYWNybyxcbiAgICByZXBsYWNlcjogKFxuICAgICAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgICAgICBzdHJlYW1pbmdDb21tYW5kOiBBc3QuTWFjcm9cbiAgICApID0+IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXVxuKTogQXN0Lk5vZGVbXSB7XG4gICAgaWYgKHR5cGVvZiBpc1N0cmVhbWluZ0NvbW1hbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJ2lzU3RyZWFtaW5nQ29tbWFuZCcgbXVzdCBiZSBhIGZ1bmN0aW9uLCBub3QgJyR7dHlwZW9mIGlzU3RyZWFtaW5nQ29tbWFuZH0nYFxuICAgICAgICApO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkQ29udGVudDogQXN0Lk5vZGVbXSA9IFtdO1xuICAgIGlmIChtYXRjaC5ncm91cChhc3QpKSB7XG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluR3JvdXAoXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICBpc1N0cmVhbWluZ0NvbW1hbmQsXG4gICAgICAgICAgICByZXBsYWNlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgLy8gU3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgY29tZSBhdCB0aGUgZW5kIG9mIGEgc2VxdWVuY2Ugb2Ygbm9kZXMgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIC8vIFRoZXkgYWxzbyB3aWxsIGNvbnN1bWUgd2hpdGVzcGFjZSwgc28gd2Ugc2hvdWxkIHJlbW92ZSB0aGVtIGFuZCB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSBhc3Q7XG4gICAgICAgIGxldCBzY2FuSW5kZXggPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBzbGljZUluZGV4ID0gc2NhbkluZGV4O1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICBzY2FuSW5kZXggPiAwICYmXG4gICAgICAgICAgICAoaXNTdHJlYW1pbmdDb21tYW5kKG5vZGVzW3NjYW5JbmRleCAtIDFdKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2Uobm9kZXNbc2NhbkluZGV4IC0gMV0pKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHNjYW5JbmRleC0tO1xuICAgICAgICAgICAgaWYgKGlzU3RyZWFtaW5nQ29tbWFuZChub2Rlc1tzY2FuSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIHNsaWNlSW5kZXggPSBzY2FuSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsaWNlSW5kZXggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKHNsaWNlSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNQYXIgPSAobm9kZTogQXN0Lk5vZGUpID0+XG4gICAgICAgICAgICBtYXRjaC5wYXJicmVhayhub2RlKSB8fCBtYXRjaC5tYWNybyhub2RlLCBcInBhclwiKTtcblxuICAgICAgICAvLyBXZSBzcGxpdCBvbiBib3RoIGEgcGFyYnJlYWsgYW5kIGEgbGl0ZXJhbCBgXFxwYXJgLiBCdXQgd2Ugd2lsbFxuICAgICAgICAvLyBub3JtYWxpemUgZXZlcnl0aGluZyB0byBiZSBwYXJicmVha3NcbiAgICAgICAgY29uc3Qgc3BsaXRCeVBhciA9IHNwbGl0T25Db25kaXRpb24obm9kZXMsIGlzUGFyKTtcbiAgICAgICAgc3BsaXRCeVBhci5zZXBhcmF0b3JzID0gc3BsaXRCeVBhci5zZXBhcmF0b3JzLm1hcCgoc2VwKSA9PlxuICAgICAgICAgICAgbWF0Y2gucGFyYnJlYWsoc2VwKSA/IHNlcCA6IHsgdHlwZTogXCJwYXJicmVha1wiIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXBsYWNlcnM6IFJlcGxhY2VyW10gPSBbXTtcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gc3BsaXRCeVBhci5zZWdtZW50cy5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5QWNjdW11bGF0ZWRSZXBsYWNlcnMobm9kZXM6IEFzdC5Ob2RlW10pOiBBc3QuTm9kZVtdIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwU2lnbmlmaWNhbnRDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zZVJlcGxhY2VycyhyZXBsYWNlcnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzIH0gPSByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluQXJyYXkoXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBpc1N0cmVhbWluZ0NvbW1hbmQsXG4gICAgICAgICAgICAgICAgcmVwbGFjZXJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFsbCBzdHJlYW1pbmcgY29tbWFuZHMgaW4gYHNlZ21lbnRgIGhhdmUgbm93IGJlZW4gcmVwbGFjZWQuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBjb21tYW5kcyBmcm9tIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGhzIHRoYXQgc2hvdWxkIHdyYXBcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNlZ21lbnQhXG4gICAgICAgICAgICBjb25zdCByZXQgPSBhcHBseUFjY3VtdWxhdGVkUmVwbGFjZXJzKHNlZ21lbnQpO1xuXG4gICAgICAgICAgICAvLyBBbnkgc3RyZWFtaW5nIGNvbW1hbmRzIGZyb20gdGhpcyBzZWdtZW50IHdpbGwgY2Fycnkgb3ZlciB0byB0aGUgbmV4dCxcbiAgICAgICAgICAgIC8vIHNvIGtlZXAgdHJhY2sgb2YgdGhlbS5cbiAgICAgICAgICAgIGZvdW5kU3RyZWFtaW5nQ29tbWFuZHMuZm9yRWFjaCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICByZXBsYWNlcnMucHVzaCgobm9kZXM6IEFzdC5Ob2RlW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gcmVwbGFjZXIobm9kZXMsIG1hY3JvIGFzIEFzdC5NYWNybyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3JldF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2Ugd2FzIGhvaXN0ZWQgaW4gZnJvbnQvYmFjayBvZiBlYWNoIHJlcGxhY2VyLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSBzZXBhcmF0ZWQgYnkgcGFyYnJlYWtzLCB3ZSBjYW4gc2FmZWx5IHRyaW0gYWxsIHRoYXQgd2hpdGVzcGFjZS5cbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmltRW5kKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gc2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cmltU3RhcnQoc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbShzZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSB1bnNwbGl0T25NYWNybyh7XG4gICAgICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgICAgICBtYWNyb3M6IHNwbGl0QnlQYXIuc2VwYXJhdG9ycyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZENvbnRlbnQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzZXF1ZW5jZSBvZiByZXBsYWNlciBmdW5jdGlvbnMgYFtmLCBnLCBoXWAgcmV0dXJuXG4gKiBgaCBcXGNpcmMgZyBcXGNpcmMgZmBcbiAqXG4gKiBAcGFyYW0geygobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlKVtdfSByZXBsYWNlcnNcbiAqIEByZXR1cm5zIHsobm9kZXM6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlfVxuICovXG5mdW5jdGlvbiBjb21wb3NlUmVwbGFjZXJzKHJlcGxhY2VyczogUmVwbGFjZXJbXSk6IFJlcGxhY2VyIHtcbiAgICBpZiAocmVwbGFjZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcG9zZSB6ZXJvIHJlcGxhY2VtZW50IGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIChub2RlczogQXN0Lk5vZGVbXSkgPT4ge1xuICAgICAgICBsZXQgcmV0ID0gbm9kZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVwbGFjZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gcmVwbGFjZXJzW2ldO1xuICAgICAgICAgICAgcmV0ID0gZnVuYyhyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgeyByZXBsYWNlTm9kZUR1cmluZ1Zpc2l0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtbGludC91dGlscy9yZXBsYWNlLW5vZGVcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdFwiO1xuaW1wb3J0IHsgcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQgfSBmcm9tIFwiLi9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHtcbiAgICByZXBsYWNlcnM6IFJlY29yZDxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICAoXG4gICAgICAgICAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgICAgICAgICAgc3RyZWFtaW5nQ29tbWFuZDogQXN0Lk1hY3JvXG4gICAgICAgICkgPT4gQXN0Lk5vZGUgfCBBc3QuTm9kZVtdXG4gICAgPjtcbn07XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gcmVwbGFjZSBhbGwgZm91bmQgc3RyZWFtaW5nIGNvbW1hbmRzIHdpdGggdGhlaXIgYXJndW1lbnQtc3R5bGUgZXF1aXZhbGVudHMuXG4gKiBUaGlzIG9ubHkgYXBwbGllcyB0byBzZWN0aW9ucyBvZiB0aGUgdHJlZSB3aXRoIG5vIG1hdGggYW5jZXN0b3IuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMucmVwbGFjZXIgQSByZWNvcmQgb2YgbWFjcm8gbmFtZXMgYW5kIHJlcGxhY2VyIGZ1bmN0aW9ucy4gQSByZXBsYWNlciBmdW5jdGlvbiBhY2NlcHRzIGNvbnRlbnQgYW5kIHRoZSBvcmlnaW5hbCBzdHJlYW1pbmcgY29tbWFuZCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIHRoZSBhcmd1bWVudC1zdHlsZSBjb21tYW5kLiBJdCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHBlciBzdHJlYW1pbmcgY29tbWFuZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFJlcGxhY2VTdHJlYW1pbmdDb21tYW5kczogUGx1Z2luPFxuICAgIFBsdWdpbk9wdGlvbnNbXSxcbiAgICBBc3QuUm9vdCxcbiAgICBBc3QuUm9vdFxuPiA9IGZ1bmN0aW9uIHVuaWZpZWRMYXRleFJlcGxhY2VTdHJlYW1pbmdDb21tYW5kcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXBsYWNlcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBpc1JlcGxhY2VhYmxlID0gbWF0Y2guY3JlYXRlTWFjcm9NYXRjaGVyKHJlcGxhY2Vycyk7XG4gICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgIHZpc2l0KFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIChncm91cCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgIWdyb3VwLmNvbnRlbnQuc29tZShpc1JlcGxhY2VhYmxlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGZpeGVkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBpc1JlcGxhY2VhYmxlLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudCwgY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2Vyc1tjb21tYW5kLmNvbnRlbnRdKGNvbnRlbnQsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCByZXBsYWNlIHRoZSBub2RlIHVubGVzcyB3ZSBjYW4gYWNjZXNzIHRoZSBjb250YWluaW5nIGFycmF5LlxuICAgICAgICAgICAgICAgIGlmICghaW5mby5jb250YWluaW5nQXJyYXkgfHwgaW5mby5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgZml4ZWRgIG1heSBjb25zaXN0IG9mIG9ubHkgd2hpdGVzcGFjZS4gSWYgdGhpcyBpcyB0aGUgY2FzZSxcbiAgICAgICAgICAgICAgICAvLyBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIG11c3QgdHJpbW1lZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpbmcgdGhlIGdyb3VwJ3MgY29udGVudHMuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRva2VuID0gaW5mby5jb250YWluaW5nQXJyYXlbaW5mby5pbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IGluZm8uY29udGFpbmluZ0FycmF5W2luZm8uaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2VMaWtlKHByZXZUb2tlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gud2hpdGVzcGFjZUxpa2UoZml4ZWRbMF0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaW1TdGFydChmaXhlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gud2hpdGVzcGFjZUxpa2UobmV4dFRva2VuKSAmJlxuICAgICAgICAgICAgICAgICAgICBtYXRjaC53aGl0ZXNwYWNlTGlrZShmaXhlZFtmaXhlZC5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbUVuZChmaXhlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VOb2RlRHVyaW5nVmlzaXQoZml4ZWQsIGluZm8pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdGVzdDogbWF0Y2guZ3JvdXAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZpc2l0KFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIChub2RlcywgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgIW5vZGVzLnNvbWUoaXNSZXBsYWNlYWJsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBpc1JlcGxhY2VhYmxlLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudCwgY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2Vyc1tjb21tYW5kLmNvbnRlbnRdKGNvbnRlbnQsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBiYWNrIGEgZGlmZmVyZW50IGFycmF5IHRoYW4gd2UgaW5wdXQsIHRoZSByZXBsYWNlbWVudCBkaWRcbiAgICAgICAgICAgICAgICAvLyBub3QgaGFwcGVuIGluLXBsYWNlLiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBtYW5pcHVsYXRlIGBub2Rlc2AuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VkICE9PSBub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKC4uLnJlcGxhY2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlQXJyYXlzOiB0cnVlLCB0ZXN0OiBBcnJheS5pc0FycmF5IH1cbiAgICAgICAgKTtcbiAgICB9O1xufTtcbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2Uvbm9uLWNvbW1lbnQgbm9kZSBpbiBgbm9kZXNgLiBJZiB0aGVyZSBpcyBubyBzdWNoXG4gKiBub2RlLCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFNpZ25pZmljYW50Tm9kZShub2RlczogQXN0Lk5vZGVbXSk6IEFzdC5Ob2RlIHwgbnVsbCB7XG4gICAgbGV0IGZpcnN0Tm9kZTogQXN0Lk5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHwgbWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3ROb2RlID0gbm9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0Tm9kZTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcblxuLyoqXG4gKiBJcyB0aGUgbm9kZSBzcGFjZS1saWtlPyBJLmUuLCBpcyBpdCB3aGl0ZXNwYWNlIG9yXG4gKiBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2U/XG4gKi9cbmZ1bmN0aW9uIGlzU3BhY2VMaWtlKG5vZGU6IEFzdC5Ob2RlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbWF0Y2gud2hpdGVzcGFjZShub2RlKSB8fFxuICAgICAgICAobWF0Y2guY29tbWVudChub2RlKSAmJiBCb29sZWFuKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpKVxuICAgICk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgaGVhZC5wdXNoKC4uLnRhaWwpYCBleGNlcHQgdGhhdCB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICogb2YgYHRhaWxgIGFuZCB0aGUgZW5kIG9mIGBoZWFkYCBpcyBjb2xsYXBzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luV2l0aG91dEV4Y2Vzc1doaXRlc3BhY2UoXG4gICAgaGVhZDogQXN0Lk5vZGVbXSxcbiAgICB0YWlsOiBBc3QuTm9kZVtdXG4pOiB2b2lkIHtcbiAgICBpZiAodGFpbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGVhZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaGVhZC5wdXNoKC4uLnRhaWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhlYWRFbmQgPSBoZWFkW2hlYWQubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdGFpbFN0YXJ0ID0gdGFpbFswXTtcbiAgICAvLyBXaGl0ZXNwYWNlIHdlIGNhbiBqdXN0IHRyaW0gb2ZmIGZyb20gZWl0aGVyIGVuZFxuICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKGhlYWRFbmQpICYmIG1hdGNoLndoaXRlc3BhY2UodGFpbFN0YXJ0KSkge1xuICAgICAgICBoZWFkLnB1c2goLi4udGFpbC5zbGljZSgxKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyB3aGl0ZXNwYWNlIGF0IG9uZSBvZiB0aGUgZW5kcywgbm8gbmVlZCB0byB3b3JyeVxuICAgIC8vIHVubGVzcyBgdGFpbFN0YXJ0YCBpcyBhIGNvbW1lbnQsIGluIHdoaWNoIGNhc2UgaXQgc2hvdWxkIFwiZWF0XCJcbiAgICAvLyB0aGUgd2hpdGVzcGFjZVxuICAgIGlmICghaXNTcGFjZUxpa2UoaGVhZEVuZCkgfHwgIWlzU3BhY2VMaWtlKHRhaWxTdGFydCkpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2UoaGVhZEVuZCkgJiYgbWF0Y2guY29tbWVudCh0YWlsU3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50OiBBc3QuQ29tbWVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0YWlsU3RhcnQuY29udGVudCxcbiAgICAgICAgICAgICAgICBzYW1lbGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWlsID0gdGFpbC5zbGljZSgxKTtcbiAgICAgICAgICAgIHRyaW1TdGFydCh0YWlsKTtcbiAgICAgICAgICAgIGhlYWQucG9wKCk7XG4gICAgICAgICAgICBoZWFkLnB1c2goY29tbWVudCwgLi4udGFpbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGVhZC5wdXNoKC4uLnRhaWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaGVyZSwgd2UgaGF2ZSBhIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gb25lIHNpZGVcbiAgICAvLyBhbmQgd2hpdGVzcGFjZS9jb21tZW50cyBvbiB0aGUgb3RoZXIuXG4gICAgaWYgKG1hdGNoLmNvbW1lbnQoaGVhZEVuZCkgJiYgbWF0Y2guY29tbWVudCh0YWlsU3RhcnQpKSB7XG4gICAgICAgIGlmICh0YWlsU3RhcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgdGFpbFN0YXJ0LnNhbWVsaW5lKSB7XG4gICAgICAgICAgICBoZWFkLnB1c2goXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBcImNvbW1lbnRcIiwgY29udGVudDogdGFpbFN0YXJ0LmNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAuLi50YWlsLnNsaWNlKDEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhlYWQucHVzaCguLi50YWlsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgb25lIHNpZGUgaXMgYSBjb21tZW50LCBzbyB3ZSBzaG91bGQgdHJpbSB0aGUgd2hpdGVzcGFjZSBhbmQga2VlcCB0aGUgY29tbWVudCxcbiAgICAvLyBidXQgbWFrZSBzdXJlIHRoZSBjb21tZW50IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UhXG4gICAgbGV0IGNvbW1lbnQgPSBtYXRjaC5jb21tZW50KGhlYWRFbmQpID8gaGVhZEVuZCA6IHRhaWxTdGFydDtcbiAgICBpZiAoIW1hdGNoLmNvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgY29tbWVudCBidXQgZm91bmQgJHtKU09OLnN0cmluZ2lmeShjb21tZW50KX1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFjb21tZW50LnNhbWVsaW5lKSB7XG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbW1lbnQuY29udGVudCxcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICAgICAgc2FtZWxpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGVhZC5wb3AoKTtcbiAgICBoZWFkLnB1c2goY29tbWVudCwgLi4udGFpbC5zbGljZSgxKSk7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbVwiO1xuaW1wb3J0IHsgam9pbldpdGhvdXRFeGNlc3NXaGl0ZXNwYWNlIH0gZnJvbSBcIi4vam9pbi13aXRob3V0LWV4Y2Vzcy13aGl0ZXNwYWNlXCI7XG5pbXBvcnQgeyB3cmFwU2lnbmlmaWNhbnRDb250ZW50IH0gZnJvbSBcIi4vd3JhcC1zaWduaWZpY2FudC1jb250ZW50XCI7XG5cbi8qKlxuICogUmVwbGFjZSBjb21tYW5kcyBpZGVudGlmaWVkIGJ5IGBpc1N0cmVhbWluZ0NvbW1hbmRgIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiBgcmVwbGFjZXJgLlxuICogRS5nLiwgdGhlIGFycmF5IGBbaGVhZCwgc3RyZWFtaW5nQ29tbWFuZCwgLi4udGFpbF1gIHdpbGwgYmVjb21lIGBbaGVhZCwgcmVwbGFjZXIodGFpbCwgc3RyZWFtaW5nQ29tbWFuZCldYC5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3BsaXQgYmFzZWQgb24gcGFyYnJlYWtzL2V0Yy4uIEl0IGlzIHJpZ2h0LWFzc29jaWF0aXZlIGFuZCByZXR1cm5zXG4gKiB0aGUgc3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgd2VyZSBlbmNvdW50ZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kSW5BcnJheShcbiAgICBub2RlczogQXN0Lk5vZGVbXSxcbiAgICBpc1N0cmVhbWluZ0NvbW1hbmQ6IChub2RlOiBhbnkpID0+IG5vZGUgaXMgQXN0Lk1hY3JvLFxuICAgIHJlcGxhY2VyOiAoXG4gICAgICAgIGNvbnRlbnQ6IEFzdC5Ob2RlW10sXG4gICAgICAgIHN0cmVhbWluZ0NvbW1hbmQ6IEFzdC5NYWNyb1xuICAgICkgPT4gQXN0Lk5vZGUgfCBBc3QuTm9kZVtdXG4pOiB7IGZvdW5kU3RyZWFtaW5nQ29tbWFuZHM6IEFzdC5Ob2RlW10gfSB7XG4gICAgLy8gU3RyZWFtaW5nIGNvbW1hbmRzIHRoYXQgY29tZSBhdCB0aGUgZW5kIGRvbid0IGRvIGFueXRoaW5nLFxuICAgIC8vIHNvIHdlIHNob3VsZCByZW1vdmUgdGhlbVxuICAgIHdoaWxlIChub2Rlcy5sZW5ndGggPiAwICYmIGlzU3RyZWFtaW5nQ29tbWFuZChub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgIHRyaW1FbmQobm9kZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvdW5kU3RyZWFtaW5nQ29tbWFuZHM6IEFzdC5Ob2RlW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc1N0cmVhbWluZ0NvbW1hbmQobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoY29udGVudDogQXN0Lk5vZGVbXSkgPT4gcmVwbGFjZXIoY29udGVudCwgbm9kZSk7XG4gICAgICAgICAgICBsZXQgdGFpbCA9IG5vZGVzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIC8vIFN0cmVhbWluZyBjb21tYW5kcyBhcmUgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgd2hpY2ggYmVjb21lcyB1bm5lZWRlZCB3aGVuIHRoZSBjb21tYW5kcyBhcmUgcmVwbGFjZWQuXG4gICAgICAgICAgICB0cmltU3RhcnQodGFpbCk7XG4gICAgICAgICAgICB0YWlsID0gd3JhcFNpZ25pZmljYW50Q29udGVudCh0YWlsLCB3cmFwcGVyKTtcbiAgICAgICAgICAgIGZvdW5kU3RyZWFtaW5nQ29tbWFuZHMucHVzaChub2RlKTtcblxuICAgICAgICAgICAgLy8gVHJpbSBvZmYgd2hhdCB3ZSdyZSBhYm91dCB0byByZXBsYWNlIVxuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGkpO1xuXG4gICAgICAgICAgICBqb2luV2l0aG91dEV4Y2Vzc1doaXRlc3BhY2Uobm9kZXMsIHRhaWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZm91bmRTdHJlYW1pbmdDb21tYW5kcyB9O1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuLyoqXG4gKiBXcmFwcyBgY29udGVudGAgaW4gdGhlIHNwZWNpZmllZCB3cmFwcGVyLiBUaGlzIGNvbW1hbmQgaXMgcm91Z2hseSBlcXVpdmFsZW50IHRvXG4gKiBgd3JhcHBlcihjb250ZW50KWAgZXhjZXB0IHRoYXQgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMgYXJlIGV4dHJhY3RlZFxuICogZnJvbSBgY29udGVudGAgYW5kIG1vdmVkIHRvIHRoZSBmcm9udCBvciBiYWNrIG9mIHRoZSByZXR1cm4gYXJyYXkuIEZvciBleGFtcGxlLFxuICogYFtcIiBcIiwgXCJmb29cIiwgXCJiYXJcIiwgXCIlIHh4eFwiXWAgLT4gYFtcIiBcIiwgd3JhcHBlZChbXCJmb29cIiwgXCJiYXJcIl0pLCBcIiUgeHh4XCJdYC5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwU2lnbmlmaWNhbnRDb250ZW50KFxuICAgIGNvbnRlbnQ6IEFzdC5Ob2RlW10sXG4gICAgd3JhcHBlcjogKGNvbnRlbnQ6IEFzdC5Ob2RlW10pID0+IEFzdC5Ob2RlW10gfCBBc3QuTm9kZVxuKTogQXN0Lk5vZGVbXSB7XG4gICAgbGV0IGhvaXN0VW50aWwgPSAwO1xuICAgIGxldCBob2lzdEFmdGVyID0gY29udGVudC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKGNvbnRlbnRbaV0pIHx8IG1hdGNoLmNvbW1lbnQoY29udGVudFtpXSkpIHtcbiAgICAgICAgICAgIGhvaXN0VW50aWwgPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShjb250ZW50W2pdKSB8fCBtYXRjaC5jb21tZW50KGNvbnRlbnRbal0pKSB7XG4gICAgICAgICAgICBob2lzdEFmdGVyID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChob2lzdFVudGlsID09PSAwICYmIGhvaXN0QWZ0ZXIgPT09IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh3cmFwcGVyKGNvbnRlbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcm9udE1hdHRlciA9IGNvbnRlbnQuc2xpY2UoMCwgaG9pc3RVbnRpbCk7XG4gICAgY29uc3QgbWlkZGxlID0gY29udGVudC5zbGljZShob2lzdFVudGlsLCBob2lzdEFmdGVyKTtcbiAgICBjb25zdCBiYWNrTWF0dGVyID0gY29udGVudC5zbGljZShob2lzdEFmdGVyLCBjb250ZW50Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gZnJvbnRNYXR0ZXIuY29uY2F0KHdyYXBwZXIobWlkZGxlKSwgYmFja01hdHRlcik7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KHg6IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvc3BsaXQtb24tY29uZGl0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3Vuc3BsaXQtb24tbWFjcm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvYXJyYXktam9pblwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgYnJlYWsgYXBhcnQgb3Igam9pbiBhbiBhcnJheSBvZiBub2RlcyBiYXNlZCBvbiBhIGNvbmRpdGlvbi4gRm9yIGV4YW1wbGUsXG4gKiB0aGlzIGlzIHVzZWQgdG8gc3BsaXQgb24gYCZgIGNoYXJhY3RlcnMgaW4gdGhlIGBhbGlnbmAgZW52aXJvbm1lbnQuXG4gKi8iLCIvKipcbiAqIEpvaW5zIGFuIGFycmF5IG9mIGFycmF5cyB3aXRoIHRoZSBpdGVtIGBzZXBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUpvaW48VD4oYXJyYXk6IFRbXVtdLCBzZXA6IFQgfCBUW10pOiBUW10ge1xuICAgIHJldHVybiBhcnJheS5mbGF0TWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXApKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnNlcCwgLi4uaXRlbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NlcCwgLi4uaXRlbV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG4vKipcbiAqIFNwbGl0IGEgbGlzdCBvZiBub2RlcyBiYXNlZCBvbiB3aGV0aGVyIGBzcGxpdEZ1bmNgIHJldHVybnMgYHRydWVgLlxuICogSWYgYG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlYCBpcyBzZXQgdG8gdHJ1ZSBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgdGhlblxuICogdGhlcmUgd2lsbCBiZSBhdCBtb3N0IHR3byBzZWdtZW50cyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T25Db25kaXRpb24oXG4gICAgbm9kZXM6IEFzdC5Ob2RlW10sXG4gICAgc3BsaXRGdW5jOiAobm9kZTogQXN0Lk5vZGUpID0+IGJvb2xlYW4gPSAoKSA9PiBmYWxzZSxcbiAgICBvcHRpb25zPzogeyBvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZT86IGJvb2xlYW4gfVxuKTogeyBzZWdtZW50czogQXN0Lk5vZGVbXVtdOyBzZXBhcmF0b3JzOiBBc3QuTm9kZVtdIH0ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gb25seSBzcGxpdCBhbiBBcnJheSwgbm90ICR7bm9kZXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZSA9IGZhbHNlIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qgc3BsaXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwbGl0RnVuYyhub2Rlc1tpXSkpIHtcbiAgICAgICAgICAgIHNwbGl0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgaWYgKG9ubHlTcGxpdE9uRmlyc3RPY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHRoZXJlIGlzIG5vIHNwbGl0dGluZyB0byBiZSBkb25lXG4gICAgaWYgKHNwbGl0SW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgc2VnbWVudHM6IFtub2Rlc10sIHNlcGFyYXRvcnM6IFtdIH07XG4gICAgfVxuXG4gICAgbGV0IHNlcGFyYXRvcnMgPSBzcGxpdEluZGljZXMubWFwKChpKSA9PiBub2Rlc1tpXSk7XG4gICAgbGV0IHNlZ21lbnRzID0gc3BsaXRJbmRpY2VzLm1hcCgoc3BsaXRFbmQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGkgPT09IDAgPyAwIDogc3BsaXRJbmRpY2VzW2kgLSAxXSArIDE7XG4gICAgICAgIHJldHVybiBub2Rlcy5zbGljZShzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgfSk7XG4gICAgc2VnbWVudHMucHVzaChcbiAgICAgICAgbm9kZXMuc2xpY2Uoc3BsaXRJbmRpY2VzW3NwbGl0SW5kaWNlcy5sZW5ndGggLSAxXSArIDEsIG5vZGVzLmxlbmd0aClcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgc2VnbWVudHMsIHNlcGFyYXRvcnMgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyBzcGxpdE9uQ29uZGl0aW9uIH0gZnJvbSBcIi4vc3BsaXQtb24tY29uZGl0aW9uXCI7XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXkgb2YgQVNUIG5vZGVzIGJhc2VkIG9uIGEgbWFjcm8uIEFuIG9iamVjdCBge3NlZ21lbnRzOiBbXSwgbWFjcm9zOiBbXX1gXG4gKiBpcyByZXR1cm5lZC4gVGhlIG9yaWdpbmFsIGFycmF5IGlzIHJlY29uc3RydWN0ZWQgYXNcbiAqIGBzZWdtZW50c1swXSArIG1hY3Jvc1swXSArIHNlZ21lbnRzWzFdICsgLi4uYC5cbiAqXG4gKiBAcGFyYW0ge1tvYmplY3RdfSBhc3RcbiAqIEBwYXJhbSB7KHN0cmluZ3xbc3RyaW5nXSl9IG1hY3JvTmFtZVxuICogQHJldHVybnMge3tzZWdtZW50czogW29iamVjdF0sIG1hY3JvczogW29iamVjdF19fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbk1hY3JvKFxuICAgIGFzdDogQXN0Lk5vZGVbXSxcbiAgICBtYWNyb05hbWU6IHN0cmluZyB8IHN0cmluZ1tdXG4pOiB7IHNlZ21lbnRzOiBBc3QuTm9kZVtdW107IG1hY3JvczogQXN0Lk1hY3JvW10gfSB7XG4gICAgaWYgKHR5cGVvZiBtYWNyb05hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWFjcm9OYW1lID0gW21hY3JvTmFtZV07XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShtYWNyb05hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgY29lcmNpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBpc1NlcGFyYXRvciA9IG1hdGNoLmNyZWF0ZU1hY3JvTWF0Y2hlcihtYWNyb05hbWUpO1xuICAgIGNvbnN0IHsgc2VnbWVudHMsIHNlcGFyYXRvcnMgfSA9IHNwbGl0T25Db25kaXRpb24oYXN0LCBpc1NlcGFyYXRvcik7XG4gICAgcmV0dXJuIHsgc2VnbWVudHMsIG1hY3Jvczogc2VwYXJhdG9ycyBhcyBBc3QuTWFjcm9bXSB9O1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbi8qKlxuICogRG9lcyB0aGUgcmV2ZXJzZSBvZiBgc3BsaXRPbk1hY3JvYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zcGxpdE9uTWFjcm8oe1xuICAgIHNlZ21lbnRzLFxuICAgIG1hY3Jvcyxcbn06IHtcbiAgICBzZWdtZW50czogQXN0Lk5vZGVbXVtdO1xuICAgIG1hY3JvczogQXN0Lk5vZGVbXSB8IEFzdC5Ob2RlW11bXTtcbn0pIHtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRyeWluZyB0byBqb2luIHplcm8gc2VnbWVudHNcIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAhPT0gbWFjcm9zLmxlbmd0aCArIDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJNaXNtYXRjaCBiZXR3ZWVuIGxlbmd0aHMgb2YgbWFjcm9zIGFuZCBzZWdtZW50cyB3aGVuIHRyeWluZyB0byB1bnNwbGl0XCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0ID0gc2VnbWVudHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYWNyb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIHR5cGUgb2YgbWFjcm9zW2ldIGlzIG5vZGUgYW5kIG5vdCBhcnJheSxcbiAgICAgICAgLy8gQXJyYXkuY29uY2F0IHN0aWxsIHdvcmtzXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQobWFjcm9zW2ldKS5jb25jYXQoc2VnbWVudHNbaSArIDFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy90cmltXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3VuaWZpZWQtbGF0ZXgtdHJpbS1lbnZpcm9ubWVudC1jb250ZW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tcm9vdFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy9oYXMtd2hpdGVzcGFjZS1lcXVpdmFsZW50XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gaGVscCBtb2RpZnkgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmRzIG9mIGFuIGFycmF5IG9mIG5vZGVzLlxuICpcbiAqIE5vdGUgdGhhdCB3aGl0ZXNwYWNlIGNhbiBjb21lIGZyb20gYSBgQXN0LldoaXRlc3BhY2VgIG5vZGUgb3IgZnJvbSBhblxuICogYEFzdC5Db21tZW50YCBub2RlIHRoYXQgaGFzIGxlYWRpbmcgd2hpdGVzcGFjZS4gVGhlc2UgZnVuY3Rpb25zIHRha2UgY2FyZVxuICogdG8gZGVhbCB3aXRoIGJvdGggc2l0dWF0aW9ucy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFycmF5IGhhcyB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydC9lbmQuIENvbW1lbnRzIHdpdGggYGxlYWRpbmdXaGl0ZXNwYWNlID09PSB0cnVlYFxuICogYXJlIGNvdW50ZWQgYXMgd2hpdGVzcGFjZS4gT3RoZXIgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNXaGl0ZXNwYWNlRXF1aXZhbGVudChub2RlczogQXN0Lk5vZGVbXSk6IHtcbiAgICBzdGFydDogYm9vbGVhbjtcbiAgICBlbmQ6IGJvb2xlYW47XG59IHtcbiAgICBsZXQgc3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChtYXRjaC5jb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2Ugd2lsbCByZW5kZXIgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UsXG4gICAgICAgICAgICAvLyBzbyBpZiB3ZSBlbmNvdW50ZXIgb25lLCB3ZSBzaG91bGQgY29uc2lkZXIgb3Vyc2VsdmVzIHRvIGhhdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShub2RlKSkge1xuICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gbm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICBpZiAobWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogVHJpbXMgd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmRcbiAqIG9mIGFuIGFycmF5LiBUaGUgbnVtYmVyIG9mIHRyaW1tZWQgbm9kZXMgaXMgcmV0dXJuZWQuXG4gKiBTcGVjaWFsIGNhcmUgaXMgdGFrZW4gdG8gcHJlc2VydmUgY29tbWVudHMsIHRob3VnaCBhbnkgd2hpdGVzcGFjZVxuICogYmVmb3JlIHRoZSBmaXJzdCBjb21tZW50KHMpIG9yIGFmdGVyIHRoZSBsYXN0IGNvbW1lbnQocykgaXMgdHJpbW1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0obm9kZXM6IEFzdC5Ob2RlW10pOiB7XG4gICAgdHJpbW1lZFN0YXJ0OiBudW1iZXI7XG4gICAgdHJpbW1lZEVuZDogbnVtYmVyO1xufSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gdHJpbSBhIG5vbi1hcnJheSBhc3RcIiwgbm9kZXMpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2Rlcyk7XG4gICAgY29uc3QgeyB0cmltbWVkRW5kIH0gPSB0cmltRW5kKG5vZGVzKTtcblxuICAgIHJldHVybiB7IHRyaW1tZWRTdGFydCwgdHJpbW1lZEVuZCB9O1xufVxuXG4vKipcbiAqIFRyaW0gd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIGxlZnQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnQobm9kZXM6IEFzdC5Ob2RlW10pOiB7IHRyaW1tZWRTdGFydDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgc3RhcnQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2UoMCwgc3RhcnQpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNvbW1lbnRzIGF0IHRoZSBzdGFydCwgdGhleSBtaWdodCBoYXZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAvLyBUaGlzIGxlYWRpbmcgd2hpdGVzcGFjZSBzaG91bGQgYmUgdHJpbW1lZFxuICAgIGZvciAoY29uc3QgbGVhZGluZ1Rva2VuIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmICghbWF0Y2guY29tbWVudChsZWFkaW5nVG9rZW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlIHx8IGxlYWRpbmdUb2tlbi5zYW1lbGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhpcyB0b2tlbiB0byBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGVkaXRlZCBpdFxuICAgICAgICAgICAgZGVsZXRlIGxlYWRpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIGNhcmUgbXVzdCBiZSB0YWtlbi4gSWYgdGhlIGNvbW1lbnQgd2FzIG9uIHRoZSBzYW1lIGxpbmUgYXMgYVxuICAgICAgICAvLyBwYXJza2lwLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBvbiB0aGUgc2FtZSBsaW5lIGFmdGVyIHRoZSB0cmltbWluZy5cbiAgICAgICAgLy8gVGh1cywgd2UgbXVzdCBtb2RpZnkgdGhlIGNvbW1lbnQuXG4gICAgICAgIGlmIChzdGFydCA+IDAgJiYgbGVhZGluZ1Rva2VuLnNhbWVsaW5lKSB7XG4gICAgICAgICAgICBsZWFkaW5nVG9rZW4uc2FtZWxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFkaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmltbWVkU3RhcnQ6IHN0YXJ0IH07XG59XG5cbi8qKlxuICogVHJpbSB3aGl0ZXNwYWNlIGFuZCBwYXJicmVha3MgZnJvbSB0aGUgcmlnaHQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltRW5kKG5vZGVzOiBBc3QuTm9kZVtdKTogeyB0cmltbWVkRW5kOiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBlbmQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2Uobm9kZXMubGVuZ3RoIC0gZW5kLCBlbmQpO1xuXG4gICAgLy8gVHJpbSBvZmYgYW55IHNwYWNlcyBiZWxvbmdpbmcgdG8gdHJhaWxpbmcgY29tbWVudHNcbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdUb2tlbiA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQodHJhaWxpbmdUb2tlbikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IHRyaW0gc3BhY2VzIGJlZm9yZSB0cmFpbGluZyBzYW1lLWxpbmUgY29tbWVudHMuIFRoaXMgaXMgYSBzdHlsaXN0aWMgY2hvaWNlXG4gICAgICAgIC8vIHNvIHRoYXRcbiAgICAgICAgLy8gYGZvbyAleHh4YCBkb2VzIG5vdCBiZWNvbWUgYGZvbyV4eHhgLlxuICAgICAgICAvLyBUaGUgbGF0dGVyIGlzIHN0cmljdGx5IFwiY29ycmVjdFwiIGZvciBhIHRyaW0gZnVuY3Rpb24sIGJ1dCBpdCBpcyBwcmV0dGllciB0byBmb3JtYXRcbiAgICAgICAgLy8gY29kZSBwcmVzZXJ2aW5nIHRoZSBzcGFjZSBiZWZvcmUgdGhlIHNhbWVsaW5lIGNvbW1lbnRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbWF0Y2guY29tbWVudCh0cmFpbGluZ1Rva2VuKSAmJlxuICAgICAgICAgICAgdHJhaWxpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSAmJlxuICAgICAgICAgICAgIXRyYWlsaW5nVG9rZW4uc2FtZWxpbmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmFpbGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdHJhaWxpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRyaW1tZWRFbmQ6IGVuZCB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3aGl0ZXNwYWNlL3BhcmJyZWFrIG5vZGVzIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2UoYXN0OiBBc3QuTm9kZVtdKToge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59IHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhc3QpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHwgbWF0Y2gucGFyYnJlYWsobm9kZSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gYXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kOiAwIH07XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgcGFkZGluZyBvbiB0aGUgcmlnaHRcbiAgICBmb3IgKGxldCBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhc3RbaV07XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLnBhcmJyZWFrKG5vZGUpKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuIiwiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcInVuaWZpZWRcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcbmltcG9ydCB7IHRyaW0sIHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuL3RyaW1cIjtcblxudHlwZSBQbHVnaW5PcHRpb25zID0gdm9pZDtcblxuLyoqXG4gKiBVbmlmaWVkIHBsdWdpbiB0byB0cmltIHRoZSB3aGl0ZXNwYWNlIGZyb20gdGhlIHN0YXJ0L2VuZCBvZiBhbnkgZW52aXJvbm1lbnRzLCBpbmNsdWRpbmdcbiAqIG1hdGggZW52aXJvbm1lbnRzLlxuICovXG5leHBvcnQgY29uc3QgdW5pZmllZExhdGV4VHJpbUVudmlyb25tZW50Q29udGVudHM6IFBsdWdpbjxcbiAgICBQbHVnaW5PcHRpb25zW10sXG4gICAgQXN0LlJvb3QsXG4gICAgQXN0LlJvb3Rcbj4gPSBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltRW52aXJvbm1lbnRDb250ZW50cygpIHtcbiAgICByZXR1cm4gKHRyZWUpID0+IHtcbiAgICAgICAgdmlzaXQodHJlZSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKG1hdGNoLm1hdGgobm9kZSkgfHwgbWF0Y2guYW55RW52aXJvbm1lbnQobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgdGhpbmcgaW4gdGhlIGVudmlyb25tZW50IGlzIGEgc2FtZWxpbmUgY29tbWVudCxcbiAgICAgICAgICAgIC8vIHdlIGFjdHVhbGx5IHdhbnQgdG8gc3RhcnQgdHJpbW1pbmcgKmFmdGVyKiBpdC5cbiAgICAgICAgICAgIGxldCBmaXJzdE5vZGUgPSBub2RlLmNvbnRlbnRbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2guY29tbWVudChmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zdWZmaXhQYXJicmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyaW1FbmQobm9kZS5jb250ZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHBsYXkgYSBuYXN0eSB0cmljayBoZXJlLiBUaGlzIGNhbGwgdG8gYHRyaW1TdGFydGBcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGFjdHVhbGx5IG1vZGlmeSBgbm9kZS5jb250ZW50YCBpZiBgbm9kZS5jb250ZW50LnNsaWNlKDEpYCBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGEgY29tbWVudCB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UgKGl0IHdpbGwgcmVtb3ZlIHRoYXQgd2hpdGVzcGFjZSkuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaXQgd29uJ3QgcmVtb3ZlIGFueSBlbGVtZW50cyBmcm9tIGBub2RlLmNvbnRlbnRgOyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gZG8gdGhhdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2RlLmNvbnRlbnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudC5zcGxpY2UoMSwgdHJpbW1lZFN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpbShub2RlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHRyaW0gfSBmcm9tIFwiLi90cmltXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHZvaWQ7XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydC9lbmQgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFRyaW1Sb290OiBQbHVnaW48UGx1Z2luT3B0aW9uc1tdLCBBc3QuUm9vdCwgQXN0LlJvb3Q+ID1cbiAgICBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgICAgICB0cmltKHRyZWUuY29udGVudCk7XG4gICAgICAgIH07XG4gICAgfTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdmlzaXRcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byB0cmF2ZXJzZSBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS4gYHZpc2l0YCBpc1xuICogdmVyeSBzaW1pbGFyIHRvIFtlc3RyZWUtdXRpbC12aXNpdF0oaHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2VzdHJlZS11dGlsLXZpc2l0KS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJlcGxhY2UgcGFydGljdWxhciBBU1Qgbm9kZXMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogTGlzdCBhbGwgcHJvcHMgb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IHNob3VsZCBiZSBwcm9jZXNzZWRcbiAqIGluIG1hdGggbW9kZSBvciBub3QgaW4gbWF0aCBtb2RlLiBJZiBtYXRoIG1vZGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbm9kZSdzIHJlbmRlclxuICogaW5mbywgZW1wdHkgbGlzdHMgYXJlIHJldHVybmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGBcXHRleHR7Zm9vfWAgd2lsbCByZXBvcnQgdGhhdCBgYXJnc2Agc2hvdWxkICpub3QqIGJlIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUsXG4gKiBzaW5jZSBpdCdzIGNvbnRlbnRzIHNob3VsZCBhbHdheXMgYmUgcHJvY2Vzc2VkIGluIHRleHQgbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNYXRoQ2hpbGRyZW4obm9kZTogQXN0LkFzdCk6IHtcbiAgICBlbnRlcjogc3RyaW5nW107XG4gICAgbGVhdmU6IHN0cmluZ1tdO1xufSB7XG4gICAgY29uc3QgTlVMTF9SRVRVUk4gPSB7IGVudGVyOiBbXSwgbGVhdmU6IFtdIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWF0aChub2RlKSkge1xuICAgICAgICAvLyBXaGVuIHdlIGVudGVyIGEgbWF0aCBlbnZpcm9ubWVudCwgb3VyIGNvbnRlbnQgaXMgYWx3YXlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgbWF0aCBtb2RlXG4gICAgICAgIHJldHVybiB7IGVudGVyOiBbXCJjb250ZW50XCJdLCBsZWF2ZTogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJJbmZvOiB7IGluTWF0aE1vZGU/OiBib29sZWFuIH0gPSBub2RlLl9yZW5kZXJJbmZvIHx8IHt9O1xuICAgIGlmIChyZW5kZXJJbmZvLmluTWF0aE1vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTlVMTF9SRVRVUk47XG4gICAgfVxuICAgIGlmIChtYXRjaC5tYWNybyhub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiYXJnc1wiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiYXJnc1wiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaC5lbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW10sIGxlYXZlOiBbXCJjb250ZW50XCJdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfUkVUVVJOO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBsaXN0TWF0aENoaWxkcmVuIH0gZnJvbSBcIi4vbGlzdC1tYXRoLWNoaWxkcmVuXCI7XG5cbmV4cG9ydCB0eXBlIFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBub2RlIGlzIGEgZGlyZWN0b3Igb3IgaW5kaXJlY3QgY2hpbGRcbiAgICAgKiBvZiBhIG1hdGggZW52aXJvbm1lbnQgKGUuZy4gYCRhYmMkYCksIGJ1dCBub3Qgd2hlbiBhbiBlbnZpcm9ubWVudFxuICAgICAqIHJlLWVzdGFibGlzaGVzIHRleHQgbW9kZSAoZS5nLiBgJFxcdGV4dHthYmN9JGApXG4gICAgICovXG4gICAgaW5NYXRoTW9kZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbm9kZSBoYXMgYW55IGFuY2VzdG9yIHRoYXQgaXMgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKi9cbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgR2V0R3VhcmQ8VD4gPSBUIGV4dGVuZHMgKHg6IGFueSkgPT4geCBpcyBpbmZlciBSID8gUiA6IG5ldmVyO1xuLyoqXG4gKiBHZXRzIHRoZSB0eXBlIHRoYXQgYSB0eXBlLWd1YXJkIGZ1bmN0aW9uIGlzIGd1YXJkaW5nLiBJZlxuICogdGhlIGd1YXJkIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQsIHRoZSBpbnB1dCB0eXBlIGlzIHJldHVybmVkLlxuICovXG50eXBlIEd1YXJkVHlwZU9mPFQgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuPiA9IEdldEd1YXJkPFQ+IGV4dGVuZHMgbmV2ZXJcbiAgICA/IFQgZXh0ZW5kcyAoeDogaW5mZXIgQSkgPT4gYW55XG4gICAgICAgID8gQVxuICAgICAgICA6IG5ldmVyXG4gICAgOiBHZXRHdWFyZDxUPjtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZ3VhcmQgdHlwZSBmcm9tIHRoZSBgdGVzdGAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYVxuICogYFZpc2l0T3B0aW9uc2AgYXJndW1lbnQuXG4gKi9cbnR5cGUgR3VhcmRGcm9tT3B0aW9uczxcbiAgICBPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zLFxuICAgIFBvc3NpYmxlVHlwZXMgPSBBc3QuQXN0XG4+ID0gT3B0cyBleHRlbmRzIHtcbiAgICB0ZXN0OiBpbmZlciBSO1xufVxuICAgID8gUiBleHRlbmRzICh4OiBhbnkpID0+IGJvb2xlYW5cbiAgICAgICAgPyAvLyBBIGd1YXJkIGxpa2UgYHR5cGVvZiBBcnJheS5pc0FycmF5YCB3aWxsIHJldHVybiBgYW55W11gIGFzIHRoZSB0eXBlLlxuICAgICAgICAgIC8vIFRoaXMgdHlwZSBjYW5ub3QgYmUgbmFycm93ZWQsIHNvIGluc3RlYWQgd2UgdXNlIGl0IHRvIHBpY2sgZnJvbVxuICAgICAgICAgIC8vIHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHR5cGVzLlxuICAgICAgICAgIEV4dHJhY3Q8UG9zc2libGVUeXBlcywgR3VhcmRUeXBlT2Y8Uj4+XG4gICAgICAgIDogUG9zc2libGVUeXBlc1xuICAgIDogUG9zc2libGVUeXBlcztcblxuLyoqXG4gKiBOYXJyb3cgdGhlIHR5cGUgYFRgIGJhc2VkIG9uIHRoZSBgVmlzaXRPcHRpb25zYCBzdXBwbGllZC4gSWYgYHtpbmNsdWRlQXJyYXlzOiBmYWxzZX1gXG4gKiBpcyBzcGVjaWZpZWQgaW4gdGhlIGBWaXNpdE9wdGlvbnNgLCB0aGVuIGFycmF5cyBhcmUgZXhjbHVkZWQgZnJvbSBgVGAuXG4gKi9cbnR5cGUgTmFycm93QXJyYXlzQmFzZWRPbk9wdGlvbnM8VCwgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPSBPcHRzIGV4dGVuZHMge1xuICAgIGluY2x1ZGVBcnJheXM6IGluZmVyIEE7XG59XG4gICAgPyBBIGV4dGVuZHMgdHJ1ZVxuICAgICAgICA/IFRcbiAgICAgICAgOiBFeGNsdWRlPFQsIGFueVtdPlxuICAgIDogRXhjbHVkZTxULCBhbnlbXT47XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gdGhlIGBWaXNpdG9yYCBmdW5jdGlvbiBiYXNlZCBvbiB0aGVcbiAqIGBWaXNpdE9wdGlvbnNgIHRoYXQgYXJlIHN1cHBsaWVkLlxuICovXG50eXBlIFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPVxuICAgIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPEd1YXJkRnJvbU9wdGlvbnM8T3B0cz4sIE9wdHM+O1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFN5bWJvbChcImNvbnRpbnVlXCIpO1xuLyoqXG4gKiBEbyBub3QgdHJhdmVyc2UgdGhpcyBub2Rl4oCZcyBjaGlsZHJlblxuICovXG5leHBvcnQgY29uc3QgU0tJUCA9IFN5bWJvbChcInNraXBcIik7XG4vKipcbiAqIFN0b3AgdHJhdmVyc2luZyBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IFN5bWJvbChcImV4aXRcIik7XG5cbnR5cGUgQWN0aW9uID0gdHlwZW9mIENPTlRJTlVFIHwgdHlwZW9mIFNLSVAgfCB0eXBlb2YgRVhJVDtcbnR5cGUgSW5kZXggPSBudW1iZXI7XG50eXBlIEFjdGlvblR1cGxlID0gW0FjdGlvbl0gfCBbdHlwZW9mIFNLSVAsIEluZGV4XSB8IFt0eXBlb2YgQ09OVElOVUUsIEluZGV4XTtcblxuLyoqXG4gKiBBIHZpc2l0b3IgdGFrZXMgYSBgbm9kZWAsIGBrZXlgLCBgaW5kZXhgLCBhbmQgLi4uXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmVudCB0aGF0IHdlIHdlcmUgYWNjZXNzZWQgdGhyb3VnaC5cbiAqL1xudHlwZSBWaXNpdG9yPFQ+ID0gKFxuICAgIG5vZGU6IFQsXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pID0+IG51bGwgfCB1bmRlZmluZWQgfCBBY3Rpb24gfCBJbmRleCB8IEFjdGlvblR1cGxlIHwgdm9pZDtcbnR5cGUgVmlzaXRvcnM8VD4gPSB7IGVudGVyPzogVmlzaXRvcjxUPjsgbGVhdmU/OiBWaXNpdG9yPFQ+IH07XG5cbnR5cGUgVmlzaXRPcHRpb25zID0ge1xuICAgIHN0YXJ0aW5nQ29udGV4dD86IFZpc2l0b3JDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHR5cGVzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHRlc3Q/OiAobm9kZTogQXN0LkFzdCwgaW5mbzogVmlzaXRJbmZvKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXJyYXlzIHdpbGwgYmUgc2VudCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLiBJZiBmYWxzeSxcbiAgICAgKiBvbmx5IG5vZGVzIHdpbGwgYmUgcGFzdCB0byBgdmlzaXRvcmAuXG4gICAgICovXG4gICAgaW5jbHVkZUFycmF5cz86IGJvb2xlYW47XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFQ6IFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIGluTWF0aE1vZGU6IGZhbHNlLFxuICAgIGhhc01hdGhNb2RlQW5jZXN0b3I6IGZhbHNlLFxufTtcblxuZXhwb3J0IHR5cGUgVmlzaXRJbmZvID0ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCB2aWEgYW4gYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlIGtleSBpcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgaW5kZXggaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFuY2VzdG9yIG5vZGVzLCBgW3BhcmVudCwgZ3JhbmRwYXJlbnQsIGdyZWF0LWdyYW5kcGFyZW50LCAuLi5dYFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBhcmVudHM6IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgaW4gYW4gYXJyYXksIHRoZSBhcnJheSB0aGF0IGl0IGlzIHBhcnQgb2YuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGFpbmluZ0FycmF5OiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIExhVGVYIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogVmlzaXRvckNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFZpc2l0IGNoaWxkcmVuIG9mIHRyZWUgd2hpY2ggcGFzcyBhIHRlc3RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWUgQWJzdHJhY3Qgc3ludGF4IHRyZWUgdG8gd2Fsa1xuICogQHBhcmFtIHtWaXNpdG9yfFZpc2l0b3JzfSBbdmlzaXRvcl0gRnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0PE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+KFxuICAgIHRyZWU6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjpcbiAgICAgICAgfCBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+XG4gICAgICAgIHwgVmlzaXRvcnM8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4sXG4gICAgb3B0aW9ucz86IE9wdHNcbikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRpbmdDb250ZXh0ID0gREVGQVVMVF9DT05URVhULFxuICAgICAgICB0ZXN0ID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUFycmF5cyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCBlbnRlcjogVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PiB8IHVuZGVmaW5lZDtcbiAgICBsZXQgbGVhdmU6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3I7XG4gICAgfSBlbHNlIGlmICh2aXNpdG9yICYmIHR5cGVvZiB2aXNpdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVudGVyID0gdmlzaXRvci5lbnRlcjtcbiAgICAgICAgbGVhdmUgPSB2aXNpdG9yLmxlYXZlO1xuICAgIH1cblxuICAgIHdhbGsodHJlZSwge1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyZW50czogW10sXG4gICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB7IC4uLnN0YXJ0aW5nQ29udGV4dCB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IHBhcmVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YWxrKFxuICAgICAgICBub2RlOiBBc3QuQXN0LFxuICAgICAgICB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9OiBWaXNpdEluZm9cbiAgICApOiBBY3Rpb25UdXBsZSB7XG4gICAgICAgIGNvbnN0IG5vZGVQYXNzZXNUZXN0ID0gaW5jbHVkZUFycmF5c1xuICAgICAgICAgICAgPyB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pXG4gICAgICAgICAgICA6ICFBcnJheS5pc0FycmF5KG5vZGUpICYmXG4gICAgICAgICAgICAgIHRlc3Qobm9kZSwgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBY3Rpb25UdXBsZSA9XG4gICAgICAgICAgICBlbnRlciAmJiBub2RlUGFzc2VzVGVzdFxuICAgICAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgICAgZW50ZXIobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBbQ09OVElOVUVdO1xuXG4gICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBTS0lQKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGxlYXZlKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgdmFsdWVgIGFycmF5IG1pZ2h0IGJlIG1vZGlmaWVkIGluIHBsYWNlIGFzIHdlIHRyYXZlcnNlIGl0LCBzb1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgdHJhZGl0aW9uYWwgZm9yIGxvb3AuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ID4gLTEgJiYgaW5kZXggPCBub2RlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5OiBub2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvciBsb29wIHdpbGwgaW5jcmVtZW50IGkgZXZlcnkgcGFzcy4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5kZXggd2FzIHJldHVybmVkLCB0aGF0J3Mgd2hlcmUgd2Ugd2FudCB0byBzdGFydCBuZXh0IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0WzFdIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIHRoZSBgY29udGVudGBcbiAgICAgICAgICAgIC8vIG9mIGFsbCB0eXBlcyAoZS5nLiwgY29tbWVudHMgYW5kIG1hY3JvcyksIHNvIHNwZWNpZnlcbiAgICAgICAgICAgIC8vIGEgYmxhY2tsaXN0LlxuICAgICAgICAgICAgbGV0IGNoaWxkUHJvcHM6IChcImNvbnRlbnRcIiB8IFwiYXJnc1wiKVtdID0gW1wiY29udGVudFwiLCBcImFyZ3NcIl07XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gW1wiYXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWF0aE1vZGVQcm9wcyA9IGxpc3RNYXRoQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleSBhcyBrZXlvZiB0eXBlb2Ygbm9kZV0gYXNcbiAgICAgICAgICAgICAgICAgICAgfCBBc3QuQXN0XG4gICAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYW5kcGFyZW50cyA9IFtub2RlXS5jb25jYXQocGFyZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgc3dpdGNoIGluL291dCBvZiBtYXRoIG1vZGUgYXMgd2UgcGFzcyB0byBub2RlW2tleV1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0geyAuLi5jb250ZXh0IH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhNb2RlUHJvcHMuZW50ZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0aE1vZGVQcm9wcy5sZWF2ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuaW5NYXRoTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbGsodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBncmFuZHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG5ld0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYSByZXN1bHQgaXMgYW4gYEFjdGlvblR1cGxlYHNcbiAqL1xuZnVuY3Rpb24gdG9SZXN1bHQoXG4gICAgdmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZVxuKTogQWN0aW9uVHVwbGUge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbQ09OVElOVUVdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt2YWx1ZV07XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvZGVsZXRlLWNvbW1lbnRzXCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gaGVscCBtb2RpZnkgY29tbWVudHMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBwcm9jZXNzIGNvbW1lbnRzIGluIGEgYHVuaWZpZWQtbGF0ZXhgIEFTVC5cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9