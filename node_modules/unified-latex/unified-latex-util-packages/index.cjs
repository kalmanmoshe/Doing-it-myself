/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-packages/libs/arguments.ts":
/*!*******************************************************!*\
  !*** ./unified-latex-util-packages/libs/arguments.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "processCommaSeparatedList": () => (/* binding */ processCommaSeparatedList)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");


function stripComments(nodes) {
    return nodes.filter((node) => node.type !== "comment");
}
function trimWithReturn(nodes) {
    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__.trim)(nodes);
    return nodes;
}
/**
 * Split a list of nodes on a comma
 */
function splitOnComma(nodes) {
    const ret = [];
    let curr = [];
    for (const node of stripComments(nodes)) {
        if (node.type === "string" && node.content === ",") {
            ret.push(curr);
            curr = [];
        }
        else {
            curr.push(node);
        }
    }
    if (curr.length > 0) {
        ret.push(curr);
    }
    return ret.map(trimWithReturn);
}
/**
 * Convert a list of nodes to string node, taking care to preserve the start and end
 * position of those nodes.
 */
function nodesToString(nodes) {
    var _a, _b;
    if (nodes.length === 0) {
        return { type: "string", content: "" };
    }
    if (nodes.length === 1 && nodes[0].type === "string") {
        return nodes[0];
    }
    // We are going to return a new string, but we wan to preserve
    // the start and end bounds.
    const start = (_a = nodes[0].position) === null || _a === void 0 ? void 0 : _a.start;
    const end = (_b = nodes[nodes.length - 1].position) === null || _b === void 0 ? void 0 : _b.end;
    const ret = { type: "string", content: (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(nodes) };
    if (start && end) {
        Object.assign(ret, { position: { start, end } });
    }
    return ret;
}
/**
 * Process a list of nodes that should be comma-separated. The result
 * will be a list of `Ast.String` nodes. The start/end position of
 * these nodes is preserved.
 */
function processCommaSeparatedList(nodes) {
    return splitOnComma(nodes).map(nodesToString);
}


/***/ }),

/***/ "./unified-latex-util-packages/libs/list-packages.ts":
/*!***********************************************************!*\
  !*** ./unified-latex-util-packages/libs/list-packages.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listPackages": () => (/* binding */ listPackages)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _arguments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arguments */ "./unified-latex-util-packages/libs/arguments.ts");



const isUseOrRequirePackageMacro = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.createMacroMatcher([
    "usepackage",
    "RequirePackage",
]);
/**
 * List all packages referenced via `\includepackage{...}` or `\RequirePackage{...}`
 *
 * @param {Ast.Ast} tree
 * @returns {string[]}
 */
function listPackages(tree) {
    const ret = [];
    (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
        if (node.content === "usepackage") {
            // The \usepackage macro has signature []{}
            const packages = (0,_arguments__WEBPACK_IMPORTED_MODULE_2__.processCommaSeparatedList)(node.args ? node.args[1].content : []);
            ret.push(...packages);
        }
        if (node.content === "RequirePackage") {
            // The \RequirePackage macro has signature []{}
            const packages = (0,_arguments__WEBPACK_IMPORTED_MODULE_2__.processCommaSeparatedList)(node.args ? node.args[1].content : []);
            ret.push(...packages);
        }
    }, { test: isUseOrRequirePackageMacro });
    return ret;
}


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-trim/index.ts":
/*!******************************************!*\
  !*** ./unified-latex-util-trim/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* reexport safe */ _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__.hasWhitespaceEquivalent),
/* harmony export */   "trim": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trim),
/* harmony export */   "trimEnd": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd),
/* harmony export */   "trimStart": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart),
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* reexport safe */ _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexTrimEnvironmentContents),
/* harmony export */   "unifiedLatexTrimRoot": () => (/* reexport safe */ _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__.unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _libs_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/trim */ "./unified-latex-util-trim/libs/trim.ts");
/* harmony import */ var _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-trim-environment-contents */ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts");
/* harmony import */ var _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unified-latex-trim-root */ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts");
/* harmony import */ var _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/has-whitespace-equivalent */ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to remove whitespace from the ends of an array of nodes.
 *
 * Note that whitespace can come from a `Ast.Whitespace` node or from an
 * `Ast.Comment` node that has leading whitespace. These functions take care
 * to deal with both situations.
 */


/***/ }),

/***/ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts":
/*!*******************************************************************!*\
  !*** ./unified-latex-util-trim/libs/has-whitespace-equivalent.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* binding */ hasWhitespaceEquivalent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`
 * are counted as whitespace. Other comments are ignored.
 */
function hasWhitespaceEquivalent(nodes) {
    let start = false;
    let end = false;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            // A comment with leading whitespace will render with leading whitespace,
            // so if we encounter one, we should consider ourselves to have leading whitespace.
            if (node.leadingWhitespace) {
                start = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            start = true;
        }
        break;
    }
    for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            if (node.leadingWhitespace) {
                end = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            end = true;
        }
        break;
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/trim.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-trim/libs/trim.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "trimEnd": () => (/* binding */ trimEnd),
/* harmony export */   "trimStart": () => (/* binding */ trimStart)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Trims whitespace and parbreaks from the start and end
 * of an array. The number of trimmed nodes is returned.
 * Special care is taken to preserve comments, though any whitespace
 * before the first comment(s) or after the last comment(s) is trimmed.
 */
function trim(nodes) {
    if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
}
/**
 * Trim whitespace and parbreaks from the left of an array.
 */
function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    // If there are comments at the start, they might have leading whitespace.
    // This leading whitespace should be trimmed
    for (const leadingToken of nodes) {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(leadingToken)) {
            break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
            // We remove the position information from this token to indicate that we've edited it
            delete leadingToken.position;
        }
        // Special care must be taken. If the comment was on the same line as a
        // parskip, it will no longer be on the same line after the trimming.
        // Thus, we must modify the comment.
        if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
            delete leadingToken.position;
        }
    }
    return { trimmedStart: start };
}
/**
 * Trim whitespace and parbreaks from the right of an array.
 */
function trimEnd(nodes) {
    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end, end);
    // Trim off any spaces belonging to trailing comments
    for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken)) {
            break;
        }
        // We don't trim spaces before trailing same-line comments. This is a stylistic choice
        // so that
        // `foo %xxx` does not become `foo%xxx`.
        // The latter is strictly "correct" for a trim function, but it is prettier to format
        // code preserving the space before the sameline comment
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken) &&
            trailingToken.leadingWhitespace &&
            !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
            delete trailingToken.position;
        }
    }
    return { trimmedEnd: end };
}
/**
 * Returns the number of whitespace/parbreak nodes at the start and end of an array.
 */
function amountOfLeadingAndTrailingWhitespace(ast) {
    let start = 0;
    let end = 0;
    for (const node of ast) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            start++;
        }
        else {
            break;
        }
    }
    if (start === ast.length) {
        return { start, end: 0 };
    }
    // Find the padding on the right
    for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            end++;
        }
        else {
            break;
        }
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* binding */ unifiedLatexTrimEnvironmentContents)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");



/**
 * Unified plugin to trim the whitespace from the start/end of any environments, including
 * math environments.
 */
const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents() {
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
            if (!(_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.anyEnvironment(node))) {
                return;
            }
            // If the first thing in the environment is a sameline comment,
            // we actually want to start trimming *after* it.
            let firstNode = node.content[0];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(firstNode) && firstNode.sameline) {
                firstNode.suffixParbreak = false;
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(node.content);
                // We play a nasty trick here. This call to `trimStart`
                // will actually modify `node.content` if `node.content.slice(1)` starts
                // with a comment that has leading whitespace (it will remove that whitespace).
                // However, it won't remove any elements from `node.content`; we need
                // to do that ourselves.
                const { trimmedStart } = (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(node.content.slice(1));
                node.content.splice(1, trimmedStart);
            }
            else {
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(node.content);
            }
        });
    };
};


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts":
/*!*****************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-root.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimRoot": () => (/* binding */ unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");

/**
 * Unified plugin to trim the whitespace from the start/end of the root element.
 */
const unifiedLatexTrimRoot = function unifiedLatexTrimRoot() {
    return (tree) => {
        (0,_trim__WEBPACK_IMPORTED_MODULE_0__.trim)(tree.content);
    };
};


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this node’s children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************************************!*\
  !*** ./unified-latex-util-packages/index.ts ***!
  \**********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listPackages": () => (/* reexport safe */ _libs_list_packages__WEBPACK_IMPORTED_MODULE_0__.listPackages)
/* harmony export */ });
/* harmony import */ var _libs_list_packages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/list-packages */ "./unified-latex-util-packages/libs/list-packages.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions for reporting on imported packages in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you are building a linter or some other system that needs to know which packages have been included
 * via `\usepackage{...}` or `\RequirePackage{...}`.
 */

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDM0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuQixDQUFDOzs7Ozs7O1NDblVEO1NBQ0E7O1NBRUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7O1NBRUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7Ozs7O1VDdEJBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7O1VDQUE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7Ozs7Ozs7Ozs7Ozs7QUNOcUM7QUFFckMsMEVBQTBFO0FBQzFFOzs7Ozs7Ozs7R0FTRyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9saWJzL21hdGNoLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcGFja2FnZXMvbGlicy9hcmd1bWVudHMudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wYWNrYWdlcy9saWJzL2xpc3QtcGFja2FnZXMudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvbGlicy9wcmludC1yYXcudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL2hhcy13aGl0ZXNwYWNlLWVxdWl2YWxlbnQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdHJpbS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXRyaW0vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHMudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3QudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvbGlzdC1tYXRoLWNoaWxkcmVuLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvbGlicy92aXNpdC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wYWNrYWdlcy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuL2xpYnMvbWF0Y2hcIjtcblxuZXhwb3J0IHsgbWF0Y2ggfTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgICBhbnlFbnZpcm9ubWVudCxcbiAgICBhbnlNYWNybyxcbiAgICBhbnlTdHJpbmcsXG4gICAgYXJndW1lbnQsXG4gICAgYmxhbmtBcmd1bWVudCxcbiAgICBjb21tZW50LFxuICAgIGVudmlyb25tZW50LFxuICAgIGdyb3VwLFxuICAgIG1hY3JvLFxuICAgIG1hdGgsXG4gICAgcGFyYnJlYWssXG4gICAgc3RyaW5nLFxuICAgIHdoaXRlc3BhY2UsXG59ID0gbWF0Y2g7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IGBBc3QuTm9kZWAgdHlwZXMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UgbmVlZCBhIHR5cGUtZ3VhcmQgdG8gZW5zdXJlIGEgbm9kZSBpcyBvZiBhIGNlcnRhaW4gdHlwZTsgZm9yIGV4YW1wbGUsIGR1cmluZyBhIGNhbGwgdG8gYHVuaWZpZWQtbGF0ZXgtdW50aWwtdmlzaXRgLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IEVudkluZm8sIE1hY3JvSW5mbywgTWFjcm9JbmZvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNyb01hdGNoZXIoXG4gICAgbWFjcm9zOiBBc3QuTWFjcm9bXSB8IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgbWFjcm9zSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IG1hY3Jvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHR5cGVvZiBtYWNyb3NbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8sIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjcm8uZXNjYXBlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXNjYXBlVG9rZW46IG1hY3JvLmVzY2FwZVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNyby5jb250ZW50LCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RNYWNyb3Mobm9kZTogYW55IHwgQXN0Lk1hY3JvKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS50eXBlICE9PSBcIm1hY3JvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSBtYWNybyB0eXBlXG4gICAgICAgIGNvbnN0IHNwZWMgPSBtYWNyb3NIYXNoW25vZGUuY29udGVudF07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcIm9iamVjdFwiICYmIFwiZXNjYXBlVG9rZW5cIiBpbiBzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT09IG5vZGUuZXNjYXBlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5NYWNybz47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyKG1hY3Jvczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgZW52aXJvbm1lbnRzSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgbWFjcm9zLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N0ciwge31dIGFzIFtzdHJpbmcsIEVudkluZm9dO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0RW52aXJvbm1lbnRzKG5vZGU6IGFueSB8IEFzdC5FbnZpcm9ubWVudCkge1xuICAgICAgICBpZiAoIW1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuIGVudmlyb25tZW50IHR5cGVcbiAgICAgICAgY29uc3QgZW52TmFtZSA9IHByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgY29uc3Qgc3BlYyA9IGVudmlyb25tZW50c0hhc2hbZW52TmFtZV07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5FbnZpcm9ubWVudD47XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCB0eXBlcyBvZiBub2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0ge1xuICAgIG1hY3JvKG5vZGU6IGFueSwgbWFjcm9OYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJtYWNyb1wiICYmXG4gICAgICAgICAgICAobWFjcm9OYW1lID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSBtYWNyb05hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlNYWNybyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5tYWNybyhub2RlKTtcbiAgICB9LFxuICAgIGVudmlyb25tZW50KG5vZGU6IGFueSwgZW52TmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcImVudmlyb25tZW50XCIgfHwgbm9kZS50eXBlID09PSBcIm1hdGhlbnZcIikgJiZcbiAgICAgICAgICAgIChlbnZOYW1lID09IG51bGwgfHwgcHJpbnRSYXcobm9kZS5lbnYpID09PSBlbnZOYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55RW52aXJvbm1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICByZXR1cm4gbWF0Y2guZW52aXJvbm1lbnQobm9kZSk7XG4gICAgfSxcbiAgICBjb21tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkNvbW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gICAgfSxcbiAgICBwYXJicmVhayhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5QYXJicmVhayB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInBhcmJyZWFrXCI7XG4gICAgfSxcbiAgICB3aGl0ZXNwYWNlKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2Uge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VMaWtlKFxuICAgICAgICBub2RlOiBhbnlcbiAgICApOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHwgKEFzdC5Db21tZW50ICYgeyBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiB8fFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHN0cmluZyhub2RlOiBhbnksIHZhbHVlPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHZhbHVlID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueVN0cmluZyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICByZXR1cm4gbWF0Y2guc3RyaW5nKG5vZGUpO1xuICAgIH0sXG4gICAgZ3JvdXAobm9kZTogYW55KTogbm9kZSBpcyBBc3QuR3JvdXAge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJncm91cFwiO1xuICAgIH0sXG4gICAgYXJndW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQXJndW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJhcmd1bWVudFwiO1xuICAgIH0sXG4gICAgYmxhbmtBcmd1bWVudChub2RlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hcmd1bWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLm9wZW5NYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNsb3NlTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jb250ZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH0sXG4gICAgbWF0aChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5EaXNwbGF5TWF0aCB8IEFzdC5JbmxpbmVNYXRoIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZGlzcGxheW1hdGhcIiB8fCBub2RlLnR5cGUgPT09IFwiaW5saW5lbWF0aFwiO1xuICAgIH0sXG4gICAgY3JlYXRlTWFjcm9NYXRjaGVyLFxuICAgIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcixcbn07XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcbmltcG9ydCB7IHRyaW0gfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcblxuZnVuY3Rpb24gc3RyaXBDb21tZW50cyhub2RlczogQXN0Lk5vZGVbXSk6IEFzdC5Ob2RlW10ge1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUudHlwZSAhPT0gXCJjb21tZW50XCIpO1xufVxuXG5mdW5jdGlvbiB0cmltV2l0aFJldHVybihub2RlczogQXN0Lk5vZGVbXSkge1xuICAgIHRyaW0obm9kZXMpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBTcGxpdCBhIGxpc3Qgb2Ygbm9kZXMgb24gYSBjb21tYVxuICovXG5mdW5jdGlvbiBzcGxpdE9uQ29tbWEobm9kZXM6IEFzdC5Ob2RlW10pOiBBc3QuTm9kZVtdW10ge1xuICAgIGNvbnN0IHJldDogQXN0Lk5vZGVbXVtdID0gW107XG4gICAgbGV0IGN1cnI6IEFzdC5Ob2RlW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3RyaXBDb21tZW50cyhub2RlcykpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBub2RlLmNvbnRlbnQgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICByZXQucHVzaChjdXJyKTtcbiAgICAgICAgICAgIGN1cnIgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnIucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3Vyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldC5wdXNoKGN1cnIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQubWFwKHRyaW1XaXRoUmV0dXJuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbGlzdCBvZiBub2RlcyB0byBzdHJpbmcgbm9kZSwgdGFraW5nIGNhcmUgdG8gcHJlc2VydmUgdGhlIHN0YXJ0IGFuZCBlbmRcbiAqIHBvc2l0aW9uIG9mIHRob3NlIG5vZGVzLlxuICovXG5mdW5jdGlvbiBub2Rlc1RvU3RyaW5nKG5vZGVzOiBBc3QuTm9kZVtdKTogQXN0LlN0cmluZyB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCBjb250ZW50OiBcIlwiIH07XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgfVxuICAgIC8vIFdlIGFyZSBnb2luZyB0byByZXR1cm4gYSBuZXcgc3RyaW5nLCBidXQgd2Ugd2FuIHRvIHByZXNlcnZlXG4gICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgYm91bmRzLlxuICAgIGNvbnN0IHN0YXJ0ID0gbm9kZXNbMF0ucG9zaXRpb24/LnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLnBvc2l0aW9uPy5lbmQ7XG4gICAgY29uc3QgcmV0OiBBc3QuU3RyaW5nID0geyB0eXBlOiBcInN0cmluZ1wiLCBjb250ZW50OiBwcmludFJhdyhub2RlcykgfTtcbiAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmV0LCB7IHBvc2l0aW9uOiB7IHN0YXJ0LCBlbmQgfSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgbGlzdCBvZiBub2RlcyB0aGF0IHNob3VsZCBiZSBjb21tYS1zZXBhcmF0ZWQuIFRoZSByZXN1bHRcbiAqIHdpbGwgYmUgYSBsaXN0IG9mIGBBc3QuU3RyaW5nYCBub2Rlcy4gVGhlIHN0YXJ0L2VuZCBwb3NpdGlvbiBvZlxuICogdGhlc2Ugbm9kZXMgaXMgcHJlc2VydmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NvbW1hU2VwYXJhdGVkTGlzdChub2RlczogQXN0Lk5vZGVbXSk6IEFzdC5TdHJpbmdbXSB7XG4gICAgcmV0dXJuIHNwbGl0T25Db21tYShub2RlcykubWFwKG5vZGVzVG9TdHJpbmcpO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdFwiO1xuaW1wb3J0IHsgcHJvY2Vzc0NvbW1hU2VwYXJhdGVkTGlzdCB9IGZyb20gXCIuL2FyZ3VtZW50c1wiO1xuXG5jb25zdCBpc1VzZU9yUmVxdWlyZVBhY2thZ2VNYWNybyA9IG1hdGNoLmNyZWF0ZU1hY3JvTWF0Y2hlcihbXG4gICAgXCJ1c2VwYWNrYWdlXCIsXG4gICAgXCJSZXF1aXJlUGFja2FnZVwiLFxuXSk7XG5cbi8qKlxuICogTGlzdCBhbGwgcGFja2FnZXMgcmVmZXJlbmNlZCB2aWEgYFxcaW5jbHVkZXBhY2thZ2V7Li4ufWAgb3IgYFxcUmVxdWlyZVBhY2thZ2V7Li4ufWBcbiAqXG4gKiBAcGFyYW0ge0FzdC5Bc3R9IHRyZWVcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RQYWNrYWdlcyh0cmVlOiBBc3QuQXN0KTogQXN0LlN0cmluZ1tdIHtcbiAgICBjb25zdCByZXQ6IEFzdC5TdHJpbmdbXSA9IFtdO1xuICAgIHZpc2l0KFxuICAgICAgICB0cmVlLFxuICAgICAgICAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudCA9PT0gXCJ1c2VwYWNrYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgXFx1c2VwYWNrYWdlIG1hY3JvIGhhcyBzaWduYXR1cmUgW117fVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VzID0gcHJvY2Vzc0NvbW1hU2VwYXJhdGVkTGlzdChcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmdzID8gbm9kZS5hcmdzWzFdLmNvbnRlbnQgOiBbXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goLi4ucGFja2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudCA9PT0gXCJSZXF1aXJlUGFja2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFxcUmVxdWlyZVBhY2thZ2UgbWFjcm8gaGFzIHNpZ25hdHVyZSBbXXt9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2FnZXMgPSBwcm9jZXNzQ29tbWFTZXBhcmF0ZWRMaXN0KFxuICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3MgPyBub2RlLmFyZ3NbMV0uY29udGVudCA6IFtdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXQucHVzaCguLi5wYWNrYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgdGVzdDogaXNVc2VPclJlcXVpcmVQYWNrYWdlTWFjcm8gfVxuICAgICk7XG5cbiAgICByZXR1cm4gcmV0O1xufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9wcmludC1yYXdcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBwcmludCBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKSB0byBhIHN0cmluZy5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIGRpcmVjdGx5IHByaW50IGFuIGBBc3QuQXN0YCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcgb3IgZm9ybWF0dGluZy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbnR5cGUgUHJpbnRhYmxlID0gQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCBzdHJpbmc7XG50eXBlIFByaW50VG9rZW4gPSBzdHJpbmcgfCB0eXBlb2YgbGluZWJyZWFrO1xuXG5leHBvcnQgY29uc3QgbGluZWJyZWFrID0gU3ltYm9sKFwibGluZWJyZWFrXCIpO1xuY29uc3QgRVNDQVBFID0gXCJcXFxcXCI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGFuIGFycmF5IGluc2VydGluZyBgbGluZWJyZWFrYCB3aGVyZSBuZWVkZWQ7XG4gKiBUaGlzIGFycmF5IG1heSBiZSBuZXN0ZWQuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKi9cbmZ1bmN0aW9uIF9wcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSk6IFByaW50VG9rZW5bXSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAoW10gYXMgUHJpbnRUb2tlbltdKS5jb25jYXQoXG4gICAgICAgICAgICAuLi5ub2RlLm1hcCgobjogUHJpbnRhYmxlKSA9PiBfcHJpbnRSYXcobikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIHRtcCB2YXJpYWJsZXNcbiAgICBsZXQgYXJnc1N0cmluZywgZXNjYXBlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICByZXR1cm4gX3ByaW50UmF3KG5vZGUuY29udGVudCk7XG4gICAgICAgIGNhc2UgXCJhcmd1bWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLm9wZW5NYXJrLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgbm9kZS5jbG9zZU1hcmtdO1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG5vZGUuc3VmZml4UGFyYnJlYWsgPyBcIlwiIDogbGluZWJyZWFrO1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyBpdHMgb3duIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICBzdWZmaXgsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBcIiVcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIHN1ZmZpeF07XG4gICAgICAgIGNhc2UgXCJlbnZpcm9ubWVudFwiOlxuICAgICAgICBjYXNlIFwibWF0aGVudlwiOlxuICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgIHZhciBlbnYgPSBfcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICAgICAgdmFyIGVudlN0YXJ0OiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJiZWdpbntcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICB2YXIgZW52RW5kOiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJlbmR7XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgYXJnc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgKG5vZGUgYXMgYW55KS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdygobm9kZSBhcyBhbnkpLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5lbnZTdGFydCxcbiAgICAgICAgICAgICAgICAuLi5hcmdzU3RyaW5nLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIC4uLmVudkVuZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJkaXNwbGF5bWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtFU0NBUEUgKyBcIltcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIEVTQ0FQRSArIFwiXVwiXTtcbiAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wie1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCJ9XCJdO1xuICAgICAgICBjYXNlIFwiaW5saW5lbWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiRcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwiJFwiXTtcbiAgICAgICAgY2FzZSBcIm1hY3JvXCI6XG4gICAgICAgICAgICBhcmdzU3RyaW5nID0gbm9kZS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdyhub2RlLmFyZ3MpO1xuICAgICAgICAgICAgZXNjYXBlID0gbm9kZS5lc2NhcGVUb2tlbiA9PSBudWxsID8gRVNDQVBFIDogbm9kZS5lc2NhcGVUb2tlbjtcbiAgICAgICAgICAgIHJldHVybiBbZXNjYXBlLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgLi4uYXJnc1N0cmluZ107XG4gICAgICAgIGNhc2UgXCJwYXJicmVha1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIGxpbmVicmVha107XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5jb250ZW50XTtcbiAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRVNDQVBFLFxuICAgICAgICAgICAgICAgIG5vZGUuZW52LFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIgXCJdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmluZCByZW5kZXIgZm9yIG5vZGUgXCIsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBgKG9mIHR5cGUgJHt0eXBlb2Ygbm9kZX0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBbXCJcIiArIG5vZGVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHsqfSBvcHRpb25zIC0gU2V0dGluZyBgYXNBcnJheWAgdG8gYHRydWVgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRoZSBzeW1ib2wgYGxpbmVicmVha2AsIHNvIHRoYXQgcHJpbnRpbmcgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zPzogeyBhc0FycmF5OiBmYWxzZSB9XG4pOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9uczogeyBhc0FycmF5OiB0cnVlIH1cbik6IFByaW50VG9rZW5bXTtcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSwgb3B0aW9ucz86IG9iamVjdCk6IGFueSB7XG4gICAgY29uc3QgYXNBcnJheSA9IG9wdGlvbnMgIT0gbnVsbCA/IChvcHRpb25zIGFzIGFueSkuYXNBcnJheSA6IGZhbHNlO1xuICAgIGNvbnN0IHByaW50ZWRUb2tlbnMgPSBfcHJpbnRSYXcobm9kZSk7XG4gICAgaWYgKGFzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHByaW50ZWRUb2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBwcmludGVkVG9rZW5zLm1hcCgoeCkgPT4gKHggPT09IGxpbmVicmVhayA/IFwiXFxuXCIgOiB4KSkuam9pbihcIlwiKTtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdHJpbVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvaGFzLXdoaXRlc3BhY2UtZXF1aXZhbGVudFwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgbW9kaWZ5IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kcyBvZiBhbiBhcnJheSBvZiBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgd2hpdGVzcGFjZSBjYW4gY29tZSBmcm9tIGEgYEFzdC5XaGl0ZXNwYWNlYCBub2RlIG9yIGZyb20gYW5cbiAqIGBBc3QuQ29tbWVudGAgbm9kZSB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UuIFRoZXNlIGZ1bmN0aW9ucyB0YWtlIGNhcmVcbiAqIHRvIGRlYWwgd2l0aCBib3RoIHNpdHVhdGlvbnMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBhcnJheSBoYXMgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnQvZW5kLiBDb21tZW50cyB3aXRoIGBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZWBcbiAqIGFyZSBjb3VudGVkIGFzIHdoaXRlc3BhY2UuIE90aGVyIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzV2hpdGVzcGFjZUVxdWl2YWxlbnQobm9kZXM6IEFzdC5Ob2RlW10pOiB7XG4gICAgc3RhcnQ6IGJvb2xlYW47XG4gICAgZW5kOiBib29sZWFuO1xufSB7XG4gICAgbGV0IHN0YXJ0ID0gZmFsc2U7XG4gICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHdpbGwgcmVuZGVyIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLFxuICAgICAgICAgICAgLy8gc28gaWYgd2UgZW5jb3VudGVyIG9uZSwgd2Ugc2hvdWxkIGNvbnNpZGVyIG91cnNlbHZlcyB0byBoYXZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IG5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgaWYgKG1hdGNoLmNvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG4vKipcbiAqIFRyaW1zIHdoaXRlc3BhY2UgYW5kIHBhcmJyZWFrcyBmcm9tIHRoZSBzdGFydCBhbmQgZW5kXG4gKiBvZiBhbiBhcnJheS4gVGhlIG51bWJlciBvZiB0cmltbWVkIG5vZGVzIGlzIHJldHVybmVkLlxuICogU3BlY2lhbCBjYXJlIGlzIHRha2VuIHRvIHByZXNlcnZlIGNvbW1lbnRzLCB0aG91Z2ggYW55IHdoaXRlc3BhY2VcbiAqIGJlZm9yZSB0aGUgZmlyc3QgY29tbWVudChzKSBvciBhZnRlciB0aGUgbGFzdCBjb21tZW50KHMpIGlzIHRyaW1tZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKG5vZGVzOiBBc3QuTm9kZVtdKToge1xuICAgIHRyaW1tZWRTdGFydDogbnVtYmVyO1xuICAgIHRyaW1tZWRFbmQ6IG51bWJlcjtcbn0ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIHRyaW0gYSBub24tYXJyYXkgYXN0XCIsIG5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgdHJpbW1lZFN0YXJ0IH0gPSB0cmltU3RhcnQobm9kZXMpO1xuICAgIGNvbnN0IHsgdHJpbW1lZEVuZCB9ID0gdHJpbUVuZChub2Rlcyk7XG5cbiAgICByZXR1cm4geyB0cmltbWVkU3RhcnQsIHRyaW1tZWRFbmQgfTtcbn1cblxuLyoqXG4gKiBUcmltIHdoaXRlc3BhY2UgYW5kIHBhcmJyZWFrcyBmcm9tIHRoZSBsZWZ0IG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN0YXJ0KG5vZGVzOiBBc3QuTm9kZVtdKTogeyB0cmltbWVkU3RhcnQ6IG51bWJlciB9IHtcbiAgICBjb25zdCB7IHN0YXJ0IH0gPSBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2Uobm9kZXMpO1xuXG4gICAgbm9kZXMuc3BsaWNlKDAsIHN0YXJ0KTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBjb21tZW50cyBhdCB0aGUgc3RhcnQsIHRoZXkgbWlnaHQgaGF2ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgLy8gVGhpcyBsZWFkaW5nIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHRyaW1tZWRcbiAgICBmb3IgKGNvbnN0IGxlYWRpbmdUb2tlbiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQobGVhZGluZ1Rva2VuKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSB8fCBsZWFkaW5nVG9rZW4uc2FtZWxpbmUpIHtcbiAgICAgICAgICAgIGxlYWRpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgdG9rZW4gdG8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBlZGl0ZWQgaXRcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFkaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXJlIG11c3QgYmUgdGFrZW4uIElmIHRoZSBjb21tZW50IHdhcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGFcbiAgICAgICAgLy8gcGFyc2tpcCwgaXQgd2lsbCBubyBsb25nZXIgYmUgb24gdGhlIHNhbWUgbGluZSBhZnRlciB0aGUgdHJpbW1pbmcuXG4gICAgICAgIC8vIFRodXMsIHdlIG11c3QgbW9kaWZ5IHRoZSBjb21tZW50LlxuICAgICAgICBpZiAoc3RhcnQgPiAwICYmIGxlYWRpbmdUb2tlbi5zYW1lbGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ1Rva2VuLnNhbWVsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgbGVhZGluZ1Rva2VuLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJpbW1lZFN0YXJ0OiBzdGFydCB9O1xufVxuXG4vKipcbiAqIFRyaW0gd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIHJpZ2h0IG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUVuZChub2RlczogQXN0Lk5vZGVbXSk6IHsgdHJpbW1lZEVuZDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgZW5kIH0gPSBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2Uobm9kZXMpO1xuXG4gICAgbm9kZXMuc3BsaWNlKG5vZGVzLmxlbmd0aCAtIGVuZCwgZW5kKTtcblxuICAgIC8vIFRyaW0gb2ZmIGFueSBzcGFjZXMgYmVsb25naW5nIHRvIHRyYWlsaW5nIGNvbW1lbnRzXG4gICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nVG9rZW4gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCFtYXRjaC5jb21tZW50KHRyYWlsaW5nVG9rZW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkb24ndCB0cmltIHNwYWNlcyBiZWZvcmUgdHJhaWxpbmcgc2FtZS1saW5lIGNvbW1lbnRzLiBUaGlzIGlzIGEgc3R5bGlzdGljIGNob2ljZVxuICAgICAgICAvLyBzbyB0aGF0XG4gICAgICAgIC8vIGBmb28gJXh4eGAgZG9lcyBub3QgYmVjb21lIGBmb28leHh4YC5cbiAgICAgICAgLy8gVGhlIGxhdHRlciBpcyBzdHJpY3RseSBcImNvcnJlY3RcIiBmb3IgYSB0cmltIGZ1bmN0aW9uLCBidXQgaXQgaXMgcHJldHRpZXIgdG8gZm9ybWF0XG4gICAgICAgIC8vIGNvZGUgcHJlc2VydmluZyB0aGUgc3BhY2UgYmVmb3JlIHRoZSBzYW1lbGluZSBjb21tZW50XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1hdGNoLmNvbW1lbnQodHJhaWxpbmdUb2tlbikgJiZcbiAgICAgICAgICAgIHRyYWlsaW5nVG9rZW4ubGVhZGluZ1doaXRlc3BhY2UgJiZcbiAgICAgICAgICAgICF0cmFpbGluZ1Rva2VuLnNhbWVsaW5lXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJhaWxpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHRyYWlsaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmltbWVkRW5kOiBlbmQgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2hpdGVzcGFjZS9wYXJicmVhayBub2RlcyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYW1vdW50T2ZMZWFkaW5nQW5kVHJhaWxpbmdXaGl0ZXNwYWNlKGFzdDogQXN0Lk5vZGVbXSk6IHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xufSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0KSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLnBhcmJyZWFrKG5vZGUpKSB7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IGFzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZDogMCB9O1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIHBhZGRpbmcgb24gdGhlIHJpZ2h0XG4gICAgZm9yIChsZXQgaSA9IGFzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBub2RlID0gYXN0W2ldO1xuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShub2RlKSB8fCBtYXRjaC5wYXJicmVhayhub2RlKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5pbXBvcnQgeyB0cmltLCB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi90cmltXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHZvaWQ7XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydC9lbmQgb2YgYW55IGVudmlyb25tZW50cywgaW5jbHVkaW5nXG4gKiBtYXRoIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFRyaW1FbnZpcm9ubWVudENvbnRlbnRzOiBQbHVnaW48XG4gICAgUGx1Z2luT3B0aW9uc1tdLFxuICAgIEFzdC5Sb290LFxuICAgIEFzdC5Sb290XG4+ID0gZnVuY3Rpb24gdW5pZmllZExhdGV4VHJpbUVudmlyb25tZW50Q29udGVudHMoKSB7XG4gICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgIHZpc2l0KHRyZWUsIChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShtYXRjaC5tYXRoKG5vZGUpIHx8IG1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IHRoaW5nIGluIHRoZSBlbnZpcm9ubWVudCBpcyBhIHNhbWVsaW5lIGNvbW1lbnQsXG4gICAgICAgICAgICAvLyB3ZSBhY3R1YWxseSB3YW50IHRvIHN0YXJ0IHRyaW1taW5nICphZnRlciogaXQuXG4gICAgICAgICAgICBsZXQgZmlyc3ROb2RlID0gbm9kZS5jb250ZW50WzBdO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmNvbW1lbnQoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdE5vZGUuc3VmZml4UGFyYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cmltRW5kKG5vZGUuY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBwbGF5IGEgbmFzdHkgdHJpY2sgaGVyZS4gVGhpcyBjYWxsIHRvIGB0cmltU3RhcnRgXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBhY3R1YWxseSBtb2RpZnkgYG5vZGUuY29udGVudGAgaWYgYG5vZGUuY29udGVudC5zbGljZSgxKWAgc3RhcnRzXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhIGNvbW1lbnQgdGhhdCBoYXMgbGVhZGluZyB3aGl0ZXNwYWNlIChpdCB3aWxsIHJlbW92ZSB0aGF0IHdoaXRlc3BhY2UpLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGl0IHdvbid0IHJlbW92ZSBhbnkgZWxlbWVudHMgZnJvbSBgbm9kZS5jb250ZW50YDsgd2UgbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGRvIHRoYXQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpbW1lZFN0YXJ0IH0gPSB0cmltU3RhcnQobm9kZS5jb250ZW50LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQuc3BsaWNlKDEsIHRyaW1tZWRTdGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaW0obm9kZS5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwidW5pZmllZFwiO1xuaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyB0cmltIH0gZnJvbSBcIi4vdHJpbVwiO1xuXG50eXBlIFBsdWdpbk9wdGlvbnMgPSB2b2lkO1xuXG4vKipcbiAqIFVuaWZpZWQgcGx1Z2luIHRvIHRyaW0gdGhlIHdoaXRlc3BhY2UgZnJvbSB0aGUgc3RhcnQvZW5kIG9mIHRoZSByb290IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmlmaWVkTGF0ZXhUcmltUm9vdDogUGx1Z2luPFBsdWdpbk9wdGlvbnNbXSwgQXN0LlJvb3QsIEFzdC5Sb290PiA9XG4gICAgZnVuY3Rpb24gdW5pZmllZExhdGV4VHJpbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiAodHJlZSkgPT4ge1xuICAgICAgICAgICAgdHJpbSh0cmVlLmNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgIH07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3Zpc2l0XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gdHJhdmVyc2UgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuIGB2aXNpdGAgaXNcbiAqIHZlcnkgc2ltaWxhciB0byBbZXN0cmVlLXV0aWwtdmlzaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9lc3RyZWUtdXRpbC12aXNpdCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZWN1cnNpdmVseSByZXBsYWNlIHBhcnRpY3VsYXIgQVNUIG5vZGVzLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG4vKipcbiAqIExpc3QgYWxsIHByb3BzIG9mIHRoZSBjdXJyZW50IG5vZGUgdGhhdCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gKiBpbiBtYXRoIG1vZGUgb3Igbm90IGluIG1hdGggbW9kZS4gSWYgbWF0aCBtb2RlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIG5vZGUncyByZW5kZXJcbiAqIGluZm8sIGVtcHR5IGxpc3RzIGFyZSByZXR1cm5lZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgXFx0ZXh0e2Zvb31gIHdpbGwgcmVwb3J0IHRoYXQgYGFyZ3NgIHNob3VsZCAqbm90KiBiZSBwcm9jZXNzZWQgaW4gbWF0aCBtb2RlLFxuICogc2luY2UgaXQncyBjb250ZW50cyBzaG91bGQgYWx3YXlzIGJlIHByb2Nlc3NlZCBpbiB0ZXh0IG1vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0TWF0aENoaWxkcmVuKG5vZGU6IEFzdC5Bc3QpOiB7XG4gICAgZW50ZXI6IHN0cmluZ1tdO1xuICAgIGxlYXZlOiBzdHJpbmdbXTtcbn0ge1xuICAgIGNvbnN0IE5VTExfUkVUVVJOID0geyBlbnRlcjogW10sIGxlYXZlOiBbXSB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1JFVFVSTjtcbiAgICB9XG4gICAgaWYgKG1hdGNoLm1hdGgobm9kZSkpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBlbnRlciBhIG1hdGggZW52aXJvbm1lbnQsIG91ciBjb250ZW50IGlzIGFsd2F5c1xuICAgICAgICAvLyBjb25zaWRlcmVkIG1hdGggbW9kZVxuICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVySW5mbzogeyBpbk1hdGhNb2RlPzogYm9vbGVhbiB9ID0gbm9kZS5fcmVuZGVySW5mbyB8fCB7fTtcbiAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWFjcm8obm9kZSkpIHtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtcImFyZ3NcIl0sIGxlYXZlOiBbXSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVudGVyOiBbXSwgbGVhdmU6IFtcImFyZ3NcIl0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2guZW52aXJvbm1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtcImNvbnRlbnRcIl0sIGxlYXZlOiBbXSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiY29udGVudFwiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1JFVFVSTjtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbGlzdE1hdGhDaGlsZHJlbiB9IGZyb20gXCIuL2xpc3QtbWF0aC1jaGlsZHJlblwiO1xuXG5leHBvcnQgdHlwZSBWaXNpdG9yQ29udGV4dCA9IHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBub2RlIGlzIGJlaW5nIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgbm9kZSBpcyBhIGRpcmVjdG9yIG9yIGluZGlyZWN0IGNoaWxkXG4gICAgICogb2YgYSBtYXRoIGVudmlyb25tZW50IChlLmcuIGAkYWJjJGApLCBidXQgbm90IHdoZW4gYW4gZW52aXJvbm1lbnRcbiAgICAgKiByZS1lc3RhYmxpc2hlcyB0ZXh0IG1vZGUgKGUuZy4gYCRcXHRleHR7YWJjfSRgKVxuICAgICAqL1xuICAgIGluTWF0aE1vZGU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaGFzIGFueSBhbmNlc3RvciB0aGF0IGlzIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUuXG4gICAgICovXG4gICAgaGFzTWF0aE1vZGVBbmNlc3Rvcj86IGJvb2xlYW47XG59O1xuXG50eXBlIEdldEd1YXJkPFQ+ID0gVCBleHRlbmRzICh4OiBhbnkpID0+IHggaXMgaW5mZXIgUiA/IFIgOiBuZXZlcjtcbi8qKlxuICogR2V0cyB0aGUgdHlwZSB0aGF0IGEgdHlwZS1ndWFyZCBmdW5jdGlvbiBpcyBndWFyZGluZy4gSWZcbiAqIHRoZSBndWFyZCB0eXBlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLCB0aGUgaW5wdXQgdHlwZSBpcyByZXR1cm5lZC5cbiAqL1xudHlwZSBHdWFyZFR5cGVPZjxUIGV4dGVuZHMgKHg6IGFueSkgPT4gYm9vbGVhbj4gPSBHZXRHdWFyZDxUPiBleHRlbmRzIG5ldmVyXG4gICAgPyBUIGV4dGVuZHMgKHg6IGluZmVyIEEpID0+IGFueVxuICAgICAgICA/IEFcbiAgICAgICAgOiBuZXZlclxuICAgIDogR2V0R3VhcmQ8VD47XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGd1YXJkIHR5cGUgZnJvbSB0aGUgYHRlc3RgIGZ1bmN0aW9uIHByb3ZpZGVkIGluIGFcbiAqIGBWaXNpdE9wdGlvbnNgIGFyZ3VtZW50LlxuICovXG50eXBlIEd1YXJkRnJvbU9wdGlvbnM8XG4gICAgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucyxcbiAgICBQb3NzaWJsZVR5cGVzID0gQXN0LkFzdFxuPiA9IE9wdHMgZXh0ZW5kcyB7XG4gICAgdGVzdDogaW5mZXIgUjtcbn1cbiAgICA/IFIgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuXG4gICAgICAgID8gLy8gQSBndWFyZCBsaWtlIGB0eXBlb2YgQXJyYXkuaXNBcnJheWAgd2lsbCByZXR1cm4gYGFueVtdYCBhcyB0aGUgdHlwZS5cbiAgICAgICAgICAvLyBUaGlzIHR5cGUgY2Fubm90IGJlIG5hcnJvd2VkLCBzbyBpbnN0ZWFkIHdlIHVzZSBpdCB0byBwaWNrIGZyb21cbiAgICAgICAgICAvLyB0aGUgc2V0IG9mIGFsbCBwb3NzaWJsZSB0eXBlcy5cbiAgICAgICAgICBFeHRyYWN0PFBvc3NpYmxlVHlwZXMsIEd1YXJkVHlwZU9mPFI+PlxuICAgICAgICA6IFBvc3NpYmxlVHlwZXNcbiAgICA6IFBvc3NpYmxlVHlwZXM7XG5cbi8qKlxuICogTmFycm93IHRoZSB0eXBlIGBUYCBiYXNlZCBvbiB0aGUgYFZpc2l0T3B0aW9uc2Agc3VwcGxpZWQuIElmIGB7aW5jbHVkZUFycmF5czogZmFsc2V9YFxuICogaXMgc3BlY2lmaWVkIGluIHRoZSBgVmlzaXRPcHRpb25zYCwgdGhlbiBhcnJheXMgYXJlIGV4Y2x1ZGVkIGZyb20gYFRgLlxuICovXG50eXBlIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPFQsIE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+ID0gT3B0cyBleHRlbmRzIHtcbiAgICBpbmNsdWRlQXJyYXlzOiBpbmZlciBBO1xufVxuICAgID8gQSBleHRlbmRzIHRydWVcbiAgICAgICAgPyBUXG4gICAgICAgIDogRXhjbHVkZTxULCBhbnlbXT5cbiAgICA6IEV4Y2x1ZGU8VCwgYW55W10+O1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVyIHRvIHRoZSBgVmlzaXRvcmAgZnVuY3Rpb24gYmFzZWQgb24gdGhlXG4gKiBgVmlzaXRPcHRpb25zYCB0aGF0IGFyZSBzdXBwbGllZC5cbiAqL1xudHlwZSBWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+ID1cbiAgICBOYXJyb3dBcnJheXNCYXNlZE9uT3B0aW9uczxHdWFyZEZyb21PcHRpb25zPE9wdHM+LCBPcHRzPjtcblxuLyoqXG4gKiBDb250aW51ZSB0cmF2ZXJzaW5nIGFzIG5vcm1hbFxuICovXG5leHBvcnQgY29uc3QgQ09OVElOVUUgPSBTeW1ib2woXCJjb250aW51ZVwiKTtcbi8qKlxuICogRG8gbm90IHRyYXZlcnNlIHRoaXMgbm9kZeKAmXMgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGNvbnN0IFNLSVAgPSBTeW1ib2woXCJza2lwXCIpO1xuLyoqXG4gKiBTdG9wIHRyYXZlcnNpbmcgaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGNvbnN0IEVYSVQgPSBTeW1ib2woXCJleGl0XCIpO1xuXG50eXBlIEFjdGlvbiA9IHR5cGVvZiBDT05USU5VRSB8IHR5cGVvZiBTS0lQIHwgdHlwZW9mIEVYSVQ7XG50eXBlIEluZGV4ID0gbnVtYmVyO1xudHlwZSBBY3Rpb25UdXBsZSA9IFtBY3Rpb25dIHwgW3R5cGVvZiBTS0lQLCBJbmRleF0gfCBbdHlwZW9mIENPTlRJTlVFLCBJbmRleF07XG5cbi8qKlxuICogQSB2aXNpdG9yIHRha2VzIGEgYG5vZGVgLCBga2V5YCwgYGluZGV4YCwgYW5kIC4uLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJlbnQgdGhhdCB3ZSB3ZXJlIGFjY2Vzc2VkIHRocm91Z2guXG4gKi9cbnR5cGUgVmlzaXRvcjxUPiA9IChcbiAgICBub2RlOiBULFxuICAgIGluZm86IFZpc2l0SW5mb1xuKSA9PiBudWxsIHwgdW5kZWZpbmVkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZSB8IHZvaWQ7XG50eXBlIFZpc2l0b3JzPFQ+ID0geyBlbnRlcj86IFZpc2l0b3I8VD47IGxlYXZlPzogVmlzaXRvcjxUPiB9O1xuXG50eXBlIFZpc2l0T3B0aW9ucyA9IHtcbiAgICBzdGFydGluZ0NvbnRleHQ/OiBWaXNpdG9yQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciB0eXBlcyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGB2aXNpdG9yYCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0ZXN0PzogKG5vZGU6IEFzdC5Bc3QsIGluZm86IFZpc2l0SW5mbykgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFycmF5cyB3aWxsIGJlIHNlbnQgdG8gdGhlIGB2aXNpdG9yYCBmdW5jdGlvbi4gSWYgZmFsc3ksXG4gICAgICogb25seSBub2RlcyB3aWxsIGJlIHBhc3QgdG8gYHZpc2l0b3JgLlxuICAgICAqL1xuICAgIGluY2x1ZGVBcnJheXM/OiBib29sZWFuO1xufTtcblxuY29uc3QgREVGQVVMVF9DT05URVhUOiBWaXNpdG9yQ29udGV4dCA9IHtcbiAgICBpbk1hdGhNb2RlOiBmYWxzZSxcbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yOiBmYWxzZSxcbn07XG5cbmV4cG9ydCB0eXBlIFZpc2l0SW5mbyA9IHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgdmlhIGFuIGF0dHJpYnV0ZSwgdGhlIGF0dHJpYnV0ZSBrZXkgaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGtleTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCBpbiBhbiBhcnJheSwgdGhlIGluZGV4IGlzIHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICByZWFkb25seSBpbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbmNlc3RvciBub2RlcywgYFtwYXJlbnQsIGdyYW5kcGFyZW50LCBncmVhdC1ncmFuZHBhcmVudCwgLi4uXWBcbiAgICAgKi9cbiAgICByZWFkb25seSBwYXJlbnRzOiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW107XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgYXJyYXkgdGhhdCBpdCBpcyBwYXJ0IG9mLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRhaW5pbmdBcnJheTogKEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50KVtdIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFRoZSBMYVRlWCBjb250ZXh0IG9mIHRoZSBjdXJyZW50IG1hdGNoLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFZpc2l0b3JDb250ZXh0O1xufTtcblxuLyoqXG4gKiBWaXNpdCBjaGlsZHJlbiBvZiB0cmVlIHdoaWNoIHBhc3MgYSB0ZXN0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0cmVlIEFic3RyYWN0IHN5bnRheCB0cmVlIHRvIHdhbGtcbiAqIEBwYXJhbSB7VmlzaXRvcnxWaXNpdG9yc30gW3Zpc2l0b3JdIEZ1bmN0aW9uIHRvIHJ1biBmb3IgZWFjaCBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdDxPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zPihcbiAgICB0cmVlOiBBc3QuQXN0LFxuICAgIHZpc2l0b3I6XG4gICAgICAgIHwgVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PlxuICAgICAgICB8IFZpc2l0b3JzPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+LFxuICAgIG9wdGlvbnM/OiBPcHRzXG4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0aW5nQ29udGV4dCA9IERFRkFVTFRfQ09OVEVYVCxcbiAgICAgICAgdGVzdCA9ICgpID0+IHRydWUsXG4gICAgICAgIGluY2x1ZGVBcnJheXMgPSBmYWxzZSxcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZW50ZXI6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IGxlYXZlOiBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50ZXIgPSB2aXNpdG9yO1xuICAgIH0gZWxzZSBpZiAodmlzaXRvciAmJiB0eXBlb2YgdmlzaXRvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3IuZW50ZXI7XG4gICAgICAgIGxlYXZlID0gdmlzaXRvci5sZWF2ZTtcbiAgICB9XG5cbiAgICB3YWxrKHRyZWUsIHtcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmVudHM6IFtdLFxuICAgICAgICBjb250YWluaW5nQXJyYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogeyAuLi5zdGFydGluZ0NvbnRleHQgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nP30ga2V5XG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBwYXJlbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FsayhcbiAgICAgICAgbm9kZTogQXN0LkFzdCxcbiAgICAgICAgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfTogVmlzaXRJbmZvXG4gICAgKTogQWN0aW9uVHVwbGUge1xuICAgICAgICBjb25zdCBub2RlUGFzc2VzVGVzdCA9IGluY2x1ZGVBcnJheXNcbiAgICAgICAgICAgID8gdGVzdChub2RlLCB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9KVxuICAgICAgICAgICAgOiAhQXJyYXkuaXNBcnJheShub2RlKSAmJlxuICAgICAgICAgICAgICB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQWN0aW9uVHVwbGUgPVxuICAgICAgICAgICAgZW50ZXIgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGVudGVyKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogW0NPTlRJTlVFXTtcblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdFswXSA9PT0gU0tJUCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYXZlICYmIG5vZGVQYXNzZXNUZXN0XG4gICAgICAgICAgICAgICAgPyB0b1Jlc3VsdChcbiAgICAgICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgYHZhbHVlYCBhcnJheSBtaWdodCBiZSBtb2RpZmllZCBpbiBwbGFjZSBhcyB3ZSB0cmF2ZXJzZSBpdCwgc29cbiAgICAgICAgICAgIC8vIHdlIHVzZSBhIHRyYWRpdGlvbmFsIGZvciBsb29wLlxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA+IC0xICYmIGluZGV4IDwgbm9kZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZVtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FsayhpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogbm9kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0WzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb3IgbG9vcCB3aWxsIGluY3JlbWVudCBpIGV2ZXJ5IHBhc3MuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFuIGluZGV4IHdhcyByZXR1cm5lZCwgdGhhdCdzIHdoZXJlIHdlIHdhbnQgdG8gc3RhcnQgbmV4dCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdFsxXSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZWN1cnNpdmVseSBhcHBseSB0byB0aGUgYGNvbnRlbnRgXG4gICAgICAgICAgICAvLyBvZiBhbGwgdHlwZXMgKGUuZy4sIGNvbW1lbnRzIGFuZCBtYWNyb3MpLCBzbyBzcGVjaWZ5XG4gICAgICAgICAgICAvLyBhIGJsYWNrbGlzdC5cbiAgICAgICAgICAgIGxldCBjaGlsZFByb3BzOiAoXCJjb250ZW50XCIgfCBcImFyZ3NcIilbXSA9IFtcImNvbnRlbnRcIiwgXCJhcmdzXCJdO1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtcImFyZ3NcIl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZXJiXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJhdGltXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGhNb2RlUHJvcHMgPSBsaXN0TWF0aENoaWxkcmVuKG5vZGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXkgYXMga2V5b2YgdHlwZW9mIG5vZGVdIGFzXG4gICAgICAgICAgICAgICAgICAgIHwgQXN0LkFzdFxuICAgICAgICAgICAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBncmFuZHBhcmVudHMgPSBbbm9kZV0uY29uY2F0KHBhcmVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHN3aXRjaCBpbi9vdXQgb2YgbWF0aCBtb2RlIGFzIHdlIHBhc3MgdG8gbm9kZVtrZXldXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IHsgLi4uY29udGV4dCB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXRoTW9kZVByb3BzLmVudGVyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5pbk1hdGhNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5oYXNNYXRoTW9kZUFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGhNb2RlUHJvcHMubGVhdmUuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50czogZ3JhbmRwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBuZXdDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nQXJyYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlYXZlICYmIG5vZGVQYXNzZXNUZXN0XG4gICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgbGVhdmUobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIGEgcmVzdWx0IGlzIGFuIGBBY3Rpb25UdXBsZWBzXG4gKi9cbmZ1bmN0aW9uIHRvUmVzdWx0KFxuICAgIHZhbHVlOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8IEFjdGlvbiB8IEluZGV4IHwgQWN0aW9uVHVwbGVcbik6IEFjdGlvblR1cGxlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFXTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFtDT05USU5VRSwgdmFsdWVdO1xuICAgIH1cblxuICAgIHJldHVybiBbdmFsdWVdO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL2xpc3QtcGFja2FnZXNcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyBmb3IgcmVwb3J0aW5nIG9uIGltcG9ydGVkIHBhY2thZ2VzIGluIGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IGFyZSBidWlsZGluZyBhIGxpbnRlciBvciBzb21lIG90aGVyIHN5c3RlbSB0aGF0IG5lZWRzIHRvIGtub3cgd2hpY2ggcGFja2FnZXMgaGF2ZSBiZWVuIGluY2x1ZGVkXG4gKiB2aWEgYFxcdXNlcGFja2FnZXsuLi59YCBvciBgXFxSZXF1aXJlUGFja2FnZXsuLi59YC5cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9