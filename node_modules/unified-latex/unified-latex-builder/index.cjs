/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-builder/libs/builders.ts":
/*!************************************************!*\
  !*** ./unified-latex-builder/libs/builders.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SP": () => (/* binding */ SP),
/* harmony export */   "arg": () => (/* binding */ arg),
/* harmony export */   "args": () => (/* binding */ args),
/* harmony export */   "env": () => (/* binding */ env),
/* harmony export */   "m": () => (/* binding */ m),
/* harmony export */   "s": () => (/* binding */ s)
/* harmony export */ });
function normalizeNode(node) {
    if (typeof node === "string") {
        return s(node);
    }
    return node;
}
function normalizeArgument(arg, openMark = "{", closeMark = "}") {
    if (typeof arg === "string") {
        return {
            type: "argument",
            openMark,
            closeMark,
            content: [s(arg)],
        };
    }
    if (arg.type === "argument") {
        return arg;
    }
    return { type: "argument", openMark, closeMark, content: [arg] };
}
function normalizeArgumentsList(args, openMark = "{", closeMark = "}") {
    if (args == null) {
        return [];
    }
    if (Array.isArray(args)) {
        return args.map((arg) => normalizeArgument(arg, openMark, closeMark));
    }
    return [normalizeArgument(args, openMark, closeMark)];
}
const BRACES_MAP = {
    "*": { openMark: "", closeMark: "" },
    "{": { openMark: "{", closeMark: "}" },
    "[": { openMark: "[", closeMark: "]" },
    "(": { openMark: "(", closeMark: ")" },
};
const CLOSE_BRACES = new Set(Object.values(BRACES_MAP)
    .map((x) => x.closeMark)
    .filter((x) => x));
/**
 * Turn a braces signature into an array of braces.
 */
function bracesToOpenAndCloseMarks(braces) {
    const ret = [];
    for (const char of braces.split("")) {
        if (CLOSE_BRACES.has(char)) {
            continue;
        }
        const braces = BRACES_MAP[char];
        if (braces == null) {
            throw new Error(`Unknown open/close mark type "${char}"`);
        }
        braces;
        ret.push(braces);
    }
    return ret;
}
/**
 * Create an Argument list. `special.braces` can optionally specify
 * the signature of the open/close marks that each argument uses. For example
 * ```
 * args(["a", "b"], { braces: "[]{}" });
 * ```
 * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, and `(`.
 */
function args(args, special) {
    var _a, _b;
    if (!Array.isArray(args)) {
        args = [args];
    }
    if (special === null || special === void 0 ? void 0 : special.braces) {
        const braces = bracesToOpenAndCloseMarks(special.braces);
        if (braces.length !== args.length) {
            throw new Error(`There is a difference between the number of supplied braces and the number of supplied arguments. ${args.length} supplied with braces signature ${special.braces}`);
        }
        return args.map((arg, i) => normalizeArgument(arg, braces[i].openMark, braces[i].closeMark));
    }
    const openMark = (_a = special === null || special === void 0 ? void 0 : special.defaultOpenMark) !== null && _a !== void 0 ? _a : "{";
    const closeMark = (_b = special === null || special === void 0 ? void 0 : special.defaultCloseMark) !== null && _b !== void 0 ? _b : "}";
    return normalizeArgumentsList(args, openMark, closeMark);
}
/**
 * Create an Argument. `special.braces` can optionally specify
 * the signature of the open/close marks that each argument uses. For example
 * ```
 * arg("a", { braces: "[]" });
 * ```
 * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, and `(`.
 */
function arg(args, special) {
    var _a, _b;
    if (typeof args === "string") {
        args = s(args);
    }
    if (!Array.isArray(args) && args.type === "argument") {
        return args;
    }
    let openMark = (_a = special === null || special === void 0 ? void 0 : special.openMark) !== null && _a !== void 0 ? _a : "{";
    let closeMark = (_b = special === null || special === void 0 ? void 0 : special.closeMark) !== null && _b !== void 0 ? _b : "}";
    if (special === null || special === void 0 ? void 0 : special.braces) {
        const braces = bracesToOpenAndCloseMarks(special.braces);
        if (braces[0]) {
            openMark = braces[0].openMark;
            closeMark = braces[0].closeMark;
        }
    }
    if (!Array.isArray(args)) {
        args = [args];
    }
    return { type: "argument", content: args, openMark, closeMark };
}
/**
 * Create a Macro with the given `name`. The macro
 * may be followed by any number of arguments.
 */
function m(name, marcoArgs, special) {
    const args = normalizeArgumentsList(marcoArgs);
    const escapeToken = special === null || special === void 0 ? void 0 : special.escapeToken;
    const ret = { type: "macro", content: name };
    if (args.length > 0) {
        ret.args = args;
    }
    if (escapeToken != null) {
        ret.escapeToken = escapeToken;
    }
    return ret;
}
/**
 * Create a String node from `value`
 */
function s(value) {
    if (typeof value === "string") {
        return { type: "string", content: value };
    }
    return value;
}
/**
 * Create an Environment node.
 */
function env(name, body, envArgs, special) {
    if (!Array.isArray(body)) {
        body = [body];
    }
    const args = normalizeArgumentsList(envArgs, "[", "]");
    const ret = {
        type: "environment",
        env: name,
        content: body.map(normalizeNode),
    };
    if (args.length > 0) {
        ret.args = args;
    }
    return ret;
}
/**
 * Whitespace node.
 */
const SP = { type: "whitespace" };


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!****************************************!*\
  !*** ./unified-latex-builder/index.ts ***!
  \****************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SP": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.SP),
/* harmony export */   "arg": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.arg),
/* harmony export */   "args": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.args),
/* harmony export */   "env": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.env),
/* harmony export */   "m": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.m),
/* harmony export */   "s": () => (/* reexport safe */ _libs_builders__WEBPACK_IMPORTED_MODULE_0__.s)
/* harmony export */ });
/* harmony import */ var _libs_builders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/builders */ "./unified-latex-builder/libs/builders.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help build a `unified-latex` Abstract Syntax Tree (AST)
 * with [hyperscript](https://github.com/dominictarr/hyperscript)-like syntax.
 *
 * ## When should I use this?
 *
 * If you want to programmatically create `Ast.Node` nodes.
 *
 */

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pZmllZC1sYXRleC1idWlsZGVyL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxTQUFTLGFBQWEsQ0FBQyxJQUFtQjtJQUN0QyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUN0QixHQUFzQixFQUN0QixRQUFRLEdBQUcsR0FBRyxFQUNkLFNBQVMsR0FBRyxHQUFHO0lBRWYsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDekIsT0FBTztZQUNILElBQUksRUFBRSxVQUFVO1lBQ2hCLFFBQVE7WUFDUixTQUFTO1lBQ1QsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BCLENBQUM7S0FDTDtJQUNELElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxVQUFVLEVBQUU7UUFDekIsT0FBTyxHQUFHLENBQUM7S0FDZDtJQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUNyRSxDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FDM0IsSUFBOEMsRUFDOUMsUUFBUSxHQUFHLEdBQUcsRUFDZCxTQUFTLEdBQUcsR0FBRztJQUVmLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtRQUNkLE9BQU8sRUFBRSxDQUFDO0tBQ2I7SUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7S0FDekU7SUFDRCxPQUFPLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQzFELENBQUM7QUFHRCxNQUFNLFVBQVUsR0FBK0I7SUFDM0MsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFO0lBQ3BDLEdBQUcsRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRTtJQUN0QyxHQUFHLEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUU7SUFDdEMsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFO0NBQ3pDLENBQUM7QUFDRixNQUFNLFlBQVksR0FBRyxJQUFJLEdBQUcsQ0FDeEIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7S0FDcEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0tBQ3ZCLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3hCLENBQUM7QUFFRjs7R0FFRztBQUNILFNBQVMseUJBQXlCLENBQUMsTUFBYztJQUM3QyxNQUFNLEdBQUcsR0FBaUIsRUFBRSxDQUFDO0lBRTdCLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUNqQyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEIsU0FBUztTQUNaO1FBQ0QsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsTUFBTSxDQUFDO1FBQ1AsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNwQjtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxTQUFTLElBQUksQ0FDaEIsSUFBNkMsRUFDN0MsT0FBaUM7O0lBRWpDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3RCLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2pCO0lBQ0QsSUFBSSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxFQUFFO1FBQ2pCLE1BQU0sTUFBTSxHQUFHLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6RCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUNYLHFHQUFxRyxJQUFJLENBQUMsTUFBTSxtQ0FBbUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUN0SyxDQUFDO1NBQ0w7UUFDRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDdkIsaUJBQWlCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUNsRSxDQUFDO0tBQ0w7SUFFRCxNQUFNLFFBQVEsR0FBRyxhQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsZUFBZSxtQ0FBSSxHQUFHLENBQUM7SUFDakQsTUFBTSxTQUFTLEdBQUcsYUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLGdCQUFnQixtQ0FBSSxHQUFHLENBQUM7SUFDbkQsT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzdELENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0ksU0FBUyxHQUFHLENBQ2YsSUFBb0MsRUFDcEMsT0FBZ0M7O0lBRWhDLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbEI7SUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtRQUNsRCxPQUFPLElBQUksQ0FBQztLQUNmO0lBRUQsSUFBSSxRQUFRLEdBQUcsYUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsbUNBQUksR0FBRyxDQUFDO0lBQ3hDLElBQUksU0FBUyxHQUFHLGFBQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxTQUFTLG1DQUFJLEdBQUcsQ0FBQztJQUMxQyxJQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLEVBQUU7UUFDakIsTUFBTSxNQUFNLEdBQUcseUJBQXlCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pELElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ1gsUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDOUIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDbkM7S0FDSjtJQUVELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3RCLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2pCO0lBRUQsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLENBQUM7QUFDcEUsQ0FBQztBQUVEOzs7R0FHRztBQUNJLFNBQVMsQ0FBQyxDQUNiLElBQVksRUFDWixTQUFtRCxFQUNuRCxPQUE2QjtJQUU3QixNQUFNLElBQUksR0FBRyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvQyxNQUFNLFdBQVcsR0FBRyxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsV0FBVyxDQUFDO0lBQ3pDLE1BQU0sR0FBRyxHQUFjLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFFeEQsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUNqQixHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztLQUNuQjtJQUNELElBQUksV0FBVyxJQUFJLElBQUksRUFBRTtRQUNyQixHQUFHLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztLQUNqQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUVEOztHQUVHO0FBQ0ksU0FBUyxDQUFDLENBQUMsS0FBMEI7SUFDeEMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDM0IsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO0tBQzdDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVEOztHQUVHO0FBQ0ksU0FBUyxHQUFHLENBQ2YsSUFBWSxFQUNaLElBQXFDLEVBQ3JDLE9BQWlELEVBQ2pELE9BQWlCO0lBRWpCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3RCLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2pCO0lBQ0QsTUFBTSxJQUFJLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN2RCxNQUFNLEdBQUcsR0FBb0I7UUFDekIsSUFBSSxFQUFFLGFBQWE7UUFDbkIsR0FBRyxFQUFFLElBQUk7UUFDVCxPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7S0FDbkMsQ0FBQztJQUNGLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDakIsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDbkI7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFFRDs7R0FFRztBQUNJLE1BQU0sRUFBRSxHQUFtQixFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsQ0FBQzs7Ozs7OztTQzdOekQ7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTmdDO0FBRWhDLDBFQUEwRTtBQUMxRTs7Ozs7Ozs7OztHQVVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtYnVpbGRlci9saWJzL2J1aWxkZXJzLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC1idWlsZGVyL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG50eXBlIENvZXJjaWJsZU5vZGUgPSBzdHJpbmcgfCBBc3QuTm9kZTtcbnR5cGUgQ29lcmNpYmxlQXJndW1lbnQgPSBDb2VyY2libGVOb2RlIHwgQXN0LkFyZ3VtZW50O1xudHlwZSBNYWNyb1NwZWNpYWxPcHRpb25zID0ge1xuICAgIGVzY2FwZVRva2VuPzogc3RyaW5nO1xufTtcbnR5cGUgQXJndW1lbnRzU3BlY2lhbE9wdGlvbnMgPSB7XG4gICAgYnJhY2VzPzogc3RyaW5nO1xuICAgIGRlZmF1bHRPcGVuTWFyaz86IHN0cmluZztcbiAgICBkZWZhdWx0Q2xvc2VNYXJrPzogc3RyaW5nO1xufTtcbnR5cGUgQXJndW1lbnRTcGVjaWFsT3B0aW9ucyA9IHtcbiAgICBicmFjZXM/OiBzdHJpbmc7XG4gICAgb3Blbk1hcms/OiBzdHJpbmc7XG4gICAgY2xvc2VNYXJrPzogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTm9kZShub2RlOiBDb2VyY2libGVOb2RlKTogQXN0Lk5vZGUge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcyhub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50KFxuICAgIGFyZzogQ29lcmNpYmxlQXJndW1lbnQsXG4gICAgb3Blbk1hcmsgPSBcIntcIixcbiAgICBjbG9zZU1hcmsgPSBcIn1cIlxuKTogQXN0LkFyZ3VtZW50IHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJhcmd1bWVudFwiLFxuICAgICAgICAgICAgb3Blbk1hcmssXG4gICAgICAgICAgICBjbG9zZU1hcmssXG4gICAgICAgICAgICBjb250ZW50OiBbcyhhcmcpXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFyZy50eXBlID09PSBcImFyZ3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhcmd1bWVudFwiLCBvcGVuTWFyaywgY2xvc2VNYXJrLCBjb250ZW50OiBbYXJnXSB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcmd1bWVudHNMaXN0KFxuICAgIGFyZ3M/OiBDb2VyY2libGVBcmd1bWVudCB8IENvZXJjaWJsZUFyZ3VtZW50W10sXG4gICAgb3Blbk1hcmsgPSBcIntcIixcbiAgICBjbG9zZU1hcmsgPSBcIn1cIlxuKTogQXN0LkFyZ3VtZW50W10ge1xuICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gbm9ybWFsaXplQXJndW1lbnQoYXJnLCBvcGVuTWFyaywgY2xvc2VNYXJrKSk7XG4gICAgfVxuICAgIHJldHVybiBbbm9ybWFsaXplQXJndW1lbnQoYXJncywgb3Blbk1hcmssIGNsb3NlTWFyayldO1xufVxuXG50eXBlIEJyYWNlc1BhaXIgPSB7IG9wZW5NYXJrOiBzdHJpbmc7IGNsb3NlTWFyazogc3RyaW5nIH07XG5jb25zdCBCUkFDRVNfTUFQOiBSZWNvcmQ8c3RyaW5nLCBCcmFjZXNQYWlyPiA9IHtcbiAgICBcIipcIjogeyBvcGVuTWFyazogXCJcIiwgY2xvc2VNYXJrOiBcIlwiIH0sXG4gICAgXCJ7XCI6IHsgb3Blbk1hcms6IFwie1wiLCBjbG9zZU1hcms6IFwifVwiIH0sXG4gICAgXCJbXCI6IHsgb3Blbk1hcms6IFwiW1wiLCBjbG9zZU1hcms6IFwiXVwiIH0sXG4gICAgXCIoXCI6IHsgb3Blbk1hcms6IFwiKFwiLCBjbG9zZU1hcms6IFwiKVwiIH0sXG59O1xuY29uc3QgQ0xPU0VfQlJBQ0VTID0gbmV3IFNldChcbiAgICBPYmplY3QudmFsdWVzKEJSQUNFU19NQVApXG4gICAgICAgIC5tYXAoKHgpID0+IHguY2xvc2VNYXJrKVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiB4KVxuKTtcblxuLyoqXG4gKiBUdXJuIGEgYnJhY2VzIHNpZ25hdHVyZSBpbnRvIGFuIGFycmF5IG9mIGJyYWNlcy5cbiAqL1xuZnVuY3Rpb24gYnJhY2VzVG9PcGVuQW5kQ2xvc2VNYXJrcyhicmFjZXM6IHN0cmluZyk6IEJyYWNlc1BhaXJbXSB7XG4gICAgY29uc3QgcmV0OiBCcmFjZXNQYWlyW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgY2hhciBvZiBicmFjZXMuc3BsaXQoXCJcIikpIHtcbiAgICAgICAgaWYgKENMT1NFX0JSQUNFUy5oYXMoY2hhcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYWNlcyA9IEJSQUNFU19NQVBbY2hhcl07XG4gICAgICAgIGlmIChicmFjZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZW4vY2xvc2UgbWFyayB0eXBlIFwiJHtjaGFyfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJhY2VzO1xuICAgICAgICByZXQucHVzaChicmFjZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIEFyZ3VtZW50IGxpc3QuIGBzcGVjaWFsLmJyYWNlc2AgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeVxuICogdGhlIHNpZ25hdHVyZSBvZiB0aGUgb3Blbi9jbG9zZSBtYXJrcyB0aGF0IGVhY2ggYXJndW1lbnQgdXNlcy4gRm9yIGV4YW1wbGVcbiAqIGBgYFxuICogYXJncyhbXCJhXCIsIFwiYlwiXSwgeyBicmFjZXM6IFwiW117fVwiIH0pO1xuICogYGBgXG4gKiB3aWxsIHJlc3VsdCBpbiBhcmd1bWVudHMgYFthXXtifWAuIFZhbGlkIGJyYWNlcyBhcmUgYCpgLCBgW2AsIGB7YCwgYW5kIGAoYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZ3MoXG4gICAgYXJnczogQ29lcmNpYmxlQXJndW1lbnQgfCBDb2VyY2libGVBcmd1bWVudFtdLFxuICAgIHNwZWNpYWw/OiBBcmd1bWVudHNTcGVjaWFsT3B0aW9uc1xuKTogQXN0LkFyZ3VtZW50W10ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBhcmdzID0gW2FyZ3NdO1xuICAgIH1cbiAgICBpZiAoc3BlY2lhbD8uYnJhY2VzKSB7XG4gICAgICAgIGNvbnN0IGJyYWNlcyA9IGJyYWNlc1RvT3BlbkFuZENsb3NlTWFya3Moc3BlY2lhbC5icmFjZXMpO1xuICAgICAgICBpZiAoYnJhY2VzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVGhlcmUgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG51bWJlciBvZiBzdXBwbGllZCBicmFjZXMgYW5kIHRoZSBudW1iZXIgb2Ygc3VwcGxpZWQgYXJndW1lbnRzLiAke2FyZ3MubGVuZ3RofSBzdXBwbGllZCB3aXRoIGJyYWNlcyBzaWduYXR1cmUgJHtzcGVjaWFsLmJyYWNlc31gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzLm1hcCgoYXJnLCBpKSA9PlxuICAgICAgICAgICAgbm9ybWFsaXplQXJndW1lbnQoYXJnLCBicmFjZXNbaV0ub3Blbk1hcmssIGJyYWNlc1tpXS5jbG9zZU1hcmspXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3Blbk1hcmsgPSBzcGVjaWFsPy5kZWZhdWx0T3Blbk1hcmsgPz8gXCJ7XCI7XG4gICAgY29uc3QgY2xvc2VNYXJrID0gc3BlY2lhbD8uZGVmYXVsdENsb3NlTWFyayA/PyBcIn1cIjtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJndW1lbnRzTGlzdChhcmdzLCBvcGVuTWFyaywgY2xvc2VNYXJrKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQXJndW1lbnQuIGBzcGVjaWFsLmJyYWNlc2AgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeVxuICogdGhlIHNpZ25hdHVyZSBvZiB0aGUgb3Blbi9jbG9zZSBtYXJrcyB0aGF0IGVhY2ggYXJndW1lbnQgdXNlcy4gRm9yIGV4YW1wbGVcbiAqIGBgYFxuICogYXJnKFwiYVwiLCB7IGJyYWNlczogXCJbXVwiIH0pO1xuICogYGBgXG4gKiB3aWxsIHJlc3VsdCBpbiBhcmd1bWVudHMgYFthXWAuIFZhbGlkIGJyYWNlcyBhcmUgYCpgLCBgW2AsIGB7YCwgYW5kIGAoYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZyhcbiAgICBhcmdzOiBDb2VyY2libGVBcmd1bWVudCB8IEFzdC5Ob2RlW10sXG4gICAgc3BlY2lhbD86IEFyZ3VtZW50U3BlY2lhbE9wdGlvbnNcbik6IEFzdC5Bcmd1bWVudCB7XG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFyZ3MgPSBzKGFyZ3MpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy50eXBlID09PSBcImFyZ3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgbGV0IG9wZW5NYXJrID0gc3BlY2lhbD8ub3Blbk1hcmsgPz8gXCJ7XCI7XG4gICAgbGV0IGNsb3NlTWFyayA9IHNwZWNpYWw/LmNsb3NlTWFyayA/PyBcIn1cIjtcbiAgICBpZiAoc3BlY2lhbD8uYnJhY2VzKSB7XG4gICAgICAgIGNvbnN0IGJyYWNlcyA9IGJyYWNlc1RvT3BlbkFuZENsb3NlTWFya3Moc3BlY2lhbC5icmFjZXMpO1xuICAgICAgICBpZiAoYnJhY2VzWzBdKSB7XG4gICAgICAgICAgICBvcGVuTWFyayA9IGJyYWNlc1swXS5vcGVuTWFyaztcbiAgICAgICAgICAgIGNsb3NlTWFyayA9IGJyYWNlc1swXS5jbG9zZU1hcms7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgYXJncyA9IFthcmdzXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiBcImFyZ3VtZW50XCIsIGNvbnRlbnQ6IGFyZ3MsIG9wZW5NYXJrLCBjbG9zZU1hcmsgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBNYWNybyB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuIFRoZSBtYWNyb1xuICogbWF5IGJlIGZvbGxvd2VkIGJ5IGFueSBudW1iZXIgb2YgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgbWFyY29BcmdzPzogQ29lcmNpYmxlQXJndW1lbnQgfCBDb2VyY2libGVBcmd1bWVudFtdLFxuICAgIHNwZWNpYWw/OiBNYWNyb1NwZWNpYWxPcHRpb25zXG4pOiBBc3QuTWFjcm8ge1xuICAgIGNvbnN0IGFyZ3MgPSBub3JtYWxpemVBcmd1bWVudHNMaXN0KG1hcmNvQXJncyk7XG4gICAgY29uc3QgZXNjYXBlVG9rZW4gPSBzcGVjaWFsPy5lc2NhcGVUb2tlbjtcbiAgICBjb25zdCByZXQ6IEFzdC5NYWNybyA9IHsgdHlwZTogXCJtYWNyb1wiLCBjb250ZW50OiBuYW1lIH07XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldC5hcmdzID0gYXJncztcbiAgICB9XG4gICAgaWYgKGVzY2FwZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmV0LmVzY2FwZVRva2VuID0gZXNjYXBlVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBTdHJpbmcgbm9kZSBmcm9tIGB2YWx1ZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHModmFsdWU6IHN0cmluZyB8IEFzdC5TdHJpbmcpOiBBc3QuU3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIGNvbnRlbnQ6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gRW52aXJvbm1lbnQgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudihcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgYm9keTogQ29lcmNpYmxlTm9kZSB8IENvZXJjaWJsZU5vZGVbXSxcbiAgICBlbnZBcmdzPzogQ29lcmNpYmxlQXJndW1lbnQgfCBDb2VyY2libGVBcmd1bWVudFtdLFxuICAgIHNwZWNpYWw/OiB1bmtub3duXG4pOiBBc3QuRW52aXJvbm1lbnQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgICBib2R5ID0gW2JvZHldO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gbm9ybWFsaXplQXJndW1lbnRzTGlzdChlbnZBcmdzLCBcIltcIiwgXCJdXCIpO1xuICAgIGNvbnN0IHJldDogQXN0LkVudmlyb25tZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICAgIGVudjogbmFtZSxcbiAgICAgICAgY29udGVudDogYm9keS5tYXAobm9ybWFsaXplTm9kZSksXG4gICAgfTtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldC5hcmdzID0gYXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFdoaXRlc3BhY2Ugbm9kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IFNQOiBBc3QuV2hpdGVzcGFjZSA9IHsgdHlwZTogXCJ3aGl0ZXNwYWNlXCIgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9idWlsZGVyc1wiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgYnVpbGQgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVClcbiAqIHdpdGggW2h5cGVyc2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvaHlwZXJzY3JpcHQpLWxpa2Ugc3ludGF4LlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYEFzdC5Ob2RlYCBub2Rlcy5cbiAqIFxuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=