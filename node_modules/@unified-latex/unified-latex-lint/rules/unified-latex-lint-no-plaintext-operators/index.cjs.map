{"version":3,"file":"index.cjs","sources":["../../../../../node_modules/unist-util-position/lib/index.js","../../../rules/unified-latex-lint-no-plaintext-operators/index.ts"],"sourcesContent":["/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    // To do: next major: donâ€™t return points when invalid.\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","import { pointStart, pointEnd } from \"unist-util-position\";\nimport { lintRule } from \"unified-lint-rule\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { prefixMatch, Trie } from \"@unified-latex/unified-latex-util-scan\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\nconst OPERATOR_NAMES = [\n    \"Pr\",\n    \"arccos\",\n    \"arcctg\",\n    \"arcsin\",\n    \"arctan\",\n    \"arctg\",\n    \"arg\",\n    \"argmax\",\n    \"argmin\",\n    \"ch\",\n    \"cos\",\n    \"cosec\",\n    \"cosh\",\n    \"cot\",\n    \"cotg\",\n    \"coth\",\n    \"csc\",\n    \"ctg\",\n    \"cth\",\n    \"deg\",\n    \"det\",\n    \"dim\",\n    \"exp\",\n    \"gcd\",\n    \"hom\",\n    \"inf\",\n    \"injlim\",\n    \"ker\",\n    \"lg\",\n    \"lim\",\n    \"liminf\",\n    \"limsup\",\n    \"ln\",\n    \"log\",\n    \"max\",\n    \"min\",\n    \"plim\",\n    \"projlim\",\n    \"sec\",\n    \"sh\",\n    \"sin\",\n    \"sinh\",\n    \"sup\",\n    \"tan\",\n    \"tanh\",\n    \"tg\",\n    \"th\",\n    \"varinjlim\",\n    \"varliminf\",\n    \"varlimsup\",\n    \"varprojlim\",\n];\n\n// Use a prefix-tree (Trie) to store the operators for quick lookup.\n// We put a `$` at the end of each word because the implementation used only\n// returns prefixes and we need to know when we've matched an entire word.\n// `$` should never be a string in math mode.\nconst prefixTree = Trie(OPERATOR_NAMES);\n\n/**\n * If the sequence starting at `pos` is a sequence of single character strings\n * matching one of the `OPERATOR_NAMES`, then the matching operator name is returned.\n * Otherwise `null` is returned.\n */\nfunction matchesAtPos(\n    nodes: Ast.Node[],\n    index: number\n): ReturnType<typeof prefixMatch> {\n    // We don't match words that are in the middle of other letters.\n    // E.g. the `sin` in \"lsinl\" is not recognized, but the `sin` in \"l sin l\" would be.\n    const prevNode = nodes[index - 1];\n    if (match.string(prevNode) && prevNode.content.match(/^[a-zA-Z]/)) {\n        return null;\n    }\n\n    const matched = prefixMatch(nodes, prefixTree, {\n        startIndex: index,\n        // In math mode, all string nodes should be single characters. If they're\n        // not, we have mangled them via some other process and the shouldn't be treated\n        // normally\n        assumeOneCharStrings: true,\n    });\n\n    if (!matched) {\n        return null;\n    }\n\n    // Make sure the next node is not a letter.\n    const nextNode = nodes[matched.endNodeIndex + 1];\n    if (match.string(nextNode) && nextNode.content.match(/^[a-zA-Z]/)) {\n        return null;\n    }\n\n    return matched;\n}\n\ntype PluginOptions = { fix?: boolean } | undefined;\n\nexport const DESCRIPTION = `## Lint Rule\n\nAvoid writing operators in plaintext. For example, instead of \\`$sin(2)$\\` write \\`$\\\\sin(2)$\\`.\n\n### See\n\nChkTeX Warning 35\n`;\n\nexport const unifiedLatexLintNoPlaintextOperators = lintRule<\n    Ast.Root,\n    PluginOptions\n>(\n    { origin: \"unified-latex-lint:no-plaintext-operators\" },\n    (tree, file, options) => {\n        visit(\n            tree,\n            (nodes, info) => {\n                if (!info.context.inMathMode) {\n                    return;\n                }\n\n                for (let i = 0; i < nodes.length; i++) {\n                    const matched = matchesAtPos(nodes, i);\n                    if (matched) {\n                        file.message(\n                            `Use \"\\\\${matched.match}\" instead of the string \"${matched.match}\" to specify an operator name in math mode`,\n                            {\n                                start: pointStart(nodes[i]),\n                                end: pointEnd(nodes[matched.endNodeIndex]),\n                            }\n                        );\n\n                        if (options?.fix) {\n                            nodes.splice(i, matched.endNodeIndex - i + 1, {\n                                type: \"macro\",\n                                content: matched.match,\n                            });\n                            // Skip the next index since it's a macro now it doesn't need to be checked\n                            i++;\n                        }\n                    }\n                }\n            },\n            { test: Array.isArray, includeArrays: true }\n        );\n    }\n);\n"],"names":["point","Trie","index","match","prefixMatch","lintRule","visit"],"mappings":"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","x_google_ignoreList":[0]}