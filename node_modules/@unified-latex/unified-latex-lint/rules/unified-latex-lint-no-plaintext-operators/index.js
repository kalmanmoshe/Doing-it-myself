import { pointStart, pointEnd } from "unist-util-position";
import { lintRule } from "unified-lint-rule";
import { match } from "@unified-latex/unified-latex-util-match";
import { Trie, prefixMatch } from "@unified-latex/unified-latex-util-scan";
import { visit } from "@unified-latex/unified-latex-util-visit";
const OPERATOR_NAMES = [
  "Pr",
  "arccos",
  "arcctg",
  "arcsin",
  "arctan",
  "arctg",
  "arg",
  "argmax",
  "argmin",
  "ch",
  "cos",
  "cosec",
  "cosh",
  "cot",
  "cotg",
  "coth",
  "csc",
  "ctg",
  "cth",
  "deg",
  "det",
  "dim",
  "exp",
  "gcd",
  "hom",
  "inf",
  "injlim",
  "ker",
  "lg",
  "lim",
  "liminf",
  "limsup",
  "ln",
  "log",
  "max",
  "min",
  "plim",
  "projlim",
  "sec",
  "sh",
  "sin",
  "sinh",
  "sup",
  "tan",
  "tanh",
  "tg",
  "th",
  "varinjlim",
  "varliminf",
  "varlimsup",
  "varprojlim"
];
const prefixTree = Trie(OPERATOR_NAMES);
function matchesAtPos(nodes, index) {
  const prevNode = nodes[index - 1];
  if (match.string(prevNode) && prevNode.content.match(/^[a-zA-Z]/)) {
    return null;
  }
  const matched = prefixMatch(nodes, prefixTree, {
    startIndex: index,
    // In math mode, all string nodes should be single characters. If they're
    // not, we have mangled them via some other process and the shouldn't be treated
    // normally
    assumeOneCharStrings: true
  });
  if (!matched) {
    return null;
  }
  const nextNode = nodes[matched.endNodeIndex + 1];
  if (match.string(nextNode) && nextNode.content.match(/^[a-zA-Z]/)) {
    return null;
  }
  return matched;
}
const DESCRIPTION = `## Lint Rule

Avoid writing operators in plaintext. For example, instead of \`$sin(2)$\` write \`$\\sin(2)$\`.

### See

ChkTeX Warning 35
`;
const unifiedLatexLintNoPlaintextOperators = lintRule(
  { origin: "unified-latex-lint:no-plaintext-operators" },
  (tree, file, options) => {
    visit(
      tree,
      (nodes, info) => {
        if (!info.context.inMathMode) {
          return;
        }
        for (let i = 0; i < nodes.length; i++) {
          const matched = matchesAtPos(nodes, i);
          if (matched) {
            file.message(
              `Use "\\${matched.match}" instead of the string "${matched.match}" to specify an operator name in math mode`,
              {
                start: pointStart(nodes[i]),
                end: pointEnd(nodes[matched.endNodeIndex])
              }
            );
            if (options == null ? void 0 : options.fix) {
              nodes.splice(i, matched.endNodeIndex - i + 1, {
                type: "macro",
                content: matched.match
              });
              i++;
            }
          }
        }
      },
      { test: Array.isArray, includeArrays: true }
    );
  }
);
export {
  DESCRIPTION,
  unifiedLatexLintNoPlaintextOperators
};
//# sourceMappingURL=index.js.map
