{"version":3,"file":"index.js","sources":["../../../rules/unified-latex-lint-argument-color-commands/index.ts"],"sourcesContent":["import { lintRule } from \"unified-lint-rule\";\nimport { m, s } from \"@unified-latex/unified-latex-builder\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { hasParbreak } from \"../../utils/has-parbreak\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { colorToTextcolorMacro } from \"@unified-latex/unified-latex-ctan/package/xcolor\";\nimport {\n    firstSignificantNode,\n    replaceNodeDuringVisit,\n    replaceStreamingCommand,\n} from \"@unified-latex/unified-latex-util-replace\";\n\nconst REPLACEMENTS: Record<\n    string,\n    (content: Ast.Node | Ast.Node[], originalMacro: Ast.Macro) => Ast.Macro\n> = {\n    color: colorToTextcolorMacro,\n};\n\nconst isReplaceable = match.createMacroMatcher(REPLACEMENTS);\n\n/**\n * Returns true if the `group` is a group that starts with one of the `REPLACEMENT` macros.\n */\nfunction groupStartsWithMacroAndHasNoParbreak(\n    group: Ast.Ast\n): group is Ast.Group {\n    if (!match.group(group)) {\n        return false;\n    }\n    // Find the first non-whitespace non-comment node\n    let firstNode: Ast.Node | null = firstSignificantNode(group.content);\n    return isReplaceable(firstNode) && !hasParbreak(group.content);\n}\n\ntype PluginOptions =\n    | {\n          /**\n           * Whether or not to fix the lint\n           *\n           * @type {boolean}\n           */\n          fix?: boolean;\n      }\n    | undefined;\n\nexport const DESCRIPTION = `## Lint Rule\n\nPrefer using fond color commands with arguments (e.g. \\`\\\\textcolor{red}{foo bar}\\`) over in-stream color commands\n(e.g. \\`{\\\\color{red} foo bar}\\`) if the style does not apply for multiple paragraphs.\nThis rule is useful when parsing LaTeX into other tree structures (e.g., when converting from LaTeX to HTML). \n\n\nThis rule flags any usage of \\`${Object.keys(REPLACEMENTS)\n    .map((r) => printRaw(m(r)))\n    .join(\"` `\")}\\`\n`;\n\nexport const unifiedLatexLintArgumentColorCommands = lintRule<\n    Ast.Root,\n    PluginOptions\n>(\n    { origin: \"unified-latex-lint:argument-color-commands\" },\n    (tree, file, options) => {\n        const lintedNodes = new Set();\n\n        // We do two passes. First we deal with all the groups like `{\\bfseries xxx}`\n        // and then we replace all remaining streaming commands that appear in arrays.\n\n        visit(\n            tree,\n            (group, info) => {\n                const nodes = group.content;\n                for (const node of nodes) {\n                    if (isReplaceable(node) && !lintedNodes.has(node)) {\n                        lintedNodes.add(node);\n                        const macroName = node.content;\n                        file.message(\n                            `Replace \"${printRaw(group)}\" with \"${printRaw(\n                                REPLACEMENTS[macroName](s(\"...\"), node)\n                            )}\"`,\n                            node\n                        );\n                        break;\n                    }\n                }\n\n                if (options?.fix) {\n                    let fixed = replaceStreamingCommand(\n                        group,\n                        isReplaceable,\n                        (content, command) => {\n                            return REPLACEMENTS[command.content](\n                                content,\n                                command\n                            );\n                        }\n                    );\n\n                    // We cannot replace the node unless we can access the containing array.\n                    if (!info.containingArray || info.index == null) {\n                        return;\n                    }\n\n                    // `fixed` may consist of only whitespace. If this is the case,\n                    // surrounding whitespace must trimmed before\n                    // inserting the group's contents.\n                    const prevToken = info.containingArray[info.index - 1];\n                    const nextToken = info.containingArray[info.index + 1];\n                    if (\n                        match.whitespaceLike(prevToken) &&\n                        match.whitespaceLike(fixed[0])\n                    ) {\n                        trimStart(fixed);\n                    }\n                    if (\n                        match.whitespaceLike(nextToken) &&\n                        match.whitespaceLike(fixed[fixed.length - 1])\n                    ) {\n                        trimEnd(fixed);\n                    }\n                    replaceNodeDuringVisit(fixed, info);\n                }\n            },\n            { test: groupStartsWithMacroAndHasNoParbreak }\n        );\n\n        visit(\n            tree,\n            (nodes) => {\n                if (hasParbreak(nodes)) {\n                    return;\n                }\n\n                let hasReplaceableContent = false;\n                for (const node of nodes) {\n                    if (isReplaceable(node) && !lintedNodes.has(node)) {\n                        lintedNodes.add(node);\n                        hasReplaceableContent = true;\n                        const macroName = node.content;\n                        file.message(\n                            `Replace \"${printRaw(nodes)}\" with \"${printRaw(\n                                REPLACEMENTS[macroName](s(\"...\"), node)\n                            )}\"`,\n                            node\n                        );\n                    }\n                }\n\n                if (hasReplaceableContent && options?.fix) {\n                    // In an array replacements happen in-place\n                    replaceStreamingCommand(\n                        nodes,\n                        isReplaceable,\n                        (content, command) => {\n                            return REPLACEMENTS[command.content](\n                                content,\n                                command\n                            );\n                        }\n                    );\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n);\n"],"names":[],"mappings":"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"}