{"version":3,"file":"index.js","sources":["../../../utils/macro-factory.ts","../../../rules/unified-latex-lint-argument-font-shaping-commands/index.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Factory function that returns a wrapper which wraps the passed in `content`\n * as an arg to a macro named `macroName`.\n *\n * E.g.\n * ```\n * f = singleArgumentMacroFactory(\"foo\");\n *\n * // Gives \"\\\\foo{bar}\"\n * printRaw(f(\"bar\"));\n * ```\n */\nexport function singleArgMacroFactory(\n    macroName: string\n): (content: Ast.Node | Ast.Node[]) => Ast.Macro {\n    return (content: Ast.Node | Ast.Node[]) => {\n        if (!Array.isArray(content)) {\n            content = [content];\n        }\n        return {\n            type: \"macro\",\n            content: macroName,\n            args: [\n                {\n                    type: \"argument\",\n                    openMark: \"{\",\n                    closeMark: \"}\",\n                    content,\n                },\n            ],\n            _renderInfo: { inParMode: true },\n        };\n    };\n}\n","import { lintRule } from \"unified-lint-rule\";\nimport { m, s } from \"@unified-latex/unified-latex-builder\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { singleArgMacroFactory } from \"../../utils/macro-factory\";\nimport {\n    firstSignificantNode,\n    replaceNodeDuringVisit,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { replaceStreamingCommand } from \"@unified-latex/unified-latex-util-replace\";\nimport { hasBreakingNode } from \"../../utils/has-parbreak\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\nconst REPLACEMENTS: Record<\n    string,\n    (content: Ast.Node | Ast.Node[]) => Ast.Macro\n> = {\n    bfseries: singleArgMacroFactory(\"textbf\"),\n    itshape: singleArgMacroFactory(\"textit\"),\n    rmfamily: singleArgMacroFactory(\"textrm\"),\n    scshape: singleArgMacroFactory(\"textsc\"),\n    sffamily: singleArgMacroFactory(\"textsf\"),\n    slshape: singleArgMacroFactory(\"textsl\"),\n    ttfamily: singleArgMacroFactory(\"texttt\"),\n    em: singleArgMacroFactory(\"emph\"),\n};\n\nconst isReplaceable = match.createMacroMatcher(REPLACEMENTS);\n\n/**\n * Returns true if the `group` is a group that starts with one of the `REPLACEMENT` macros.\n */\nfunction groupStartsWithMacroAndHasNoParbreak(\n    group: Ast.Ast\n): group is Ast.Group {\n    if (!match.group(group)) {\n        return false;\n    }\n    // Find the first non-whitespace non-comment node\n    let firstNode: Ast.Node | null = firstSignificantNode(group.content);\n    return isReplaceable(firstNode) && !hasBreakingNode(group.content);\n}\n\ntype PluginOptions =\n    | {\n          /**\n           * Whether or not to fix the lint\n           *\n           * @type {boolean}\n           */\n          fix?: boolean;\n      }\n    | undefined;\n\nexport const DESCRIPTION = `## Lint Rule\n\nPrefer using text shaping commands with arguments (e.g. \\`\\\\textbf{foo bar}\\`) over in-stream text shaping commands\n(e.g. \\`{\\\\bfseries foo bar}\\`) if the style does not apply for multiple paragraphs.\nThis rule is useful when parsing LaTeX into other tree structures (e.g., when converting from LaTeX to HTML). \n\n\nThis rule flags any usage of \\`${Object.keys(REPLACEMENTS)\n    .map((r) => printRaw(m(r)))\n    .join(\"` `\")}\\`\n`;\n\nexport const unifiedLatexLintArgumentFontShapingCommands = lintRule<\n    Ast.Root,\n    PluginOptions\n>(\n    { origin: \"unified-latex-lint:argument-font-shaping-commands\" },\n    (tree, file, options) => {\n        const lintedNodes = new Set();\n\n        // We do two passes. First we deal with all the groups like `{\\bfseries xxx}`\n        // and then we replace all remaining streaming commands that appear in arrays.\n\n        visit(\n            tree,\n            (group, info) => {\n                const nodes = group.content;\n                for (const node of nodes) {\n                    if (isReplaceable(node) && !lintedNodes.has(node)) {\n                        lintedNodes.add(node);\n                        const macroName = node.content;\n                        file.message(\n                            `Replace \"${printRaw(group)}\" with \"${printRaw(\n                                REPLACEMENTS[macroName](s(\"...\"))\n                            )}\"`,\n                            node\n                        );\n                        break;\n                    }\n                }\n\n                if (options?.fix) {\n                    let fixed = replaceStreamingCommand(\n                        group,\n                        isReplaceable,\n                        (content, command) => {\n                            return REPLACEMENTS[command.content](content);\n                        }\n                    );\n\n                    // We cannot replace the node unless we can access the containing array.\n                    if (!info.containingArray || info.index == null) {\n                        return;\n                    }\n\n                    // `fixed` may consist of only whitespace. If this is the case,\n                    // surrounding whitespace must trimmed before\n                    // inserting the group's contents.\n                    const prevToken = info.containingArray[info.index - 1];\n                    const nextToken = info.containingArray[info.index + 1];\n                    if (\n                        match.whitespaceLike(prevToken) &&\n                        match.whitespaceLike(fixed[0])\n                    ) {\n                        trimStart(fixed);\n                    }\n                    if (\n                        match.whitespaceLike(nextToken) &&\n                        match.whitespaceLike(fixed[fixed.length - 1])\n                    ) {\n                        trimEnd(fixed);\n                    }\n                    replaceNodeDuringVisit(fixed, info);\n                }\n            },\n            { test: groupStartsWithMacroAndHasNoParbreak }\n        );\n\n        visit(\n            tree,\n            (nodes) => {\n                if (hasBreakingNode(nodes)) {\n                    return;\n                }\n\n                let hasReplaceableContent = false;\n                for (const node of nodes) {\n                    if (isReplaceable(node) && !lintedNodes.has(node)) {\n                        lintedNodes.add(node);\n                        hasReplaceableContent = true;\n                        const macroName = node.content;\n                        file.message(\n                            `Replace \"${printRaw(nodes)}\" with \"${printRaw(\n                                REPLACEMENTS[macroName](s(\"...\"))\n                            )}\"`,\n                            node\n                        );\n                    }\n                }\n\n                if (hasReplaceableContent && options?.fix) {\n                    // In an array replacements happen in-place\n                    replaceStreamingCommand(\n                        nodes,\n                        isReplaceable,\n                        (content, command) => {\n                            return REPLACEMENTS[command.content](content);\n                        }\n                    );\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n);\n"],"names":[],"mappings":"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"}