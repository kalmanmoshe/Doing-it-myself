{"version":3,"file":"index-CvNqyD-G.cjs","sources":["../../../node_modules/trough/lib/index.js","../../../node_modules/unified-lint-rule/lib/index.js"],"sourcesContent":["// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > itâ€™s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {0 | 1 | 2} Severity\n *   Numeric severity (`0`: `'off'`, `1`: `'on'`, `2`: `'error'`).\n * @typedef {'warn' | 'on' | 'off' | 'error'} Label\n *   Severity label (`'off'`: `0`, `'on'`: `1`, `'error'`: `2`).\n * @typedef {[Severity, ...Array<unknown>]} SeverityTuple\n *   Parsed severty and options.\n *\n * @typedef RuleMeta\n *   Rule metadata.\n * @property {string} origin\n *   Name of the lint rule.\n * @property {string | null | undefined} [url]\n *   Link to documentation.\n */\n\n/**\n * @template {Node} [Tree=Node]\n * @template {any} [Options=unknown]\n * @callback Rule\n * @param {Tree} tree\n * @param {VFile} file\n * @param {Options} options\n * @returns {Promise<Tree | undefined | void> | Tree | undefined | void}\n */\n\nimport {wrap} from 'trough'\n\n/**\n * @template {Node} [Tree=Node]\n * @template {any} [Options=unknown]\n * @param {string | RuleMeta} meta\n * @param {Rule<Tree, Options>} rule\n * @returns {import('unified').Plugin<Array<void> | [Options | [boolean | Label | Severity, (Options | undefined)?]], Tree>}\n */\nexport function lintRule(meta, rule) {\n  const id = typeof meta === 'string' ? meta : meta.origin\n  const url = typeof meta === 'string' ? undefined : meta.url\n  const parts = id.split(':')\n  // Possibly useful if externalised later.\n  /* c8 ignore next */\n  const source = parts[1] ? parts[0] : undefined\n  const ruleId = parts[1]\n\n  Object.defineProperty(plugin, 'name', {value: id})\n\n  // @ts-expect-error: to do: fix.\n  return plugin\n\n  /** @type {import('unified').Plugin<[unknown] | Array<void>>} */\n  function plugin(config) {\n    const [severity, options] = coerce(ruleId, config)\n\n    if (!severity) return\n\n    const fatal = severity === 2\n\n    return (tree, file, next) => {\n      let index = file.messages.length - 1\n\n      wrap(rule, (error) => {\n        const messages = file.messages\n\n        // Add the error, if not already properly added.\n        // Only happens for incorrect plugins.\n        /* c8 ignore next 6 */\n        // @ts-expect-error: errors could be `messages`.\n        if (error && !messages.includes(error)) {\n          try {\n            file.fail(error)\n          } catch {}\n        }\n\n        while (++index < messages.length) {\n          Object.assign(messages[index], {ruleId, source, fatal, url})\n        }\n\n        next()\n      })(tree, file, options)\n    }\n  }\n}\n\n/**\n * Coerce a value to a severity--options tuple.\n *\n * @param {string} name\n * @param {unknown} config\n * @returns {SeverityTuple}\n */\nfunction coerce(name, config) {\n  if (!Array.isArray(config)) return [1, config]\n  /** @type {Array<unknown>} */\n  const [severity, ...options] = config\n  switch (severity) {\n    case false:\n    case 'off':\n    case 0: {\n      return [0, ...options]\n    }\n\n    case true:\n    case 'on':\n    case 'warn':\n    case 1: {\n      return [1, ...options]\n    }\n\n    case 'error':\n    case 2: {\n      return [2, ...options]\n    }\n\n    default: {\n      if (typeof severity !== 'number') return [1, config]\n      throw new Error(\n        'Incorrect severity `' +\n          severity +\n          '` for `' +\n          name +\n          '`, ' +\n          'expected 0, 1, or 2'\n      )\n    }\n  }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}