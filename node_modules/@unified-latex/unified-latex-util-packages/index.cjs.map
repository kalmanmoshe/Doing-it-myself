{"version":3,"file":"index.cjs","sources":["../libs/arguments.ts","../libs/list-packages.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nfunction stripComments(nodes: Ast.Node[]): Ast.Node[] {\n    return nodes.filter((node) => node.type !== \"comment\");\n}\n\nfunction trimWithReturn(nodes: Ast.Node[]) {\n    trim(nodes);\n    return nodes;\n}\n\n/**\n * Split a list of nodes on a comma\n */\nfunction splitOnComma(nodes: Ast.Node[]): Ast.Node[][] {\n    const ret: Ast.Node[][] = [];\n    let curr: Ast.Node[] = [];\n    for (const node of stripComments(nodes)) {\n        if (node.type === \"string\" && node.content === \",\") {\n            ret.push(curr);\n            curr = [];\n        } else {\n            curr.push(node);\n        }\n    }\n    if (curr.length > 0) {\n        ret.push(curr);\n    }\n\n    return ret.map(trimWithReturn);\n}\n\n/**\n * Convert a list of nodes to string node, taking care to preserve the start and end\n * position of those nodes.\n */\nfunction nodesToString(nodes: Ast.Node[]): Ast.String {\n    if (nodes.length === 0) {\n        return { type: \"string\", content: \"\" };\n    }\n    if (nodes.length === 1 && nodes[0].type === \"string\") {\n        return nodes[0];\n    }\n    // We are going to return a new string, but we wan to preserve\n    // the start and end bounds.\n    const start = nodes[0].position?.start;\n    const end = nodes[nodes.length - 1].position?.end;\n    const ret: Ast.String = { type: \"string\", content: printRaw(nodes) };\n    if (start && end) {\n        Object.assign(ret, { position: { start, end } });\n    }\n    return ret;\n}\n\n/**\n * Process a list of nodes that should be comma-separated. The result\n * will be a list of `Ast.String` nodes. The start/end position of\n * these nodes is preserved.\n */\nexport function processCommaSeparatedList(nodes: Ast.Node[]): Ast.String[] {\n    return splitOnComma(nodes).map(nodesToString);\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { processCommaSeparatedList } from \"./arguments\";\n\nconst isUseOrRequirePackageMacro = match.createMacroMatcher([\n    \"usepackage\",\n    \"RequirePackage\",\n]);\n\n/**\n * List all packages referenced via `\\includepackage{...}` or `\\RequirePackage{...}`\n *\n * @param {Ast.Ast} tree\n * @returns {string[]}\n */\nexport function listPackages(tree: Ast.Ast): Ast.String[] {\n    const ret: Ast.String[] = [];\n    visit(\n        tree,\n        (node: Ast.Macro) => {\n            if (node.content === \"usepackage\") {\n                // The \\usepackage macro has signature []{}\n                const packages = processCommaSeparatedList(\n                    node.args ? node.args[1].content : []\n                );\n                ret.push(...packages);\n            }\n            if (node.content === \"RequirePackage\") {\n                // The \\RequirePackage macro has signature []{}\n                const packages = processCommaSeparatedList(\n                    node.args ? node.args[1].content : []\n                );\n                ret.push(...packages);\n            }\n        },\n        { test: isUseOrRequirePackageMacro }\n    );\n\n    return ret;\n}\n"],"names":["trim","printRaw","match","visit"],"mappings":";;;;;;AAIA,SAAS,cAAc,OAA+B;AAClD,SAAO,MAAM,OAAO,CAAC,SAAS,KAAK,SAAS,SAAS;AACzD;AAEA,SAAS,eAAe,OAAmB;AACvCA,uBAAA,KAAK,KAAK;AACH,SAAA;AACX;AAKA,SAAS,aAAa,OAAiC;AACnD,QAAM,MAAoB,CAAA;AAC1B,MAAI,OAAmB,CAAA;AACZ,aAAA,QAAQ,cAAc,KAAK,GAAG;AACrC,QAAI,KAAK,SAAS,YAAY,KAAK,YAAY,KAAK;AAChD,UAAI,KAAK,IAAI;AACb,aAAO,CAAA;AAAA,IAAC,OACL;AACH,WAAK,KAAK,IAAI;AAAA,IAClB;AAAA,EACJ;AACI,MAAA,KAAK,SAAS,GAAG;AACjB,QAAI,KAAK,IAAI;AAAA,EACjB;AAEO,SAAA,IAAI,IAAI,cAAc;AACjC;AAMA,SAAS,cAAc,OAA+B;;AAC9C,MAAA,MAAM,WAAW,GAAG;AACpB,WAAO,EAAE,MAAM,UAAU,SAAS,GAAG;AAAA,EACzC;AACA,MAAI,MAAM,WAAW,KAAK,MAAM,CAAC,EAAE,SAAS,UAAU;AAClD,WAAO,MAAM,CAAC;AAAA,EAClB;AAGA,QAAM,SAAQ,WAAM,CAAC,EAAE,aAAT,mBAAmB;AACjC,QAAM,OAAM,WAAM,MAAM,SAAS,CAAC,EAAE,aAAxB,mBAAkC;AAC9C,QAAM,MAAkB,EAAE,MAAM,UAAU,SAASC,yBAAA,SAAS,KAAK;AACjE,MAAI,SAAS,KAAK;AACP,WAAA,OAAO,KAAK,EAAE,UAAU,EAAE,OAAO,OAAO;AAAA,EACnD;AACO,SAAA;AACX;AAOO,SAAS,0BAA0B,OAAiC;AACvE,SAAO,aAAa,KAAK,EAAE,IAAI,aAAa;AAChD;AC1DA,MAAM,6BAA6BC,4BAAM,mBAAmB;AAAA,EACxD;AAAA,EACA;AACJ,CAAC;AAQM,SAAS,aAAa,MAA6B;AACtD,QAAM,MAAoB,CAAA;AAC1BC,wBAAA;AAAA,IACI;AAAA,IACA,CAAC,SAAoB;AACb,UAAA,KAAK,YAAY,cAAc;AAE/B,cAAM,WAAW;AAAA,UACb,KAAK,OAAO,KAAK,KAAK,CAAC,EAAE,UAAU,CAAC;AAAA,QAAA;AAEpC,YAAA,KAAK,GAAG,QAAQ;AAAA,MACxB;AACI,UAAA,KAAK,YAAY,kBAAkB;AAEnC,cAAM,WAAW;AAAA,UACb,KAAK,OAAO,KAAK,KAAK,CAAC,EAAE,UAAU,CAAC;AAAA,QAAA;AAEpC,YAAA,KAAK,GAAG,QAAQ;AAAA,MACxB;AAAA,IACJ;AAAA,IACA,EAAE,MAAM,2BAA2B;AAAA,EAAA;AAGhC,SAAA;AACX;;"}