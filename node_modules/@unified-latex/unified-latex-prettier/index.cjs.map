{"version":3,"file":"index.cjs","sources":["../libs/printer/common.ts","../libs/zip.ts","../libs/printer/macro.ts","../libs/printer/print-argument-pgfkeys.ts","../libs/printer/tikz.ts","../libs/printer/argument.ts","../libs/printer/root.ts","../libs/printer/comment.ts","../libs/printer/math.ts","../libs/printer/environment.ts","../libs/reference-map.ts","../libs/printer/printer.ts","../libs/prettier-plugin-latex.ts"],"sourcesContent":["import { builders } from \"prettier/doc\";\nimport type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Computes the environment name, start/end, and args.\n * E.g., for \"\\begin{x}abc\\end{x}\", it returns\n * ```\n * {\n *  envName: \"x\",\n *  start: \"\\\\begin{x}\",\n *  end: \"\\\\end{x}\",\n * }\n * ```\n *\n * @param {*} node\n * @returns\n */\nexport function formatEnvSurround(node: Ast.Environment) {\n    const env = printRaw(node.env);\n\n    return {\n        envName: env,\n        start: ESCAPE + \"begin{\" + env + \"}\",\n        end: ESCAPE + \"end{\" + env + \"}\",\n    };\n}\n\n/**\n * Determine if `elm` is a line type (softline/hardline/etc). If `elm` is an\n * array or a concat, the first element is checked.\n */\nfunction isLineType(elm: Doc): boolean {\n    if (elm == null || typeof elm === \"string\") {\n        return false;\n    }\n    if (Array.isArray(elm)) {\n        return isLineType(elm[0]);\n    }\n    // Perhaps we can sneak by with Prettier v2 compatibility?\n    if ((elm.type as any) === \"concat\") {\n        return isLineType((elm as any).parts);\n    }\n    return elm.type === \"line\";\n}\n\n/**\n * Join an array with `softline`. However, if a `line` is\n * found, do not insert an additional softline. For example\n * `[a, b, c]` -> `[a, softline, b, softline, c]`\n *\n * but\n *\n * `[a, line, b, c]` -> `[a, line, b, softline, c]`\n *\n * @param {*} arr\n * @returns\n */\nexport function joinWithSoftline(arr: Doc[]) {\n    if (arr.length === 0 || arr.length === 1) {\n        return arr;\n    }\n    const ret = [arr[0]];\n    for (let i = 1; i < arr.length; i++) {\n        const prevNode = arr[i - 1];\n        const nextNode = arr[i];\n        if (!isLineType(prevNode) && !isLineType(nextNode)) {\n            ret.push(softline);\n        }\n        ret.push(nextNode);\n    }\n    return ret;\n}\n\nexport function getNodeInfo(\n    node: any,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap }\n): {\n    renderInfo: Record<string, any>;\n    renderCache?: object;\n    previousNode?: Ast.Node;\n    nextNode?: Ast.Node;\n    referenceMap?: ReferenceMap;\n} {\n    if (!node) {\n        return { renderInfo: {} };\n    }\n    const renderInfo = node._renderInfo || {};\n    const previousNode =\n        options.referenceMap && options.referenceMap.getPreviousNode(node);\n    const nextNode =\n        options.referenceMap && options.referenceMap.getNextNode(node);\n    const renderCache =\n        options.referenceMap && options.referenceMap.getRenderCache(node);\n    // It's useful to know whether we're the start or end node in an array,\n    // so compute this information.\n    return {\n        renderInfo,\n        renderCache,\n        previousNode,\n        nextNode,\n        referenceMap: options.referenceMap,\n    };\n}\n\nexport const ESCAPE = \"\\\\\";\n\n// Commands to build the prettier syntax tree\nexport const {\n    group,\n    fill,\n    ifBreak,\n    line,\n    softline,\n    hardline,\n    lineSuffix,\n    lineSuffixBoundary,\n    breakParent,\n    indent,\n    markAsRoot,\n    join,\n} = builders;\n\n/**\n * Given an array of nodes and the corresponding printed versions, prepares\n * a final Doc array. This function does things like ensures there are `hardlines`\n * around environments and that there aren't excess hardlines at the start or end.\n * It also unwraps `inParMode` macro contents.\n *\n * @export\n * @param {Ast.Node[]} nodes\n * @param {Doc[]} docArray\n * @param {*} options\n * @returns {Doc[]}\n */\nexport function formatDocArray(\n    nodes: Ast.Node[],\n    docArray: Doc[],\n    options: any\n): Doc[] {\n    const ret: Doc[] = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n        const rawNode = nodes[i];\n        const printedNode = docArray[i];\n        const { renderInfo, referenceMap, previousNode, nextNode } =\n            getNodeInfo(rawNode, options);\n        const renderCache =\n            referenceMap && referenceMap.getRenderCache(rawNode);\n\n        switch (rawNode.type) {\n            case \"comment\":\n                // Comments don't insert hardlines themselves; they depend on appropriate\n                // hardlines being inserted here.\n\n                // This comment printer inserts hardlines after comments, so do not insert\n                // a hardline before a comment if there is a comment right before.\n                if (\n                    !rawNode.sameline &&\n                    previousNode &&\n                    !match.comment(previousNode) &&\n                    !match.parbreak(previousNode)\n                ) {\n                    ret.push(hardline);\n                }\n                ret.push(printedNode);\n                if (nextNode && !rawNode.suffixParbreak) {\n                    ret.push(hardline);\n                }\n                break;\n            case \"environment\":\n            case \"displaymath\":\n            case \"mathenv\":\n                // Environments always start on a new line (unless they are the first\n                // item). Peek to see if there is a newline inserted already.\n                if (previousNode && previousNode?.type !== \"parbreak\") {\n                    if (ret[ret.length - 1] === line) {\n                        // A preceding `line` should be converted into a `hardline`.\n                        // Remove the line so a hardline can be added\n                        ret.pop();\n                    }\n                    if (ret[ret.length - 1] !== hardline) {\n                        ret.push(hardline);\n                    }\n                }\n                ret.push(printedNode);\n                // If an environment is followed by whitespace, replace it with a hardline\n                // instead\n                if (nextNode?.type === \"whitespace\") {\n                    ret.push(hardline);\n                    i++;\n                }\n\n                break;\n            case \"macro\":\n                if (renderInfo.breakBefore || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be preceded by a hardline\n                    if (previousNode) {\n                        if (\n                            ret[ret.length - 1] === line ||\n                            ret[ret.length - 1] === hardline\n                        ) {\n                            // We may be replacing a hardline here for no reason. However,\n                            // if there is already a hardline, we don't want to continue\n                            // and accidentally add too many linebreaks\n                            ret.pop();\n                            ret.push(hardline);\n                        } else if (\n                            !match.comment(previousNode) &&\n                            !match.parbreak(previousNode)\n                        ) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                // Macros marked as `inParMode` should be unwrapped\n                // unless they have a hanging indent, in which case the macro\n                // has already be wrapped in an `indent` block\n                if (\n                    renderInfo.inParMode &&\n                    !renderInfo.hangingIndent &&\n                    renderCache\n                ) {\n                    ret.push(\n                        (renderCache as any).content,\n                        ...((renderCache as any).rawArgs || [])\n                    );\n                } else {\n                    ret.push(printedNode);\n                }\n                if (renderInfo.breakAfter || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be followed by a hardline\n                    if (nextNode) {\n                        if (match.whitespace(nextNode)) {\n                            ret.push(hardline);\n                            i++;\n                        } else if (match.parbreak(nextNode)) {\n                            // If the next node is a parbreak, it will insert its own newline\n                        } else if (!match.comment(nextNode)) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                break;\n            case \"parbreak\":\n                ret.push(hardline, hardline);\n                break;\n            default:\n                ret.push(printedNode);\n                break;\n        }\n    }\n\n    return ret;\n}\n","export function zip<T, U>(array1: T[], array2: U[]): [T, U][] {\n    const ret: [T, U][] = [];\n    const len = Math.min(array1.length, array2.length);\n    for (let i = 0; i < len; i++) {\n        ret.push([array1[i], array2[i]]);\n    }\n    return ret;\n}\n","import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, ESCAPE, indent, group } from \"./common\";\nimport { zip } from \"../zip\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport function printMacro(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Macro;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content =\n        (node.escapeToken != null ? node.escapeToken : ESCAPE) + node.content;\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n\n    // Some of the arguments want to be printed \"inline\".\n    // We loop through the arguments and unwrap the inline ones.\n    const rawArgs = [];\n    for (const [arg, printedArg] of zip(node.args || [], args)) {\n        const renderCache = referenceMap && referenceMap.getRenderCache(arg);\n        if (renderInfo.inParMode && renderCache) {\n            rawArgs.push(...(renderCache as any[]));\n        } else {\n            rawArgs.push(printedArg);\n        }\n    }\n\n    if (referenceMap) {\n        referenceMap.setRenderCache(node, { rawArgs, content });\n    }\n\n    if (renderInfo.hangingIndent) {\n        return indent(fill([content, ...rawArgs]));\n    }\n\n    return group([content, ...rawArgs]);\n}\n","import { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    hardline,\n    join,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n} from \"./common\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"@unified-latex/unified-latex-util-pgfkeys\";\n\n/**\n * Format a sequence of Pgfkeys key-value pairs. `nodes` will be parsed\n * by a grammar defining Pgfkeys\n */\nexport function printArgumentPgfkeys(\n    nodes: Ast.Node[],\n    options: {\n        openMark: string;\n        closeMark: string;\n        leadingComment?: Ast.Comment | null | undefined;\n        allowParenGroups?: boolean;\n    }\n): Doc {\n    const { allowParenGroups = false } = options;\n    const parsed = parsePgfkeys(nodes, { allowParenGroups });\n\n    const content: Doc[] = [];\n    for (const part of parsed) {\n        const isLastItem = part === parsed[parsed.length - 1];\n\n        if (part.itemParts) {\n            // parts are printed using `printRaw`, `hardline` is used in place\n            // of \"\\n\"\n            const parts = part.itemParts.map((node) =>\n                printRaw(node, { asArray: true }).map((token) =>\n                    token === linebreak ? hardline : token\n                )\n            );\n            const row = join(\"=\", parts);\n            content.push(row);\n            if (part.trailingComma) {\n                content.push(\",\");\n            }\n        }\n        if (part.trailingComment) {\n            const leadingContent: Doc[] = part.itemParts ? [\" \"] : [];\n            if (part.leadingParbreak) {\n                // We preserve parbreaks before comments, so if we have\n                // one, insert an extra hardline\n                leadingContent.push(hardline);\n            }\n\n            content.push(\n                ...leadingContent,\n                // We're carefully and manually controlling the newlines,\n                // so print the comment directly without any newlines\n                \"%\",\n                part.trailingComment.content,\n                breakParent\n            );\n        }\n\n        if (!isLastItem) {\n            content.push(line);\n        }\n    }\n\n    let leadingComment: Doc[] = [\"\"];\n    if (options.leadingComment) {\n        if (options.leadingComment.leadingWhitespace) {\n            leadingComment.push(\" \");\n        }\n        leadingComment.push(\"%\" + options.leadingComment.content, breakParent);\n    }\n\n    return group([\n        options.openMark,\n        ...leadingComment,\n        // If there is no content, we don't want to push an extra `softline`.\n        // This matters because the braces group could still be broken by `leadingComment`\n        content.length > 0 ? indent([softline, ...content]) : \"\",\n        softline,\n        options.closeMark,\n    ]);\n}\n","import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    formatDocArray,\n    hardline,\n    join,\n    ifBreak,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n    fill,\n} from \"./common\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport {\n    parse as parseTikz,\n    PathSpec,\n    PathSpecNode,\n    printRaw as tikzPrintRaw,\n} from \"@unified-latex/unified-latex-ctan/package/tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printTikzArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content: Doc[] = [];\n    const nodes = [...node.content];\n    trim(nodes);\n    try {\n        const tikzAst = parseTikz(nodes);\n        if (tikzAst.content.length === 0) {\n            content.push(\";\");\n            return content;\n        }\n\n        const printer = new TikzArgumentPrinter(tikzAst, path, print);\n        return printer.toDoc();\n    } catch (e) {\n        console.warn(\"Encountered error when trying to parse tikz argument\", e);\n    }\n\n    content.push(\";\");\n\n    return content;\n}\n\n/**\n * Print a fragment of an AST to a `Doc`.\n */\nfunction printFragment(\n    fragment: Ast.Node | Ast.Argument,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const tmpKey = Symbol();\n    const currNode = path.getNode();\n    if (!currNode) {\n        throw new Error(\n            \"tried to print a fragment, but the current node is `null`\"\n        );\n    }\n    (currNode as any)[tmpKey] = fragment;\n    const ret = print(tmpKey);\n    delete (currNode as any)[tmpKey];\n    return ret;\n}\n\n/**\n * Turn an item in a tikz PathSpec into a Doc for printing.\n */\nfunction printTikzPathSpecNode(\n    node: PathSpecNode,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    switch (node.type) {\n        case \"comment\":\n            return printFragment(node, path, print);\n        case \"unknown\":\n            // `\"unknown\"` nodes contain regular AST nodes as children which couldn't be identified by the parser\n            return printFragment(node.content, path, print);\n        case \"coordinate\":\n            return [printRaw(node.prefix), \"(\", printRaw(node.content), \")\"];\n        case \"line_to\":\n            return node.command;\n        case \"square_brace_group\":\n            return printOptionalArgs(node.content);\n        case \"operation\":\n            return node.content.content;\n        case \"svg_operation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const options = node.options ? printOptionalArgs(node.options) : [];\n            const rest: Doc[] = node.options\n                ? [group(indent([line, printRaw(node.content)]))]\n                : [\" \", printRaw(node.content)];\n            return [...comments, \"svg\", options, ...rest];\n        }\n        case \"curve_to\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const printedControls =\n                node.controls.length > 1\n                    ? [\n                          printTikzPathSpecNode(node.controls[0], path, print),\n                          \" \",\n                          \"and\",\n                          line,\n                          printTikzPathSpecNode(node.controls[1]!, path, print),\n                      ]\n                    : [printTikzPathSpecNode(node.controls[0], path, print)];\n            return [\n                ...comments,\n                \"..\",\n                \" \",\n                group(\n                    indent([\"controls\", line, ...printedControls, \" \", \"..\"])\n                ),\n            ];\n        }\n        case \"animation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n\n            return [\n                ...comments,\n                \":\",\n                node.attribute,\n                \" \",\n                \"=\",\n                \" \",\n                group(\n                    indent([\n                        printArgumentPgfkeys(node.content, {\n                            openMark: \"{\",\n                            closeMark: \"}\",\n                        }),\n                    ])\n                ),\n            ];\n        }\n        case \"foreach\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const variables = [...node.variables];\n            trim(variables);\n            const list =\n                node.list.type === \"macro\"\n                    ? printFragment(node.list, path, print)\n                    : printArgumentPgfkeys(node.list.content, {\n                          openMark: \"{\",\n                          closeMark: \"}\",\n                          allowParenGroups: true,\n                      });\n            const doc = [\n                ...comments,\n                printRaw(node.start),\n                \" \",\n                printRaw(variables),\n            ];\n            if (node.options) {\n                doc.push(\" \", indent(printOptionalArgs(node.options)));\n            }\n\n            // The list, e.g. `{1,2,...,9}`\n            doc.push(\" \", \"in\", \" \", group(indent(list)));\n            // The loop body\n            // XXX: if we are in a tikz node, whitespace doesn't matter. If we are in a regular\n            // part of the document, the loop body is whitespace-sensitive\n            const commandType = node.command.type;\n            switch (commandType) {\n                case \"foreach\":\n                    doc.push(\n                        indent([\n                            line,\n                            printTikzPathSpecNode(node.command, path, print),\n                        ])\n                    );\n                    break;\n                case \"macro\":\n                    doc.push(\n                        indent([line, printFragment(node.command, path, print)])\n                    );\n                    break;\n                case \"group\": {\n                    const groupContent = [...node.command.content];\n                    trim(groupContent);\n                    doc.push(\n                        \" \",\n                        indent(\n                            group([\n                                \"{\",\n                                indent([\n                                    softline,\n                                    ...groupContent.map((n) =>\n                                        printFragment(n, path, print)\n                                    ),\n                                ]),\n                                softline,\n                                \"}\",\n                            ])\n                        )\n                    );\n                    break;\n                }\n                default:\n                    const invalidType: void = commandType;\n                    console.warn(\n                        `Unhandled command type when printing \"foreach\": ${invalidType}`\n                    );\n            }\n\n            return indent(doc);\n        }\n    }\n    console.warn(\n        `Encountered unknown type when trying to print tikz PathSpec: \"${\n            (node as any).type\n        }\"`\n    );\n    return [];\n}\n\nfunction printOptionalArgs(nodes: Ast.Node[]): Doc {\n    return printArgumentPgfkeys(nodes, {\n        openMark: \"[\",\n        closeMark: \"]\",\n    });\n}\n\n/**\n * Utility to turn a Tikz PathSpec into a Prettier Doc.\n */\nclass TikzArgumentPrinter {\n    #path: PrettierTypes.AstPath;\n    #print: PrettierTypes.RecursivePrintFunc;\n    nodes: PathSpec[\"content\"];\n    constructor(\n        spec: PathSpec,\n        path: PrettierTypes.AstPath,\n        print: PrettierTypes.RecursivePrintFunc\n    ) {\n        this.#path = path;\n        this.#print = print;\n        this.nodes = [...spec.content];\n    }\n\n    nodeToDoc(node: PathSpecNode): Doc {\n        return printTikzPathSpecNode(node, this.#path, this.#print);\n    }\n\n    toDoc(): Doc {\n        const doc: Doc = [];\n        const startArg = this.eatOptionalArg();\n        if (startArg.optionalArg) {\n            doc.push(\n                ...startArg.comments.map((c) =>\n                    printFragment(c, this.#path, this.#print)\n                )\n            );\n            doc.push(printOptionalArgs(startArg.optionalArg.content));\n        }\n\n        const innerDoc: Doc = [];\n        doc.push(group([indent(innerDoc), \";\"]));\n        let cycle = -1;\n        while (this.nodes.length > 0) {\n            cycle++;\n            // If this is the first item being printed and the draw command has no optional\n            // argument, then we force the command to start printing on the same line.\n            const firstSep = cycle === 0 && !startArg.optionalArg ? \" \" : line;\n            const comingUp = this.peek();\n            switch (comingUp) {\n                case \"short_path\": {\n                    const [n0, n1, n2] = this.nodes.splice(0, 3);\n                    // A short path does not break\n                    innerDoc.push(\n                        firstSep,\n                        this.nodeToDoc(n0),\n                        \" \",\n                        this.nodeToDoc(n1),\n                        \" \",\n                        this.nodeToDoc(n2)\n                    );\n                    continue;\n                }\n                case \"long_path\": {\n                    // A long path consists of at least a node followed by a joiner\n                    const [n0, n1] = this.nodes.splice(0, 2);\n                    if (n1.type === \"operation\") {\n                        this.nodes.unshift(n1);\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.eatOperation()\n                        );\n                    } else {\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.nodeToDoc(n1)\n                        );\n                    }\n                    continue;\n                }\n                case \"node\":\n                    {\n                        const eatenNode = this.eatNode();\n                        if (eatenNode) {\n                            innerDoc.push(line, ...eatenNode);\n                            continue;\n                        }\n                        console.warn(\n                            \"Expected to print a tikz `node` PathSpec but couldn't find the text `node`\"\n                        );\n                    }\n                    continue;\n                case \"operation\":\n                    innerDoc.push(firstSep, this.eatOperation());\n                    continue;\n                case \"unknown\": {\n                    const node = this.nodes.shift()!;\n                    innerDoc.push(firstSep, this.nodeToDoc(node));\n                    continue;\n                }\n            }\n            this.nodes.shift();\n        }\n\n        return doc;\n    }\n\n    /**\n     * Look at the current node and the nodes that follow. Return what\n     * \"type\" is recognized.\n     */\n    peek() {\n        // A short path is two coordinates, joined by a line_to (with no coordinates/line_to's following).\n        // If there are comments intermixed, the short path is broken.\n        const [n0, n1, n2, n3] = [\n            this.nodes[0],\n            this.nodes[1],\n            this.nodes[2],\n            this.nodes[3],\n        ];\n        if (n0?.type === \"coordinate\" && isPathJoinOperation(n1)) {\n            if (\n                n2?.type === \"coordinate\" &&\n                !(n3?.type === \"coordinate\" || isPathJoinOperation(n3))\n            ) {\n                return \"short_path\";\n            }\n            return \"long_path\";\n        }\n        if (n0?.type === \"operation\") {\n            if (n0.content.content === \"node\") {\n                // Nodes are a special type of operation.\n                return \"node\";\n            }\n            return \"operation\";\n        }\n\n        return \"unknown\";\n    }\n\n    /**\n     * Eat comments and an optional arg if present. If no optional\n     * arg is present, do nothing.\n     */\n    eatOptionalArg() {\n        let i = 0;\n        const comments: Ast.Comment[] = [];\n        let optionalArg:\n            | (PathSpecNode & { type: \"square_brace_group\" })\n            | null = null;\n        for (; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node.type === \"square_brace_group\") {\n                optionalArg = node;\n                i++;\n                break;\n            }\n            if (node.type === \"comment\") {\n                comments.push(node);\n                continue;\n            }\n            break;\n        }\n        if (optionalArg) {\n            // If we grabbed an optional argument, remove it and everything\n            // preceding it.\n            this.nodes.splice(0, i);\n        }\n        return { optionalArg, comments };\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node whose contents is `\"node\"`. I.e.,\n     * the type of thing that shows up in `\\path node at (1,1) {foo};`\n     */\n    eatNode(): Doc[] | null {\n        const firstNode = this.nodes[0];\n        if (\n            firstNode?.type === \"operation\" &&\n            firstNode.content.content === \"node\"\n        ) {\n            this.nodes.shift();\n        } else {\n            return null;\n        }\n\n        // From the tikz documentation:\n        // \\path … node ⟨foreach statements⟩ [⟨options⟩] (⟨name⟩) at(⟨coordinate⟩)\n        //       :⟨animation attribute⟩={⟨options⟩} {⟨node contents⟩} …;\n        //\n        // Order of the parts of the specification.\n        // Everything between “node” and the opening brace of a node is optional.\n        // If there are ⟨foreach statements⟩, they must come first, directly following “node”.\n        // Other than that, the ordering of all the other elements of a node specification\n        // (the ⟨options⟩, the ⟨name⟩, ⟨coordinate⟩, and ⟨animation attribute⟩) is arbitrary, indeed,\n        // there can be multiple occurrences of any of these elements (although for the name and the\n        // coordinate this makes no sense).\n\n        const innerDoc: Doc = [];\n        const commentBlock: Doc = [];\n        const doc: Doc = [commentBlock, \"node\", group(indent(innerDoc))];\n        // We now peek to see if a group `{...}` is the next thing. If so,\n        // we're going to eat everything up to it and call it quits. Otherwise,\n        // we bail.\n        let hasNodeArgument = false;\n        let shouldBail = false;\n        let i = 0;\n        const comments: Doc[] = [];\n        const options: Doc[] = [];\n        const name: Doc[] = [];\n        const atLocations: Doc[] = [];\n        const animations: Doc[] = [];\n        let content: Doc = [];\n        for (; i < this.nodes.length && !shouldBail; i++) {\n            const node = this.nodes[i];\n            switch (node.type) {\n                case \"animation\":\n                    animations.push(this.nodeToDoc(node));\n                    continue;\n                case \"comment\": {\n                    const comment: Ast.Comment = {\n                        ...node,\n                        leadingWhitespace: false,\n                    };\n                    comments.push(this.nodeToDoc(comment));\n                    continue;\n                }\n                case \"square_brace_group\":\n                    options.push(printOptionalArgs(node.content));\n                    continue;\n                case \"coordinate\":\n                    name.push(this.nodeToDoc(node));\n                    continue;\n                case \"operation\": {\n                    // An \"at\" should be followed by a coordinate or a macro. If it is,\n                    // then we slurp it. Otherwise we bail.\n                    if (node.content.content === \"at\") {\n                        const nextNode = this.nodes[i + 1];\n                        if (\n                            !nextNode ||\n                            !(\n                                nextNode.type === \"coordinate\" ||\n                                (nextNode.type === \"unknown\" &&\n                                    match.anyMacro(nextNode.content))\n                            )\n                        ) {\n                            shouldBail = true;\n                            continue;\n                        }\n                        atLocations.push([\"at\", \" \", this.nodeToDoc(nextNode)]);\n                        i++;\n                        continue;\n                    }\n                    shouldBail = true;\n                    continue;\n                }\n                case \"unknown\": {\n                    // If we're here, we must be the termination group.\n                    if (match.group(node.content)) {\n                        hasNodeArgument = true;\n                        content = this.nodeToDoc(node);\n                    }\n                    // NOTE: the fallthrough here is on purpose. Finding the terminating\n                    // groups should end our loop.\n                }\n            }\n            break;\n        }\n        if (!hasNodeArgument) {\n            return innerDoc;\n        }\n        // We have collected docs for all the nodes we've scanned, so delete\n        // them from the list.\n        this.nodes.splice(0, i + 1);\n\n        // We standardize node rendering as `[options] :animations (name) at (pos) {content}`\n        let isFirstElement = true;\n        let isNamed = !(Array.isArray(name) && name.length === 0);\n        // Comments get hoisted to before the \"node\" keyword\n        for (const comment of comments) {\n            commentBlock.push(comment, hardline);\n        }\n        if (options.length > 0) {\n            innerDoc.push(join(\" \", options));\n            isFirstElement = false;\n        }\n        if (animations.length > 0) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(join(line, animations));\n            isFirstElement = false;\n        }\n        if (isNamed) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(name);\n            isFirstElement = false;\n        }\n        if (atLocations.length > 0) {\n            innerDoc.push(isFirstElement || isNamed ? \" \" : line);\n            innerDoc.push(join(line, atLocations));\n            isFirstElement = false;\n        }\n        innerDoc.push(line, content);\n\n        return doc;\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node, including its optional arguments.\n     */\n    eatOperation(): Doc[] {\n        const node = this.nodes[0];\n        if (node?.type === \"operation\") {\n            this.nodes.shift();\n        } else {\n            return [];\n        }\n\n        const doc: Doc[] = [];\n        if (node?.type !== \"operation\") {\n            throw new Error(\"Expecting `operation` node.\");\n        }\n        const options = this.eatOptionalArg();\n        doc.push(\n            ...options.comments.map((c) =>\n                printFragment(c, this.#path, this.#print)\n            ),\n            node.content.content\n        );\n        if (options.optionalArg) {\n            doc.push(indent(printOptionalArgs(options.optionalArg.content)));\n        }\n\n        return doc;\n    }\n}\n\nconst PATH_JOIN_OPERATIONS = new Set([\"rectangle\", \"grid\", \"sin\", \"cos\", \"to\"]);\n/**\n * Return whether `node` is a \"path join\", like `--`, `rectangle`, etc.\n *\n * A path join is an operation that sits between two coordinates, like\n * `(a) -- (b)` or `(a) rectangle (b)`.\n */\nfunction isPathJoinOperation(node?: PathSpecNode): boolean {\n    if (!node) {\n        return false;\n    }\n    switch (node.type) {\n        case \"line_to\":\n        case \"curve_to\":\n            return true;\n        case \"operation\":\n            return PATH_JOIN_OPERATIONS.has(node.content.content);\n    }\n    return false;\n}\n","import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, formatDocArray, hardline, ifBreak, fill } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printTikzArgument } from \"./tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    // We can return early for empty arguments (this is common for omitted optional arguments)\n    if (\n        node.openMark === \"\" &&\n        node.closeMark === \"\" &&\n        node.content.length === 0\n    ) {\n        return [];\n    }\n    const parentNode = path.getParentNode();\n    const { renderInfo: parentRenderInfo } = getNodeInfo(parentNode, options);\n    // We handle printing pgfkeys arguments manually\n    if (parentRenderInfo.pgfkeysArgs) {\n        const leadingComment =\n            node.content.length > 0 &&\n            match.comment(node.content[0]) &&\n            node.content[0].sameline\n                ? node.content[0]\n                : null;\n        const content = leadingComment ? node.content.slice(1) : node.content;\n        trim(content);\n        return printArgumentPgfkeys(content, {\n            openMark: node.openMark,\n            closeMark: node.closeMark,\n            leadingComment,\n        });\n    }\n    if (parentRenderInfo.tikzPathCommand) {\n        return printTikzArgument(path, print, options);\n    }\n\n    // Regular argument printing\n    const openMark = node.openMark;\n    const closeMark = node.closeMark;\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n\n    // if the last item is a comment, we need to insert a hardline\n    if (match.comment(node.content[node.content.length - 1])) {\n        content.push(hardline);\n    }\n\n    let rawRet: Doc[] = [openMark, fill(content), closeMark];\n    if (renderInfo.inParMode) {\n        // In paragraph node, arguments should flow just like text\n        rawRet = [openMark, ...content, closeMark];\n    }\n    if (referenceMap) {\n        // Save the raw rendered data in case a renderer higher up\n        // wants to unwrap it\n        referenceMap.setRenderCache(node, rawRet);\n    }\n\n    return rawRet;\n}\n","import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, formatDocArray } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns true if a `\\documentclass` macro is detected,\n * which would indicate that the node list contains the preamble.\n *\n * @param {[object]} nodes\n */\nexport function hasPreambleCode(nodes: Ast.Node[]) {\n    return nodes.some((node) => match.macro(node, \"documentclass\"));\n}\n\nexport function printRoot(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Root;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content = path.map(print, \"content\");\n    const rawContent = formatDocArray(node.content, content, options);\n\n    const concatFunction = hasPreambleCode(node.content) ? (x: any) => x : fill;\n    return concatFunction(rawContent);\n}\n","import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nexport function printComment(\n    path: PrettierTypes.AstPath,\n    _print: PrettierTypes.RecursivePrintFunc,\n    _options: any\n): Doc {\n    const node = path.getNode() as Ast.Comment;\n\n    // If a comment is on the same line as other content and it has leading whitespace,\n    // add a single whitespace token.\n    let leadingWhitespace = \"\";\n    if (node.leadingWhitespace && node.sameline) {\n        leadingWhitespace = \" \";\n    }\n\n    const content: Doc[] = [leadingWhitespace, \"%\" + printRaw(node.content)];\n    return content;\n}\n","import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    hardline,\n    line,\n    indent,\n    ESCAPE,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\n\nexport function printInlineMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    // Since `$$` starts display math mode (in plain TeX),\n    // an empty inline math environment must be printed as `$ $`.\n    // We special case this.\n    if (node.content.length === 0) {\n        // We won't allow an empty math environment to be broken\n        return [\"$\", \" \", \"$\"];\n    }\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If the last node is a comment, we need a linebreak before the closing `$`\n    if (node.content[node.content.length - 1].type === \"comment\") {\n        content.push(hardline);\n    }\n\n    return fill([\"$\", ...content, \"$\"]);\n}\n\nexport function printDisplayMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    const bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        ESCAPE + \"[\",\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        ESCAPE + \"]\",\n    ];\n}\n","import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    indent,\n    hardline,\n    line,\n    ESCAPE,\n    formatEnvSurround,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nexport function printVerbatimEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.VerbatimEnvironment;\n\n    const env = formatEnvSurround(node as any);\n\n    return [env.start, node.content, env.end];\n}\n\nexport function printEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    if (renderInfo.inMathMode) {\n        content = joinWithSoftline(content);\n    }\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    let bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        env.start,\n        ...args,\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        env.end,\n    ];\n}\n\nexport function printAlignedEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    // If an aligned environment starts with a same-line comment, we want\n    // to ignore it. It will be printed by the environment itself.\n    const leadingComment =\n        node.content[0] &&\n        node.content[0].type === \"comment\" &&\n        node.content[0].sameline\n            ? node.content[0]\n            : null;\n\n    const { rows, rowSeps, trailingComments } = formatAlignedContent(\n        leadingComment ? node.content.slice(1) : node.content\n    );\n\n    const content = [];\n    for (let i = 0; i < rows.length; i++) {\n        const row = rows[i];\n        const rowSep = rowSeps[i];\n        const trailingComment = trailingComments[i];\n\n        // A row has\n        // 1) Content\n        // 2) (optional) rowSep (e.g., `\\\\`)\n        // 3) (optional) comment\n        // We want there to be exactly one space before the rowsep and exactly one space\n        // before any comment.\n        content.push(row);\n        if (rowSep) {\n            content.push(printRaw(rowSep));\n        }\n        if (rowSep && trailingComment) {\n            content.push(\" \");\n        }\n        if (trailingComment) {\n            content.push([\"%\", printRaw(trailingComment.content)]);\n        }\n        if (rowSep || trailingComment) {\n            content.push(hardline);\n        }\n    }\n    // Make sure the last item is not a `hardline`.\n    if (content[content.length - 1] === hardline) {\n        content.pop();\n    }\n\n    if (leadingComment) {\n        content.unshift(\n            leadingComment.leadingWhitespace ? \" \" : \"\",\n            \"%\" + printRaw(leadingComment.content),\n            hardline\n        );\n        return [env.start, ...args, indent(content), hardline, env.end];\n    }\n    return [\n        env.start,\n        ...args,\n        indent([hardline, ...content]),\n        hardline,\n        env.end,\n    ];\n}\n\n/**\n * Formats the content of an aligned/tabular environment's content.\n * Ensures the \"&\" delimiters all line up.\n *\n * @export\n * @param {[object]} nodes\n * @returns {{rows: [string], rowSeps: [object]}}\n */\nexport function formatAlignedContent(nodes: Ast.Node[]) {\n    function getSpace(len = 1) {\n        return \" \".repeat(len);\n    }\n\n    const rows = parseAlignEnvironment(nodes as any);\n    // Find the number of columns\n    const numCols = Math.max(...rows.map((r) => r.cells.length));\n    const rowSeps = rows.map(({ rowSep }) => printRaw(rowSep || []));\n    const trailingComments = rows.map(({ trailingComment }) => trailingComment);\n\n    // Get the widths of each column.\n    // Column widths will be the width of column contents plus the width\n    // of the separator. This way, even multi-character separators\n    // can be accommodated when rendering.\n    const renderedRows = rows.map(({ cells, colSeps }) => ({\n        cells: cells.map((nodes) => {\n            trim(nodes);\n\n            return printRaw(nodes);\n        }),\n        seps: colSeps.map((nodes) => printRaw(nodes)),\n    }));\n    const colWidths: number[] = [];\n    for (let i = 0; i < numCols; i++) {\n        colWidths.push(\n            Math.max(\n                ...renderedRows.map(\n                    ({ cells, seps }) =>\n                        ((cells[i] || \"\") + (seps[i] || \"\")).length\n                )\n            )\n        );\n    }\n\n    const joinedRows = renderedRows.map(({ cells, seps }) => {\n        if (cells.length === 1 && cells[0] === \"\") {\n            return \"\";\n        }\n        let ret = \"\";\n        for (let i = 0; i < cells.length; i++) {\n            // There are at least as many cells as there are `seps`. Possibly one extra\n            const width = colWidths[i] - (seps[i] || \"\").length;\n\n            // Insert a space at the start so we don't run into the prior separator.\n            // We'll trim this off in the end, in case it's not needed.\n            ret +=\n                (i === 0 ? \"\" : \" \") +\n                cells[i] +\n                getSpace(width - cells[i].length + 1) +\n                (seps[i] || \"\");\n        }\n        return ret;\n    });\n\n    return { rows: joinedRows, rowSeps, trailingComments };\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Generate a data structure that can be queried\n * for the next/previous node. This allows for \"peeking\"\n * during the rendering process.\n *\n * @class ReferenceMap\n */\nexport class ReferenceMap {\n    ast: Ast.Ast;\n    map: Map<\n        Ast.Ast,\n        { previous?: Ast.Ast; next?: Ast.Ast; renderCache?: any }\n    >;\n\n    constructor(ast: Ast.Ast) {\n        this.ast = ast;\n        this.map = new Map();\n        visit(\n            this.ast,\n            (nodeList) => {\n                for (let i = 0; i < nodeList.length; i++) {\n                    this.map.set(nodeList[i], {\n                        previous: nodeList[i - 1],\n                        next: nodeList[i + 1],\n                    });\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n\n    /**\n     * Associate render-specific data with this node. This data\n     * will be overwritten if `setRenderCache` is called twice.\n     *\n     * @param {Ast.Ast} node\n     * @param {*} data\n     * @memberof ReferenceMap\n     */\n    setRenderCache(node: any, data: any): void {\n        const currData = this.map.get(node) || {};\n        this.map.set(node, { ...currData, renderCache: data });\n    }\n\n    /**\n     * Retrieve data associated with `node` via `setRenderCache`\n     *\n     * @param {Ast.Ast} node\n     * @returns {(object | undefined)}\n     * @memberof ReferenceMap\n     */\n    getRenderCache(node: any): object | any[] | undefined {\n        return this.map.get(node)?.renderCache;\n    }\n\n    getPreviousNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).previous;\n    }\n\n    getNextNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).next;\n    }\n}\n","import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nimport { hardline, line, ESCAPE, getNodeInfo } from \"./common\";\nimport { printMacro } from \"./macro\";\nimport { printArgument } from \"./argument\";\nimport { printRoot } from \"./root\";\nimport { printComment } from \"./comment\";\nimport { printInlineMath, printDisplayMath } from \"./math\";\nimport {\n    printVerbatimEnvironment,\n    printEnvironment,\n    printAlignedEnvironment,\n} from \"./environment\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\n\nexport function printLatexAst(\n    path: PrettierTypes.AstPath,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap },\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const node = path.getValue();\n    const { renderInfo } = getNodeInfo(node, options);\n\n    if (node == null) {\n        return node;\n    }\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    switch (node.type) {\n        case \"root\":\n            // Create the ReferenceMap from the root node, so that\n            // it can traverse the entire AST\n            if (options.referenceMap) {\n                console.warn(\n                    \"Processing root node, but ReferenceMap already exists. Are there multiple nodes of type 'root'?\"\n                );\n            }\n            options.referenceMap = new ReferenceMap(node);\n            return printRoot(path, print, options);\n        case \"argument\":\n            return printArgument(path, print, options);\n        case \"comment\":\n            return printComment(path, print, options);\n        case \"environment\":\n        case \"mathenv\":\n            if (renderInfo.alignContent) {\n                return printAlignedEnvironment(path, print, options);\n            }\n            return printEnvironment(path, print, options);\n        case \"displaymath\":\n            return printDisplayMath(path, print, options);\n        case \"group\":\n            // When we print a group, we are conservative and do a raw print of its contents.\n            // However, we want to use `linebreak`s instead of literal `\\n` tokens.\n            const content = printRaw(node.content, {\n                asArray: true,\n            }).map((token) => (token === linebreak ? hardline : token));\n            return [\"{\", ...content, \"}\"];\n        case \"inlinemath\":\n            return printInlineMath(path, print, options);\n        case \"macro\":\n            return printMacro(path, print, options);\n        case \"parbreak\":\n            return [hardline, hardline];\n        case \"string\":\n            return node.content;\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                printRaw(node.content),\n                node.escape,\n            ];\n        case \"verbatim\":\n            return printVerbatimEnvironment(path, print, options);\n        case \"whitespace\":\n            return line;\n        default:\n            console.warn(`Printing unknown type ${readableType(node)}`, node);\n            return printRaw(node);\n    }\n}\n\n/**\n * Get a printable type for an object.\n */\nfunction readableType(obj: any): string {\n    if (obj == null) {\n        return \"null\";\n    }\n    if (Array.isArray(obj)) {\n        return \"array\";\n    }\n    return typeof obj;\n}\n","import type { Plugin, Printer } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parse } from \"@unified-latex/unified-latex-util-parse\";\nimport { printLatexAst } from \"./printer\";\n\nconst languages = [\n    {\n        name: \"latex\",\n        extensions: [\".tex\"],\n        parsers: [\"latex-parser\"],\n    },\n];\n\nconst parsers = {\n    \"latex-parser\": {\n        parse,\n        astFormat: \"latex-ast\",\n        locStart: (node: Ast.Node) =>\n            node.position ? node.position.start.offset : 0,\n        locEnd: (node: Ast.Node) =>\n            node.position ? node.position.end.offset : 1,\n    },\n};\n\nconst printers = {\n    \"latex-ast\": {\n        print: printLatexAst,\n    } as Printer,\n};\n\nconst prettierPluginLatex: Plugin<Ast.Node> = { languages, parsers, printers };\n\nexport { prettierPluginLatex };\n"],"names":["printRaw","builders","match","parsePgfkeys","linebreak","trim","parseTikz","doc","content","_print","parseAlignEnvironment","nodes","visit","parse"],"mappings":"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"}