{"version":3,"file":"index.cjs","sources":["../libs/parse.ts","../libs/print-glue.ts","../libs/find-glue.ts"],"sourcesContent":["import { GluePegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { Glue } from \"./types\";\n\n/**\n * Parse a string that starts with TeX glue (e.g. `1pt` or `1pt plus 2em`).\n * It is assumed that all whitespace and comments have been stripped from the glue\n */\nexport function parseTexGlue(source: string): Glue | null {\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    try {\n        return GluePegParser.parse(source);\n    } catch {}\n    return null;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Glue } from \"./types\";\n\n/**\n * Prints a `Glue` object to an AST. After printing, `glue`\n * is turned into a sequence of string and whitespace nodes.\n * All structural information about the glue is lost.\n */\nexport function printGlue(glue: Glue): Ast.Node[] {\n    const ret: Ast.Node[] = [\n        { type: \"string\", content: `${glue.fixed.value}${glue.fixed.unit}` },\n    ];\n    if (glue.stretchable) {\n        ret.push({ type: \"whitespace\" });\n        ret.push({ type: \"string\", content: \"plus\" });\n        ret.push({ type: \"whitespace\" });\n        ret.push({\n            type: \"string\",\n            content: `${glue.stretchable.value}${glue.stretchable.unit}`,\n        });\n    }\n    if (glue.shrinkable) {\n        ret.push({ type: \"whitespace\" });\n        ret.push({ type: \"string\", content: \"minus\" });\n        ret.push({ type: \"whitespace\" });\n        ret.push({\n            type: \"string\",\n            content: `${glue.shrinkable.value}${glue.shrinkable.unit}`,\n        });\n    }\n\n    return ret;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { parseTexGlue } from \"./parse\";\nimport { printGlue } from \"./print-glue\";\n\n/**\n * Finds patterns matching TeX glue in `nodes`. A pretty-formatted version\n * of the glue is returned along with information about how many nodes were consumed.\n *\n * The return object consists of\n *   * `printedGlue` - the pretty-printed version of the glue\n *   * `endIndex` - the index in `nodes` where the glue string terminates\n *   * `partialSliceLen` - how far into the `Ast.String` node the glue string finished. For example `1ptXX` would parse as `1pt`, and the parsing would terminate partway through the string node.\n */\nexport function findGlue(\n    nodes: (Ast.Node | Ast.Argument)[],\n    startIndex: number\n): {\n    printedGlue: Ast.Node[];\n    endIndex: number;\n    partialSliceLen: number;\n} | null {\n    let searchString = \"\";\n    const sourceIndices: number[] = [];\n    // We create a string until we run into a token that cannot be used\n    // in a length definition. We keep track of the \"source indices\" for every\n    // character in our string.\n    for (let i = startIndex; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.whitespace(node) || match.comment(node)) {\n            continue;\n        }\n        if (!match.anyString(node)) {\n            break;\n        }\n        searchString += node.content;\n        // Keep track of the corresponding source indices\n        node.content.split(\"\").forEach(() => sourceIndices.push(i));\n    }\n\n    // Now we look for the glue\n    const glue = parseTexGlue(searchString);\n    if (!glue) {\n        return null;\n    }\n    const printedGlue = printGlue(glue);\n    const glueLen = glue.position.end.offset;\n    // The glue could have ended partway through a string node. If so\n    // we want to compute how far in we've sliced\n    const firstInstanceOfNodeIndex = sourceIndices.indexOf(\n        sourceIndices[glueLen]\n    );\n    return {\n        printedGlue,\n        endIndex: sourceIndices[glueLen - 1],\n        partialSliceLen: glueLen - firstInstanceOfNodeIndex,\n    };\n}\n\n/**\n * Extract glue from a list of nodes returning a node array with\n * properly formatted glue as well as start/end indices where the glue was\n * \"sliced out\" of `nodes`.\n *\n * Sometimes glue may end in the middle of a string node. If this happens, the\n * string node is split and the second half is returned in the `trailingStrings` array.\n */\nexport function extractFormattedGlue(\n    nodes: (Ast.Node | Ast.Argument)[],\n    startIndex: number\n): {\n    glue: Ast.Node[];\n    span: { start: number; end: number };\n    trailingStrings: Ast.String[];\n} | null {\n    const glue = findGlue(nodes, startIndex);\n    if (!glue) {\n        return null;\n    }\n    let trailingStrings: Ast.String[] = [];\n    const retNodes = glue.printedGlue;\n    // We might have split the last string node while searching for the glue. If so\n    // we need to create a new string node that contains the remaining information.\n    const lastString = nodes[glue.endIndex];\n    if (lastString.type !== \"string\") {\n        throw new Error(`Expect string node, but found \"${lastString.type}\"`);\n    }\n    if (lastString.content.length > glue.partialSliceLen) {\n        trailingStrings.push({\n            type: \"string\",\n            content: lastString.content.slice(glue.partialSliceLen),\n        });\n    }\n    return {\n        glue: retNodes,\n        span: { start: startIndex, end: glue.endIndex },\n        trailingStrings,\n    };\n}\n"],"names":["GluePegParser","match"],"mappings":";;;;AAOO,SAAS,aAAa,QAA6B;AAGlD,MAAA;AACO,WAAAA,sBAAA,cAAc,MAAM,MAAM;AAAA,EAAA,QAC7B;AAAA,EAAC;AACF,SAAA;AACX;ACNO,SAAS,UAAU,MAAwB;AAC9C,QAAM,MAAkB;AAAA,IACpB,EAAE,MAAM,UAAU,SAAS,GAAG,KAAK,MAAM,KAAK,GAAG,KAAK,MAAM,IAAI,GAAG;AAAA,EAAA;AAEvE,MAAI,KAAK,aAAa;AAClB,QAAI,KAAK,EAAE,MAAM,aAAc,CAAA;AAC/B,QAAI,KAAK,EAAE,MAAM,UAAU,SAAS,QAAQ;AAC5C,QAAI,KAAK,EAAE,MAAM,aAAc,CAAA;AAC/B,QAAI,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,GAAG,KAAK,YAAY,KAAK,GAAG,KAAK,YAAY,IAAI;AAAA,IAAA,CAC7D;AAAA,EACL;AACA,MAAI,KAAK,YAAY;AACjB,QAAI,KAAK,EAAE,MAAM,aAAc,CAAA;AAC/B,QAAI,KAAK,EAAE,MAAM,UAAU,SAAS,SAAS;AAC7C,QAAI,KAAK,EAAE,MAAM,aAAc,CAAA;AAC/B,QAAI,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,GAAG,KAAK,WAAW,KAAK,GAAG,KAAK,WAAW,IAAI;AAAA,IAAA,CAC3D;AAAA,EACL;AAEO,SAAA;AACX;AClBgB,SAAA,SACZ,OACA,YAKK;AACL,MAAI,eAAe;AACnB,QAAM,gBAA0B,CAAA;AAIhC,WAAS,IAAI,YAAY,IAAI,MAAM,QAAQ,KAAK;AACtC,UAAA,OAAO,MAAM,CAAC;AACpB,QAAIC,sBAAAA,MAAM,WAAW,IAAI,KAAKA,sBAAAA,MAAM,QAAQ,IAAI,GAAG;AAC/C;AAAA,IACJ;AACA,QAAI,CAACA,sBAAA,MAAM,UAAU,IAAI,GAAG;AACxB;AAAA,IACJ;AACA,oBAAgB,KAAK;AAEhB,SAAA,QAAQ,MAAM,EAAE,EAAE,QAAQ,MAAM,cAAc,KAAK,CAAC,CAAC;AAAA,EAC9D;AAGM,QAAA,OAAO,aAAa,YAAY;AACtC,MAAI,CAAC,MAAM;AACA,WAAA;AAAA,EACX;AACM,QAAA,cAAc,UAAU,IAAI;AAC5B,QAAA,UAAU,KAAK,SAAS,IAAI;AAGlC,QAAM,2BAA2B,cAAc;AAAA,IAC3C,cAAc,OAAO;AAAA,EAAA;AAElB,SAAA;AAAA,IACH;AAAA,IACA,UAAU,cAAc,UAAU,CAAC;AAAA,IACnC,iBAAiB,UAAU;AAAA,EAAA;AAEnC;AAUgB,SAAA,qBACZ,OACA,YAKK;AACC,QAAA,OAAO,SAAS,OAAO,UAAU;AACvC,MAAI,CAAC,MAAM;AACA,WAAA;AAAA,EACX;AACA,MAAI,kBAAgC,CAAA;AACpC,QAAM,WAAW,KAAK;AAGhB,QAAA,aAAa,MAAM,KAAK,QAAQ;AAClC,MAAA,WAAW,SAAS,UAAU;AAC9B,UAAM,IAAI,MAAM,kCAAkC,WAAW,IAAI,GAAG;AAAA,EACxE;AACA,MAAI,WAAW,QAAQ,SAAS,KAAK,iBAAiB;AAClD,oBAAgB,KAAK;AAAA,MACjB,MAAM;AAAA,MACN,SAAS,WAAW,QAAQ,MAAM,KAAK,eAAe;AAAA,IAAA,CACzD;AAAA,EACL;AACO,SAAA;AAAA,IACH,MAAM;AAAA,IACN,MAAM,EAAE,OAAO,YAAY,KAAK,KAAK,SAAS;AAAA,IAC9C;AAAA,EAAA;AAER;;;;;"}