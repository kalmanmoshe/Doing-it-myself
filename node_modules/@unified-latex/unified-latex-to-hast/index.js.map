{"version":3,"file":"index.js","sources":["../libs/html-subs/to-hast.ts","../libs/split-for-pars.ts","../libs/wrap-pars.ts","../libs/pre-html-subs/environment-subs.ts","../libs/pre-html-subs/katex-subs.ts","../libs/pre-html-subs/macro-subs.ts","../libs/pre-html-subs/streaming-command-subs.ts","../libs/unified-latex-wrap-pars.ts","../libs/unified-latex-plugin-to-html-like.ts","../libs/unified-latex-plugin-to-hast.ts","../libs/convert-to-html.ts"],"sourcesContent":["import * as Hast from \"hast\";\nimport { h } from \"hastscript\";\nimport {\n    extractFromHtmlLike,\n    isHtmlLikeTag,\n} from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\nfunction formatNodeForError(node: Ast.Node | any): string {\n    try {\n        return printRaw(node);\n    } catch {}\n    return JSON.stringify(node);\n}\n\ntype HastNode = Hast.Element | Hast.Text | Hast.Comment;\n\n/**\n * Create a `toHast` function that will log by making a call to `logger`.\n */\nexport function toHastWithLoggerFactory(\n    logger: (message: string, node: any) => void\n) {\n    /**\n     * Convert Ast.Node to Hast nodes.\n     */\n    return function toHast(\n        node: Ast.Node | Ast.Argument\n    ): HastNode | HastNode[] {\n        // Because `isHtmlLikeTag` is a type guard, if we use it directly on\n        // `node` here, then in the switch statement `node.type === \"macro\"` will be `never`.\n        // We rename the variable to avoid this issue.\n        const htmlNode = node;\n        if (isHtmlLikeTag(htmlNode)) {\n            const extracted = extractFromHtmlLike(htmlNode);\n            const attributes: Record<string, any> = extracted.attributes;\n            return h(\n                extracted.tag,\n                attributes,\n                extracted.content.flatMap(toHast)\n            );\n        }\n\n        switch (node.type) {\n            case \"string\":\n                return {\n                    type: \"text\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"comment\":\n                return {\n                    type: \"comment\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"inlinemath\":\n                return h(\n                    \"span\",\n                    { className: \"inline-math\" },\n                    printRaw(node.content)\n                );\n            case \"mathenv\":\n            case \"displaymath\":\n                return h(\n                    \"div\",\n                    { className: \"display-math\" },\n                    printRaw(node.content)\n                );\n            case \"verb\":\n            case \"verbatim\":\n                return h(\"pre\", { className: node.env }, node.content);\n            case \"whitespace\":\n                return { type: \"text\", value: \" \", position: node.position };\n            case \"parbreak\":\n                return h(\"br\");\n            case \"group\":\n                // Groups are just ignored.\n                return node.content.flatMap(toHast);\n            case \"environment\":\n                logger(\n                    `Unknown environment when converting to HTML \\`${formatNodeForError(\n                        node.env\n                    )}\\``,\n                    node\n                );\n                return h(\n                    \"div\",\n                    { className: [\"environment\", printRaw(node.env)] },\n                    node.content.flatMap(toHast)\n                );\n            case \"macro\":\n                logger(\n                    `Unknown macro when converting to HTML \\`${formatNodeForError(\n                        node\n                    )}\\``,\n                    node\n                );\n                return h(\n                    \"span\",\n                    { className: [\"macro\", `macro-${node.content}`] },\n                    (node.args || []).map(toHast).flat()\n                );\n            case \"argument\":\n                return h(\n                    \"span\",\n                    {\n                        className: [\"argument\"],\n                        \"data-open-mark\": node.openMark,\n                        \"data-close-mark\": node.closeMark,\n                    },\n                    printRaw(node.content)\n                );\n            case \"root\":\n                return node.content.flatMap(toHast);\n            default: {\n                const _exhaustiveCheck: never = node;\n                throw new Error(\n                    `Unknown node type; cannot convert to HAST ${JSON.stringify(\n                        node\n                    )}`\n                );\n            }\n        }\n    };\n}\n\n/**\n * Convert Ast.Node to Hast nodes.\n */\nexport const toHast = toHastWithLoggerFactory(console.warn);\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Takes an array of nodes and splits it into chunks that should be wrapped\n * in HTML `<p>...</p>` tags, vs. not. By default environments are not wrapped\n * unless they are specified, and macros are included in a par unless they are excluded.\n *\n */\nexport function splitForPars(\n    nodes: Ast.Node[],\n    options: {\n        macrosThatBreakPars: string[];\n        environmentsThatDontBreakPars: string[];\n    }\n): { content: Ast.Node[]; wrapInPar: boolean }[] {\n    const ret: { content: Ast.Node[]; wrapInPar: boolean }[] = [];\n    let currBody: Ast.Node[] = [];\n    trim(nodes);\n\n    const isParBreakingMacro = match.createMacroMatcher(\n        options.macrosThatBreakPars\n    );\n    const isEnvThatShouldNotBreakPar = match.createEnvironmentMatcher(\n        options.environmentsThatDontBreakPars\n    );\n\n    /**\n     * Push and clear the contents of `currBody` to the return array.\n     * If there are any contents, it should be wrapped in an array.\n     */\n    function pushBody() {\n        if (currBody.length > 0) {\n            trim(currBody);\n            ret.push({ content: currBody, wrapInPar: true });\n            currBody = [];\n        }\n    }\n\n    for (const node of nodes) {\n        if (isParBreakingMacro(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.anyEnvironment(node) && !isEnvThatShouldNotBreakPar(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        // Display-math should always break pars\n        if (node.type === \"displaymath\") {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.parbreak(node) || match.macro(node, \"par\")) {\n            pushBody();\n            continue;\n        }\n        currBody.push(node);\n    }\n    pushBody();\n\n    return ret;\n}\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { splitForPars } from \"./split-for-pars\";\n\n/**\n * Wrap paragraphs in `<p>...</p>` tags.\n *\n * Paragraphs are inserted at\n *   * parbreak tokens\n *   * macros listed in `macrosThatBreakPars`\n *   * environments not listed in `environmentsThatDontBreakPars`\n */\nexport function wrapPars(\n    nodes: Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"paragraph\",\n            \"subparagraph\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    const parSplits = splitForPars(nodes, {\n        macrosThatBreakPars,\n        environmentsThatDontBreakPars,\n    });\n\n    return parSplits.flatMap((part) => {\n        if (part.wrapInPar) {\n            return htmlLike({ tag: \"p\", content: part.content });\n        } else {\n            return part.content;\n        }\n    });\n}\n","import cssesc from \"cssesc\";\nimport {\n    parseTabularSpec,\n    TabularColumn,\n} from \"@unified-latex/unified-latex-ctan/package/tabularx\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport {\n    getArgsContent,\n    getNamedArgsContent,\n} from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { wrapPars } from \"../wrap-pars\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\n\nconst ITEM_ARG_NAMES_REG = [\"label\"] as const;\nconst ITEM_ARG_NAMES_BEAMER = [null, \"label\", null] as const;\ntype ItemArgs = Record<\n    (typeof ITEM_ARG_NAMES_REG)[number],\n    Ast.Node[] | null\n> & {\n    body: Ast.Node[];\n};\n\n/**\n * Extract the arguments to an `\\item` macro.\n */\nfunction getItemArgs(node: Ast.Macro): ItemArgs {\n    if (!Array.isArray(node.args)) {\n        throw new Error(\n            `Cannot find \\\\item macros arguments; you must attach the \\\\item body to the macro before calling this function ${JSON.stringify(\n                node\n            )}`\n        );\n    }\n    // The \"body\" has been added as a last argument to the `\\item` node. We\n    // ignore this argument when comparing argument signatures.\n    const argNames =\n        node.args.length - 1 === ITEM_ARG_NAMES_BEAMER.length\n            ? ITEM_ARG_NAMES_BEAMER\n            : ITEM_ARG_NAMES_REG;\n    const ret = Object.assign(\n        { body: node.args[node.args.length - 1].content },\n        getNamedArgsContent(node, argNames)\n    );\n    return ret as ItemArgs;\n}\n\nfunction enumerateFactory(parentTag = \"ol\", className = \"enumerate\") {\n    return function enumerateToHtml(env: Ast.Environment) {\n        // The body of an enumerate has already been processed and all relevant parts have\n        // been attached to \\item macros as arguments.\n        const items = env.content.filter((node) => match.macro(node, \"item\"));\n        const content = items.flatMap((node) => {\n            if (!match.macro(node) || !node.args) {\n                return [];\n            }\n\n            const attributes: Record<string, string | Record<string, string>> =\n                {};\n            // Figure out if there any manually-specified item labels. If there are,\n            // we need to specify a custom list-style-type.\n            // We test the open mark to see if an optional argument was actually supplied.\n            const namedArgs = getItemArgs(node);\n            if (namedArgs.label != null) {\n                const formattedLabel = cssesc(printRaw(namedArgs.label || []));\n                attributes.style = {\n                    // Note the space after `formattedLabel`. That is on purpose!\n                    \"list-style-type\": formattedLabel\n                        ? `'${formattedLabel} '`\n                        : \"none\",\n                };\n            }\n\n            const body = namedArgs.body;\n            return htmlLike({\n                tag: \"li\",\n                content: wrapPars(body),\n                attributes,\n            });\n        });\n\n        return htmlLike({\n            tag: parentTag,\n            attributes: { className },\n            content,\n        });\n    };\n}\n\nfunction createCenteredElement(env: Ast.Environment) {\n    return htmlLike({\n        tag: \"center\",\n        attributes: { className: \"center\" },\n        content: env.content,\n    });\n}\n\nfunction createTableFromTabular(env: Ast.Environment) {\n    const tabularBody = parseAlignEnvironment(env.content);\n    const args = getArgsContent(env);\n    let columnSpecs: TabularColumn[] = [];\n    try {\n        columnSpecs = parseTabularSpec(args[1] || []);\n    } catch (e) {}\n\n    const tableBody = tabularBody.map((row) => {\n        const content = row.cells.map((cell, i) => {\n            const columnSpec = columnSpecs[i];\n            const styles: Record<string, string> = {};\n            if (columnSpec) {\n                const { alignment } = columnSpec;\n                if (alignment.alignment === \"center\") {\n                    styles[\"text-align\"] = \"center\";\n                }\n                if (alignment.alignment === \"right\") {\n                    styles[\"text-align\"] = \"right\";\n                }\n                if (\n                    columnSpec.pre_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    styles[\"border-left\"] = \"1px solid\";\n                }\n                if (\n                    columnSpec.post_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    styles[\"border-right\"] = \"1px solid\";\n                }\n            }\n            return htmlLike(\n                Object.keys(styles).length > 0\n                    ? {\n                          tag: \"td\",\n                          content: cell,\n                          attributes: { style: styles },\n                      }\n                    : {\n                          tag: \"td\",\n                          content: cell,\n                      }\n            );\n        });\n        return htmlLike({ tag: \"tr\", content });\n    });\n\n    return htmlLike({\n        tag: \"table\",\n        content: [\n            htmlLike({\n                tag: \"tbody\",\n                content: tableBody,\n            }),\n        ],\n        attributes: { className: \"tabular\" },\n    });\n}\n\n/**\n * Rules for replacing a macro with an html-like macro\n * that will render has html when printed.\n */\nexport const environmentReplacements: Record<\n    string,\n    (\n        node: Ast.Environment,\n        info: VisitInfo\n    ) => Ast.Macro | Ast.String | Ast.Environment\n> = {\n    enumerate: enumerateFactory(\"ol\"),\n    itemize: enumerateFactory(\"ul\", \"itemize\"),\n    center: createCenteredElement,\n    tabular: createTableFromTabular,\n    quote: (env) => {\n        return htmlLike({\n            tag: \"blockquote\",\n            content: env.content,\n            attributes: { className: \"environment quote\" },\n        });\n    },\n};\n","import {\n    attachSystemeSettingsAsRenderInfo,\n    systemeContentsToArray,\n} from \"@unified-latex/unified-latex-ctan/package/systeme\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport KATEX_SUPPORT_LIST from \"../katex-support.json\";\n\nconst LEFT: Ast.Macro = { type: \"macro\", content: \"left\" };\nconst RIGHT: Ast.Macro = { type: \"macro\", content: \"right\" };\nconst DEFAULT_LEFT_DELIM: Ast.Macro = { type: \"macro\", content: \"{\" };\nconst DEFAULT_RIGHT_DELIM: Ast.String = { type: \"string\", content: \".\" };\n\nexport const katexSpecificMacroReplacements: Record<\n    string,\n    (node: Ast.Macro) => Ast.Node | Ast.Node[]\n> = {\n    systeme: (node) => {\n        try {\n            const args = getArgsContent(node);\n            const whitelistedVariables = (args[1] || undefined) as\n                | (Ast.String | Ast.Macro)[]\n                | undefined;\n            const equations = args[3] || [];\n            const ret = systemeContentsToArray(equations, {\n                properSpacing: false,\n                whitelistedVariables,\n            });\n\n            // If we have information about the sysdelims, then apply them\n            if (node?._renderInfo?.sysdelims) {\n                const [frontDelim, backDelim]: [Ast.Node[], Ast.Node[]] = node\n                    ._renderInfo?.sysdelims as any;\n\n                return [\n                    LEFT,\n                    ...(frontDelim || []),\n                    ret,\n                    RIGHT,\n                    ...(backDelim || []),\n                ];\n            }\n\n            return [LEFT, DEFAULT_LEFT_DELIM, ret, RIGHT, DEFAULT_RIGHT_DELIM];\n        } catch (e) {\n            return node;\n        }\n    },\n    sysdelim: () => [],\n};\n\nfunction wrapInDisplayMath(ast: Ast.Node | Ast.Node[]): Ast.Node {\n    const content = Array.isArray(ast) ? ast : [ast];\n\n    return { type: \"displaymath\", content };\n}\n\nexport const katexSpecificEnvironmentReplacements: Record<\n    string,\n    (node: Ast.Environment) => Ast.Node | Ast.Node[]\n> = {\n    // katex supports the align environments, but it will only render them\n    // if you are already in math mode. Warning: these will produce invalid latex!\n    align: wrapInDisplayMath,\n    \"align*\": wrapInDisplayMath,\n    alignat: wrapInDisplayMath,\n    \"alignat*\": wrapInDisplayMath,\n    equation: wrapInDisplayMath,\n    \"equation*\": wrapInDisplayMath,\n};\n\n/**\n * Attach `renderInfo` needed for converting some macros into their\n * katex equivalents.\n */\nexport function attachNeededRenderInfo(ast: Ast.Ast) {\n    attachSystemeSettingsAsRenderInfo(ast);\n}\n\nexport const KATEX_SUPPORT = {\n    macros: KATEX_SUPPORT_LIST[\"KATEX_MACROS\"],\n    environments: KATEX_SUPPORT_LIST[\"KATEX_ENVIRONMENTS\"],\n};\n","import { xcolorMacroToHex } from \"@unified-latex/unified-latex-ctan/package/xcolor\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Factory function that generates html-like macros that wrap their contents.\n */\nfunction factory(\n    tag: string,\n    attributes?: Record<string, string>\n): (macro: Ast.Macro) => Ast.Macro {\n    return (macro) => {\n        if (!macro.args) {\n            throw new Error(\n                `Found macro to replace but couldn't find content ${printRaw(\n                    macro\n                )}`\n            );\n        }\n        // Assume the meaningful argument is the last argument. This\n        // ensures that we can convert for default packages as well as\n        // packages like beamer, which may add optional arguments.\n        const args = getArgsContent(macro);\n        const content = args[args.length - 1] || [];\n        return htmlLike({ tag, content, attributes });\n    };\n}\n\nfunction createHeading(tag: string, attrs = {}) {\n    return (macro: Ast.Macro) => {\n        const args = getArgsContent(macro);\n        const starred = !!args[0];\n        const attributes: Record<string, string> = starred\n            ? { className: \"starred\" }\n            : {};\n\n        if (attrs) {\n            Object.assign(attributes, attrs);\n        }\n\n        return htmlLike({\n            tag,\n            content: args[args.length - 1] || [],\n            attributes,\n        });\n    };\n}\n\nexport const macroReplacements: Record<\n    string,\n    (node: Ast.Macro, info: VisitInfo) => Ast.Node\n> = {\n    emph: factory(\"em\", { className: \"emph\" }),\n    textrm: factory(\"span\", { className: \"textrm\" }),\n    textsf: factory(\"span\", { className: \"textsf\" }),\n    texttt: factory(\"span\", { className: \"texttt\" }),\n    textsl: factory(\"span\", { className: \"textsl\" }),\n    textit: factory(\"i\", { className: \"textit\" }),\n    textbf: factory(\"b\", { className: \"textbf\" }),\n    underline: factory(\"u\", { className: \"underline\" }),\n    mbox: factory(\"span\", { className: \"mbox\" }),\n    phantom: factory(\"span\", { className: \"phantom\" }),\n    part: createHeading(\"h1\"),\n    chapter: createHeading(\"h2\"),\n    section: createHeading(\"h3\"),\n    subsection: createHeading(\"h4\"),\n    subsubsection: createHeading(\"h5\"),\n    paragraph: createHeading(\"h6\", { className: \"section-paragraph\" }),\n    subparagraph: createHeading(\"h6\", {\n        className: \"section-subparagraph\",\n    }),\n    appendix: createHeading(\"h2\"),\n    smallskip: () =>\n        htmlLike({\n            tag: \"br\",\n            attributes: { className: \"smallskip\" },\n        }),\n    medskip: () =>\n        htmlLike({\n            tag: \"br\",\n            attributes: { className: \"medskip\" },\n        }),\n    bigskip: () =>\n        htmlLike({\n            tag: \"br\",\n            attributes: { className: \"bigskip\" },\n        }),\n    \"\\n\": () =>\n        htmlLike({\n            tag: \"br\",\n            attributes: { className: \"literal-newline\" },\n        }),\n    url: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[0] || \"#\");\n        return htmlLike({\n            tag: \"a\",\n            attributes: {\n                className: \"url\",\n                href: url,\n            },\n            content: [{ type: \"string\", content: url }],\n        });\n    },\n    href: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[1] || \"#\");\n        return htmlLike({\n            tag: \"a\",\n            attributes: {\n                className: \"href\",\n                href: url,\n            },\n            content: args[2] || [],\n        });\n    },\n    hyperref: (node) => {\n        const args = getArgsContent(node);\n        const url = \"#\" + printRaw(args[0] || \"\");\n        return htmlLike({\n            tag: \"a\",\n            attributes: {\n                className: \"href\",\n                href: url,\n            },\n            content: args[1] || [],\n        });\n    },\n    \"\\\\\": () =>\n        htmlLike({\n            tag: \"br\",\n            attributes: { className: \"linebreak\" },\n        }),\n    vspace: (node) => {\n        const args = getArgsContent(node);\n        return htmlLike({\n            tag: \"div\",\n            attributes: {\n                className: \"vspace\",\n                \"data-amount\": printRaw(args[1] || []),\n            },\n            content: [],\n        });\n    },\n    hspace: (node) => {\n        const args = getArgsContent(node);\n        return htmlLike({\n            tag: \"span\",\n            attributes: {\n                className: \"vspace\",\n                \"data-amount\": printRaw(args[1] || []),\n            },\n            content: [],\n        });\n    },\n    textcolor: (node) => {\n        const args = getArgsContent(node);\n        const computedColor = xcolorMacroToHex(node);\n        const color = computedColor.hex;\n\n        if (color) {\n            return htmlLike({\n                tag: \"span\",\n                attributes: { style: `color: ${color};` },\n                content: args[2] || [],\n            });\n        } else {\n            // If we couldn't compute the color, it's probably a named\n            // color that wasn't supplied. In this case, we fall back to a css variable\n            return htmlLike({\n                tag: \"span\",\n                attributes: {\n                    style: `color: var(${computedColor.cssVarName});`,\n                },\n                content: args[2] || [],\n            });\n        }\n    },\n    textsize: (node) => {\n        const args = getArgsContent(node);\n        const textSize = printRaw(args[0] || []);\n        return htmlLike({\n            tag: \"span\",\n            attributes: {\n                className: `textsize-${textSize}`,\n            },\n            content: args[1] || [],\n        });\n    },\n    makebox: (node) => {\n        const args = getArgsContent(node);\n        return htmlLike({\n            tag: \"span\",\n            attributes: {\n                className: `latex-box`,\n                style: \"display: inline-block;\",\n            },\n            content: args[3] || [],\n        });\n    },\n    noindent: () => ({ type: \"string\", content: \"\" }),\n    includegraphics: (node) => {\n        const args = getArgsContent(node);\n        const src = printRaw(args[args.length - 1] || []);\n        return htmlLike({\n            tag: \"img\",\n            attributes: {\n                className: \"includegraphics\",\n                src,\n            },\n            content: [],\n        });\n    },\n};\n","import { arg, m } from \"@unified-latex/unified-latex-builder\";\nimport { colorToTextcolorMacro } from \"@unified-latex/unified-latex-ctan/package/xcolor\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Factory function that generates a macro with bound arguments.\n *\n * e.g.\n * ```\n * factory(\"foo\")(\"bar\") -> `\\foo{bar}`\n * ```\n *\n * ```\n * factory(\"foo\", \"baz\")(\"bar\") -> `\\foo{baz}{bar}`\n * ```\n */\nfunction factory(\n    macroName: string,\n    ...boundArgs: string[]\n): (content: Ast.Node[], originalCommand: Ast.Macro) => Ast.Macro {\n    return (content, originalCommand) => {\n        return m(macroName, boundArgs.map((a) => arg(a)).concat(arg(content)));\n    };\n}\n\nexport const streamingMacroReplacements = {\n    color: colorToTextcolorMacro,\n    bfseries: factory(\"textbf\"),\n    itshape: factory(\"textit\"),\n    rmfamily: factory(\"textrm\"),\n    scshape: factory(\"textsc\"),\n    sffamily: factory(\"textsf\"),\n    slshape: factory(\"textsl\"),\n    ttfamily: factory(\"texttt\"),\n    Huge: factory(\"textsize\", \"Huge\"),\n    huge: factory(\"textsize\", \"huge\"),\n    LARGE: factory(\"textsize\", \"LARGE\"),\n    Large: factory(\"textsize\", \"Large\"),\n    large: factory(\"textsize\", \"large\"),\n    normalsize: factory(\"textsize\", \"normalsize\"),\n    small: factory(\"textsize\", \"small\"),\n    footnotesize: factory(\"textsize\", \"footnotesize\"),\n    scriptsize: factory(\"textsize\", \"scriptsize\"),\n    tiny: factory(\"textsize\", \"tiny\"),\n};\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { wrapPars } from \"./wrap-pars\";\n\ntype PluginOptions = {\n    macrosThatBreakPars?: string[];\n    environmentsThatDontBreakPars?: string[];\n} | void;\n\n/**\n * Unified plugin to wrap paragraphs in `\\html-tag:p{...}` macros.\n * Because `-` and `:` cannot occur in regular macros, there is no risk of\n * a conflict.\n */\nexport const unifiedLatexWrapPars: Plugin<PluginOptions[], Ast.Root, Ast.Root> =\n    function unifiedLatexWrapPars(options) {\n        const { macrosThatBreakPars, environmentsThatDontBreakPars } =\n            options || {};\n        return (tree) => {\n            // If \\begin{document}...\\end{document} is present, we only wrap pars inside of it.\n            let hasDocumentEnv = false;\n            visit(\n                tree,\n                (env) => {\n                    if (match.environment(env, \"document\")) {\n                        hasDocumentEnv = true;\n\n                        // While we're here, we might as well wrap the pars!\n                        env.content = wrapPars(env.content, {\n                            macrosThatBreakPars,\n                            environmentsThatDontBreakPars,\n                        });\n\n                        return EXIT;\n                    }\n                },\n                { test: match.anyEnvironment }\n            );\n\n            if (!hasDocumentEnv) {\n                // If there is no \\begin{document}...\\end{document}, we wrap top-level pars only.\n                tree.content = wrapPars(tree.content, {\n                    macrosThatBreakPars,\n                    environmentsThatDontBreakPars,\n                });\n            }\n        };\n    };\n","import * as Hast from \"hast\";\nimport { Plugin, unified } from \"unified\";\nimport { unifiedLatexLintNoTexFontShapingCommands } from \"@unified-latex/unified-latex-lint/rules/unified-latex-lint-no-tex-font-shaping-commands\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    replaceNode,\n    unifiedLatexReplaceStreamingCommands,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { environmentReplacements as _environmentReplacements } from \"./pre-html-subs/environment-subs\";\nimport {\n    attachNeededRenderInfo,\n    katexSpecificEnvironmentReplacements,\n    katexSpecificMacroReplacements,\n} from \"./pre-html-subs/katex-subs\";\nimport { macroReplacements as _macroReplacements } from \"./pre-html-subs/macro-subs\";\nimport { streamingMacroReplacements } from \"./pre-html-subs/streaming-command-subs\";\nimport { unifiedLatexWrapPars } from \"./unified-latex-wrap-pars\";\n\ntype EnvironmentReplacements = typeof _environmentReplacements;\ntype MacroReplacements = typeof _macroReplacements;\n\nexport type PluginOptions = {\n    /**\n     * Functions called to replace environments during processing. Key values should match environment names.\n     *  You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    environmentReplacements?: EnvironmentReplacements;\n    /**\n     * Functions called to replace macros during processing. Key values should match macro names.\n     * You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    macroReplacements?: MacroReplacements;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into an html-like AST. This replaces nodes\n * with html-like macros `\\html-tag:p{...}`, etc. macros. It is a step along the way to converting to HTML.\n * **It is unlikely you want to use this plugin directly**.\n *\n * Note: this plugin only wraps paragraphs in `p` tags if there are multiple paragraphs. Otherwise it omits the <p> tags.\n */\nexport const unifiedLatexToHtmlLike: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Hast.Root\n> = function unifiedLatexToHtmlLike(options) {\n    const macroReplacements = Object.assign(\n        {},\n        _macroReplacements,\n        options?.macroReplacements || {}\n    );\n    const environmentReplacements = Object.assign(\n        {},\n        _environmentReplacements,\n        options?.environmentReplacements || {}\n    );\n    const isReplaceableMacro = match.createMacroMatcher(macroReplacements);\n    const isReplaceableEnvironment = match.createEnvironmentMatcher(\n        environmentReplacements\n    );\n    const isKatexMacro = match.createMacroMatcher(\n        katexSpecificMacroReplacements\n    );\n    const isKatexEnvironment = match.createEnvironmentMatcher(\n        katexSpecificEnvironmentReplacements\n    );\n\n    return (tree) => {\n        const originalTree = tree;\n        // NOTE: These operations need to be done in a particular order.\n\n        // We _could_ keep comments around in html, but that can complicate dealing with whitespace,\n        // so we remove them.\n        deleteComments(tree);\n        let processor = unified()\n            // Replace `\\bf` etc. with `\\bfseries`. Only the latter are auto-recognized streaming commands\n            .use(unifiedLatexLintNoTexFontShapingCommands, { fix: true })\n            .use(unifiedLatexReplaceStreamingCommands, {\n                replacers: streamingMacroReplacements,\n            });\n\n        // Must be done *after* streaming commands are replaced.\n        // We only wrap PARs if we *need* to. That is, if the content contains multiple paragraphs\n        if (shouldBeWrappedInPars(tree)) {\n            processor = processor.use(unifiedLatexWrapPars);\n        }\n        tree = processor.runSync(tree);\n\n        // Replace text-mode environments and then macros. Environments *must* be processed first, since\n        // environments like tabular use `\\\\` as a newline indicator, but a `\\\\` macro gets replaced with\n        // a `<br />` during macro replacement.\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableEnvironment(node)) {\n                return environmentReplacements[printRaw(node.env)](node, info);\n            }\n        });\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableMacro(node)) {\n                const replacement = macroReplacements[node.content](node, info);\n                return replacement;\n            }\n        });\n\n        // Replace math-mode macros for appropriate KaTeX rendering\n        attachNeededRenderInfo(tree);\n        replaceNode(tree, (node) => {\n            if (isKatexMacro(node)) {\n                return katexSpecificMacroReplacements[node.content](node);\n            }\n            if (isKatexEnvironment(node)) {\n                return katexSpecificEnvironmentReplacements[printRaw(node.env)](\n                    node\n                );\n            }\n        });\n\n        // Make sure we are actually mutating the current tree.\n        originalTree.content = tree.content;\n    };\n};\n\n/**\n * Does the content contain multiple paragraphs? If so, it should be wrapped in `p` tags.\n */\nfunction shouldBeWrappedInPars(tree: Ast.Root): boolean {\n    let content = tree.content;\n    visit(\n        tree,\n        (env) => {\n            if (match.anyEnvironment(env)) {\n                content = env.content;\n                return EXIT;\n            }\n        },\n        { test: (node) => match.environment(node, \"document\") }\n    );\n\n    return content.some(\n        (node) => match.parbreak(node) || match.macro(node, \"par\")\n    );\n}\n","import * as Hast from \"hast\";\nimport rehypeRaw from \"rehype-raw\";\nimport { h } from \"hastscript\";\nimport { Plugin, unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { TypeGuard } from \"@unified-latex/unified-latex-types\";\nimport { expandUnicodeLigatures } from \"@unified-latex/unified-latex-util-ligatures\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { toHastWithLoggerFactory } from \"./html-subs/to-hast\";\nimport {\n    unifiedLatexToHtmlLike,\n    PluginOptions as HtmlLikePluginOptions,\n} from \"./unified-latex-plugin-to-html-like\";\n\nexport type PluginOptions = HtmlLikePluginOptions & {\n    /**\n     * By default, `unifiedLatexToHast` will force the output to be valid HTML.\n     * This is accomplished by running `rehypeRaw` on the output which will ensure\n     * there are no nested `<p>` tags, and that block elements don't end up as children of `<span>`s,\n     * etc. Set to `true` to skip this check.\n     */\n    skipHtmlValidation?: boolean;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into a `hast` AST.\n */\nexport const unifiedLatexToHast: Plugin<PluginOptions[], Ast.Root, Hast.Root> =\n    function unifiedLatexAttachMacroArguments(options) {\n        const { skipHtmlValidation = false } = options || {};\n        return (tree, file) => {\n            unified().use(unifiedLatexToHtmlLike, options).run(tree);\n\n            // This should happen right before converting to HTML because macros like `\\&` should\n            // be expanded via html rules first (and not turned into their corresponding ligature directly)\n            expandUnicodeLigatures(tree);\n\n            // If there is a \\begin{document}...\\end{document}, that's the only\n            // content we want to convert.\n            let content = tree.content;\n            visit(\n                tree,\n                (env) => {\n                    content = env.content;\n                    return EXIT;\n                },\n                {\n                    test: ((node) =>\n                        match.environment(\n                            node,\n                            \"document\"\n                        )) as TypeGuard<Ast.Environment>,\n                }\n            );\n\n            const toHast = toHastWithLoggerFactory(file.message.bind(file));\n            let converted = toHast({ type: \"root\", content });\n            if (!Array.isArray(converted)) {\n                converted = [converted];\n            }\n            // Wrap everything in a Hast.Root node\n            let ret = h();\n            ret.children = converted;\n            if (!skipHtmlValidation) {\n                // We never want to produce invalid HTML, so we reparse the HTML we have generated.\n                // Ideally, any invalid HTML generation should be caught and fixed where it is, but\n                // we don't want to upset library users with invalid HTML\n                ret = unified().use(rehypeRaw).runSync(ret);\n            }\n            return ret;\n        };\n    };\n","import rehypeStringify from \"rehype-stringify\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { processLatexViaUnified } from \"@unified-latex/unified-latex\";\nimport {\n    unifiedLatexToHast,\n    PluginOptions,\n} from \"./unified-latex-plugin-to-hast\";\n\nconst _processor = processLatexViaUnified()\n    .use(unifiedLatexToHast)\n    .use(rehypeStringify);\n\n/**\n * Convert the `unified-latex` AST `tree` into an HTML string. If you need\n * more precise control or further processing, consider using `unified`\n * directly with the `unifiedLatexToHast` plugin.\n *\n * For example,\n * ```\n * unified()\n *      .use(unifiedLatexFromString)\n *      .use(unifiedLatexToHast)\n *      .use(rehypeStringify)\n *      .processSync(\"\\\\LaTeX to convert\")\n * ```\n */\nexport function convertToHtml(\n    tree: Ast.Node | Ast.Node[],\n    options?: PluginOptions\n): string {\n    let processor = _processor;\n    if (!Array.isArray(tree) && tree.type !== \"root\") {\n        tree = { type: \"root\", content: [tree] };\n    }\n    if (Array.isArray(tree)) {\n        tree = { type: \"root\", content: tree };\n    }\n\n    if (options) {\n        processor = _processor.use(unifiedLatexToHast, options);\n    }\n\n    const hast = processor.runSync(tree);\n    return processor.stringify(hast);\n}\n"],"names":["toHast","factory","unifiedLatexWrapPars","unifiedLatexToHtmlLike","macroReplacements","_macroReplacements","environmentReplacements","_environmentReplacements"],"mappings":"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"}