"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const hastUtilRaw = require("hast-util-raw");
const hastscript = require("hastscript");
const unifiedLatexUtilLigatures = require("@unified-latex/unified-latex-util-ligatures");
const unifiedLatexUtilMatch = require("@unified-latex/unified-latex-util-match");
const unifiedLatexUtilVisit = require("@unified-latex/unified-latex-util-visit");
const unifiedLatexUtilHtmlLike = require("@unified-latex/unified-latex-util-html-like");
const unifiedLatexUtilPrintRaw = require("@unified-latex/unified-latex-util-print-raw");
const unifiedLatexLintNoTexFontShapingCommands = require("@unified-latex/unified-latex-lint/rules/unified-latex-lint-no-tex-font-shaping-commands");
const unifiedLatexUtilComments = require("@unified-latex/unified-latex-util-comments");
const unifiedLatexUtilReplace = require("@unified-latex/unified-latex-util-replace");
const cssesc = require("cssesc");
const tabularx = require("@unified-latex/unified-latex-ctan/package/tabularx");
const unifiedLatexUtilAlign = require("@unified-latex/unified-latex-util-align");
const unifiedLatexUtilArguments = require("@unified-latex/unified-latex-util-arguments");
const unifiedLatexUtilTrim = require("@unified-latex/unified-latex-util-trim");
const systeme = require("@unified-latex/unified-latex-ctan/package/systeme");
const xcolor = require("@unified-latex/unified-latex-ctan/package/xcolor");
const unifiedLatexBuilder = require("@unified-latex/unified-latex-builder");
const unifiedLatex = require("@unified-latex/unified-latex");
const hastUtilToHtml = require("hast-util-to-html");
function rehypeRaw(options = {}) {
  return (tree, file) => {
    const result = (
      /** @type {Root} */
      hastUtilRaw.raw(tree, file, options)
    );
    return result;
  };
}
function bail(error) {
  if (error) {
    throw error;
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer = function isBuffer2(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
const isBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer);
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name) {
  if (name === "__proto__") {
    if (!hasOwn.call(obj, name)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name).value;
    }
  }
  return obj[name];
};
var extend = function extend2() {
  var options, name, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name in options) {
        src = getProperty(target, name);
        copy = getProperty(options, name);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name, newValue: extend2(deep, clone, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty(target, { name, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > ðŸ‘‰ **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code = path2.charCodeAt(index2);
    if (code === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code = path2.charCodeAt(index2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > ðŸ‘‰ **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
}
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return isBuffer$1(value);
}
const unified = base().freeze();
const own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data(extend$1(true, {}, namespace));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject2(entry[1]) && isPlainObject2(value2)) {
          value2 = extend$1(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node);
    if (newable(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node, file) {
    let result;
    let complete;
    processor.run(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) ;
          else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classesâ€™ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node) {
  if (!isPlainObject2(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || isBuffer$1(value);
}
function formatNodeForError(node) {
  try {
    return unifiedLatexUtilPrintRaw.printRaw(node);
  } catch {
  }
  return JSON.stringify(node);
}
function toHastWithLoggerFactory(logger) {
  return function toHast2(node) {
    const htmlNode = node;
    if (unifiedLatexUtilHtmlLike.isHtmlLikeTag(htmlNode)) {
      const extracted = unifiedLatexUtilHtmlLike.extractFromHtmlLike(htmlNode);
      const attributes = extracted.attributes;
      return hastscript.h(
        extracted.tag,
        attributes,
        extracted.content.flatMap(toHast2)
      );
    }
    switch (node.type) {
      case "string":
        return {
          type: "text",
          value: node.content,
          position: node.position
        };
      case "comment":
        return {
          type: "comment",
          value: node.content,
          position: node.position
        };
      case "inlinemath":
        return hastscript.h(
          "span",
          { className: "inline-math" },
          unifiedLatexUtilPrintRaw.printRaw(node.content)
        );
      case "mathenv":
      case "displaymath":
        return hastscript.h(
          "div",
          { className: "display-math" },
          unifiedLatexUtilPrintRaw.printRaw(node.content)
        );
      case "verb":
      case "verbatim":
        return hastscript.h("pre", { className: node.env }, node.content);
      case "whitespace":
        return { type: "text", value: " ", position: node.position };
      case "parbreak":
        return hastscript.h("br");
      case "group":
        return node.content.flatMap(toHast2);
      case "environment":
        logger(
          `Unknown environment when converting to HTML \`${formatNodeForError(
            node.env
          )}\``,
          node
        );
        return hastscript.h(
          "div",
          { className: ["environment", unifiedLatexUtilPrintRaw.printRaw(node.env)] },
          node.content.flatMap(toHast2)
        );
      case "macro":
        logger(
          `Unknown macro when converting to HTML \`${formatNodeForError(
            node
          )}\``,
          node
        );
        return hastscript.h(
          "span",
          { className: ["macro", `macro-${node.content}`] },
          (node.args || []).map(toHast2).flat()
        );
      case "argument":
        return hastscript.h(
          "span",
          {
            className: ["argument"],
            "data-open-mark": node.openMark,
            "data-close-mark": node.closeMark
          },
          unifiedLatexUtilPrintRaw.printRaw(node.content)
        );
      case "root":
        return node.content.flatMap(toHast2);
      default: {
        throw new Error(
          `Unknown node type; cannot convert to HAST ${JSON.stringify(
            node
          )}`
        );
      }
    }
  };
}
function splitForPars(nodes, options) {
  const ret = [];
  let currBody = [];
  unifiedLatexUtilTrim.trim(nodes);
  const isParBreakingMacro = unifiedLatexUtilMatch.match.createMacroMatcher(
    options.macrosThatBreakPars
  );
  const isEnvThatShouldNotBreakPar = unifiedLatexUtilMatch.match.createEnvironmentMatcher(
    options.environmentsThatDontBreakPars
  );
  function pushBody() {
    if (currBody.length > 0) {
      unifiedLatexUtilTrim.trim(currBody);
      ret.push({ content: currBody, wrapInPar: true });
      currBody = [];
    }
  }
  for (const node of nodes) {
    if (isParBreakingMacro(node)) {
      pushBody();
      ret.push({ content: [node], wrapInPar: false });
      continue;
    }
    if (unifiedLatexUtilMatch.match.anyEnvironment(node) && !isEnvThatShouldNotBreakPar(node)) {
      pushBody();
      ret.push({ content: [node], wrapInPar: false });
      continue;
    }
    if (node.type === "displaymath") {
      pushBody();
      ret.push({ content: [node], wrapInPar: false });
      continue;
    }
    if (unifiedLatexUtilMatch.match.parbreak(node) || unifiedLatexUtilMatch.match.macro(node, "par")) {
      pushBody();
      continue;
    }
    currBody.push(node);
  }
  pushBody();
  return ret;
}
function wrapPars(nodes, options) {
  const {
    macrosThatBreakPars = [
      "part",
      "chapter",
      "section",
      "subsection",
      "subsubsection",
      "paragraph",
      "subparagraph",
      "vspace",
      "smallskip",
      "medskip",
      "bigskip",
      "hfill"
    ],
    environmentsThatDontBreakPars = []
  } = options || {};
  const parSplits = splitForPars(nodes, {
    macrosThatBreakPars,
    environmentsThatDontBreakPars
  });
  return parSplits.flatMap((part) => {
    if (part.wrapInPar) {
      return unifiedLatexUtilHtmlLike.htmlLike({ tag: "p", content: part.content });
    } else {
      return part.content;
    }
  });
}
const ITEM_ARG_NAMES_REG = ["label"];
const ITEM_ARG_NAMES_BEAMER = [null, "label", null];
function getItemArgs(node) {
  if (!Array.isArray(node.args)) {
    throw new Error(
      `Cannot find \\item macros arguments; you must attach the \\item body to the macro before calling this function ${JSON.stringify(
        node
      )}`
    );
  }
  const argNames = node.args.length - 1 === ITEM_ARG_NAMES_BEAMER.length ? ITEM_ARG_NAMES_BEAMER : ITEM_ARG_NAMES_REG;
  const ret = Object.assign(
    { body: node.args[node.args.length - 1].content },
    unifiedLatexUtilArguments.getNamedArgsContent(node, argNames)
  );
  return ret;
}
function enumerateFactory(parentTag = "ol", className = "enumerate") {
  return function enumerateToHtml(env) {
    const items = env.content.filter((node) => unifiedLatexUtilMatch.match.macro(node, "item"));
    const content = items.flatMap((node) => {
      if (!unifiedLatexUtilMatch.match.macro(node) || !node.args) {
        return [];
      }
      const attributes = {};
      const namedArgs = getItemArgs(node);
      if (namedArgs.label != null) {
        const formattedLabel = cssesc(unifiedLatexUtilPrintRaw.printRaw(namedArgs.label || []));
        attributes.style = {
          // Note the space after `formattedLabel`. That is on purpose!
          "list-style-type": formattedLabel ? `'${formattedLabel} '` : "none"
        };
      }
      const body = namedArgs.body;
      return unifiedLatexUtilHtmlLike.htmlLike({
        tag: "li",
        content: wrapPars(body),
        attributes
      });
    });
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: parentTag,
      attributes: { className },
      content
    });
  };
}
function createCenteredElement(env) {
  return unifiedLatexUtilHtmlLike.htmlLike({
    tag: "center",
    attributes: { className: "center" },
    content: env.content
  });
}
function createTableFromTabular(env) {
  const tabularBody = unifiedLatexUtilAlign.parseAlignEnvironment(env.content);
  const args = unifiedLatexUtilArguments.getArgsContent(env);
  let columnSpecs = [];
  try {
    columnSpecs = tabularx.parseTabularSpec(args[1] || []);
  } catch (e) {
  }
  const tableBody = tabularBody.map((row) => {
    const content = row.cells.map((cell, i) => {
      const columnSpec = columnSpecs[i];
      const styles = {};
      if (columnSpec) {
        const { alignment } = columnSpec;
        if (alignment.alignment === "center") {
          styles["text-align"] = "center";
        }
        if (alignment.alignment === "right") {
          styles["text-align"] = "right";
        }
        if (columnSpec.pre_dividers.some(
          (div) => div.type === "vert_divider"
        )) {
          styles["border-left"] = "1px solid";
        }
        if (columnSpec.post_dividers.some(
          (div) => div.type === "vert_divider"
        )) {
          styles["border-right"] = "1px solid";
        }
      }
      return unifiedLatexUtilHtmlLike.htmlLike(
        Object.keys(styles).length > 0 ? {
          tag: "td",
          content: cell,
          attributes: { style: styles }
        } : {
          tag: "td",
          content: cell
        }
      );
    });
    return unifiedLatexUtilHtmlLike.htmlLike({ tag: "tr", content });
  });
  return unifiedLatexUtilHtmlLike.htmlLike({
    tag: "table",
    content: [
      unifiedLatexUtilHtmlLike.htmlLike({
        tag: "tbody",
        content: tableBody
      })
    ],
    attributes: { className: "tabular" }
  });
}
const environmentReplacements = {
  enumerate: enumerateFactory("ol"),
  itemize: enumerateFactory("ul", "itemize"),
  center: createCenteredElement,
  tabular: createTableFromTabular,
  quote: (env) => {
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "blockquote",
      content: env.content,
      attributes: { className: "environment quote" }
    });
  }
};
const KATEX_MACROS = [
  " ",
  "!",
  '"',
  "#",
  "&",
  "'",
  "*",
  ",",
  ".",
  ":",
  ";",
  "=",
  ">",
  "AA",
  "AE",
  "Alpha",
  "And",
  "Arrowvert",
  "Bbb",
  "Bbbk",
  "Beta",
  "Big",
  "Bigg",
  "Biggl",
  "Biggm",
  "Biggr",
  "Bigl",
  "Bigm",
  "Bigr",
  "Box",
  "Bra",
  "Bumpeq",
  "C",
  "Cap",
  "Chi",
  "Colonapprox",
  "Coloneq",
  "Coloneqq",
  "Colonsim",
  "Complex",
  "Coppa",
  "Cup",
  "Dagger",
  "Darr",
  "DeclareMathOperator",
  "Delta",
  "Diamond",
  "Digamma",
  "Doteq",
  "Downarrow",
  "Epsilon",
  "Eqcolon",
  "Eqqcolon",
  "Eta",
  "Finv",
  "Game",
  "Gamma",
  "H",
  "Harr",
  "Huge",
  "Im",
  "Iota",
  "Join",
  "KaTeX",
  "Kappa",
  "Ket",
  "Koppa",
  "L",
  "LARGE",
  "LaTeX",
  "Lambda",
  "Large",
  "Larr",
  "LeftArrow",
  "Leftarrow",
  "Leftrightarrow",
  "Lleftarrow",
  "Longleftarrow",
  "Longleftrightarrow",
  "Longrightarrow",
  "Lrarr",
  "Lsh",
  "Mu",
  "N",
  "Newextarrow",
  "Nu",
  "O",
  "OE",
  "Omega",
  "Omicron",
  "Overrightarrow",
  "P",
  "Phi",
  "Pi",
  "Pr",
  "Psi",
  "Q",
  "R",
  "Rarr",
  "Re",
  "Reals",
  "Rho",
  "Rightarrow",
  "Rrightarrow",
  "Rsh",
  "Rule",
  "S",
  "Sampi",
  "Sigma",
  "Space",
  "Stigma",
  "Subset",
  "Supset",
  "Tau",
  "TeX",
  "Theta",
  "Tiny",
  "Uarr",
  "Uparrow",
  "Updownarrow",
  "Upsilon",
  "Vdash",
  "Vert",
  "Vvdash",
  "Xi",
  "Z",
  "Zeta",
  "\\",
  "^",
  "_",
  "`",
  "aa",
  "above",
  "abovewithdelims",
  "acute",
  "add",
  "ae",
  "alef",
  "alefsym",
  "aleph",
  "allowbreak",
  "alpha",
  "amalg",
  "and",
  "ang",
  "angl",
  "angle",
  "angln",
  "approx",
  "approxcolon",
  "approxcoloncolon",
  "approxeq",
  "arccos",
  "arcctg",
  "arcsin",
  "arctan",
  "arctg",
  "arg",
  "argmax",
  "argmin",
  "array",
  "arraystretch",
  "arrowvert",
  "ast",
  "asymp",
  "atop",
  "atopwithdelims",
  "backepsilon",
  "backprime",
  "backsim",
  "backsimeq",
  "backslash",
  "bar",
  "barwedge",
  "bbox",
  "bcancel",
  "because",
  "begin",
  "begingroup",
  "beta",
  "beth",
  "between",
  "bf",
  "bfseries",
  "big",
  "bigcap",
  "bigcirc",
  "bigcup",
  "bigg",
  "biggl",
  "biggm",
  "biggr",
  "bigl",
  "bigm",
  "bigodot",
  "bigominus",
  "bigoplus",
  "bigoslash",
  "bigotimes",
  "bigr",
  "bigsqcap",
  "bigsqcup",
  "bigstar",
  "bigtriangledown",
  "bigtriangleup",
  "biguplus",
  "bigvee",
  "bigwedge",
  "binom",
  "blacklozenge",
  "blacksquare",
  "blacktriangle",
  "blacktriangledown",
  "blacktriangleleft",
  "blacktriangleright",
  "bm",
  "bmod",
  "bold",
  "boldsymbol",
  "bot",
  "bowtie",
  "boxdot",
  "boxed",
  "boxminus",
  "boxplus",
  "boxtimes",
  "bra",
  "brace",
  "bracevert",
  "brack",
  "braket",
  "breve",
  "buildrel",
  "bull",
  "bullet",
  "bumpeq",
  "cal",
  "cancel",
  "cancelto",
  "cap",
  "cases",
  "cdot",
  "cdotp",
  "cdots",
  "ce",
  "cee",
  "centerdot",
  "cf",
  "cfrac",
  "ch",
  "char",
  "check",
  "checkmark",
  "chi",
  "chk",
  "choose",
  "circ",
  "circeq",
  "circlearrowleft",
  "circlearrowright",
  "circledR",
  "circledS",
  "circledast",
  "circledcirc",
  "circleddash",
  "class",
  "cline",
  "clubs",
  "clubsuit",
  "cnums",
  "colon",
  "colonapprox",
  "coloncolon",
  "coloncolonapprox",
  "coloncolonequals",
  "coloncolonminus",
  "coloncolonsim",
  "coloneq",
  "coloneqq",
  "colonequals",
  "colonminus",
  "colonsim",
  "color",
  "colorbox",
  "complement",
  "cong",
  "coppa",
  "coprod",
  "copyright",
  "cos",
  "cosec",
  "cosh",
  "cot",
  "cotg",
  "coth",
  "cr",
  "csc",
  "cssId",
  "ctg",
  "cth",
  "cup",
  "curlyeqprec",
  "curlyeqsucc",
  "curlyvee",
  "curlywedge",
  "curvearrowleft",
  "curvearrowright",
  "dArr",
  "dag",
  "dagger",
  "daleth",
  "darr",
  "dashleftarrow",
  "dashrightarrow",
  "dashv",
  "dbinom",
  "dblcolon",
  "ddag",
  "ddagger",
  "ddddot",
  "dddot",
  "ddot",
  "ddots",
  "def",
  "definecolor",
  "deg",
  "degree",
  "delta",
  "det",
  "dfrac",
  "diagdown",
  "diagup",
  "diamond",
  "diamonds",
  "diamondsuit",
  "digamma",
  "dim",
  "displaylines",
  "displaystyle",
  "div",
  "divideontimes",
  "dot",
  "doteq",
  "doteqdot",
  "dotplus",
  "dots",
  "dotsb",
  "dotsc",
  "dotsi",
  "dotsm",
  "dotso",
  "doublebarwedge",
  "doublecap",
  "doublecup",
  "downarrow",
  "downdownarrows",
  "downharpoonleft",
  "downharpoonright",
  "edef",
  "ell",
  "else",
  "em",
  "emph",
  "empty",
  "emptyset",
  "enclose",
  "end",
  "endgroup",
  "enspace",
  "epsilon",
  "eqalign",
  "eqalignno",
  "eqcirc",
  "eqcolon",
  "eqqcolon",
  "eqref",
  "eqsim",
  "eqslantgtr",
  "eqslantless",
  "equalscolon",
  "equalscoloncolon",
  "equiv",
  "eta",
  "eth",
  "euro",
  "exist",
  "exists",
  "exp",
  "expandafter",
  "fallingdotseq",
  "fbox",
  "fcolorbox",
  "fi",
  "flat",
  "foo",
  "footnotesize",
  "forall",
  "frac",
  "frak",
  "frown",
  "futurelet",
  "gamma",
  "gcd",
  "gdef",
  "ge",
  "geneuro",
  "geneuronarrow",
  "geneurowide",
  "genfrac",
  "geq",
  "geqq",
  "geqslant",
  "gets",
  "gg",
  "ggg",
  "gggtr",
  "gimel",
  "global",
  "gnapprox",
  "gneq",
  "gneqq",
  "gnsim",
  "grave",
  "greet",
  "gt",
  "gtrapprox",
  "gtrdot",
  "gtreqless",
  "gtreqqless",
  "gtrless",
  "gtrsim",
  "gvertneqq",
  "hArr",
  "hail",
  "harr",
  "hat",
  "hbar",
  "hbox",
  "hdashline",
  "hearts",
  "heartsuit",
  "hfil",
  "hfill",
  "hline",
  "hom",
  "hookleftarrow",
  "hookrightarrow",
  "hphantom",
  "href",
  "hskip",
  "hslash",
  "hspace",
  "htmlClass",
  "htmlData",
  "htmlId",
  "htmlStyle",
  "huge",
  "i",
  "iddots",
  "idotsint",
  "if",
  "iff",
  "ifmode",
  "ifx",
  "iiiint",
  "iiint",
  "iint",
  "image",
  "imageof",
  "imath",
  "impliedby",
  "implies",
  "in",
  "includegraphics",
  "inf",
  "infin",
  "infty",
  "injlim",
  "int",
  "intercal",
  "intop",
  "iota",
  "isin",
  "it",
  "itshape",
  "j",
  "jmath",
  "kappa",
  "ker",
  "kern",
  "ket",
  "koppa",
  "l",
  "lArr",
  "lBrace",
  "lVert",
  "label",
  "lambda",
  "land",
  "lang",
  "langle",
  "large",
  "larr",
  "lbrace",
  "lbrack",
  "lceil",
  "ldotp",
  "ldots",
  "le",
  "leadsto",
  "left",
  "leftarrow",
  "leftarrowtail",
  "leftharpoondown",
  "leftharpoonup",
  "leftleftarrows",
  "leftrightarrow",
  "leftrightarrows",
  "leftrightharpoons",
  "leftrightsquigarrow",
  "leftroot",
  "leftthreetimes",
  "leq",
  "leqalignno",
  "leqq",
  "leqslant",
  "lessapprox",
  "lessdot",
  "lesseqgtr",
  "lesseqqgtr",
  "lessgtr",
  "lesssim",
  "let",
  "lfloor",
  "lg",
  "lgroup",
  "lhd",
  "lim",
  "liminf",
  "limits",
  "limsup",
  "ll",
  "llap",
  "llbracket",
  "llcorner",
  "lll",
  "llless",
  "lmoustache",
  "ln",
  "lnapprox",
  "lneq",
  "lneqq",
  "lnot",
  "lnsim",
  "log",
  "long",
  "longleftarrow",
  "longleftrightarrow",
  "longmapsto",
  "longrightarrow",
  "looparrowleft",
  "looparrowright",
  "lor",
  "lower",
  "lozenge",
  "lparen",
  "lq",
  "lrArr",
  "lrarr",
  "lrcorner",
  "lt",
  "ltimes",
  "lvert",
  "lvertneqq",
  "maltese",
  "mapsto",
  "mathbb",
  "mathbf",
  "mathbin",
  "mathcal",
  "mathchoice",
  "mathclap",
  "mathclose",
  "mathellipsis",
  "mathfrak",
  "mathinner",
  "mathit",
  "mathllap",
  "mathnormal",
  "mathop",
  "mathopen",
  "mathord",
  "mathpunct",
  "mathrel",
  "mathring",
  "mathrlap",
  "mathrm",
  "mathscr",
  "mathsf",
  "mathsterling",
  "mathstrut",
  "mathtip",
  "mathtt",
  "matrix",
  "max",
  "mbox",
  "md",
  "mdseries",
  "measuredangle",
  "medspace",
  "mho",
  "mid",
  "middle",
  "min",
  "minuscolon",
  "minuscoloncolon",
  "minuso",
  "mit",
  "mkern",
  "mmlToken",
  "mod",
  "models",
  "moveleft",
  "moveright",
  "mp",
  "mskip",
  "mspace",
  "mu",
  "multicolumn",
  "multimap",
  "nLeftarrow",
  "nLeftrightarrow",
  "nRightarrow",
  "nVDash",
  "nVdash",
  "nabla",
  "natnums",
  "natural",
  "ncong",
  "ne",
  "nearrow",
  "neg",
  "negmedspace",
  "negthickspace",
  "negthinspace",
  "neq",
  "newcommand",
  "newenvironment",
  "newline",
  "nexists",
  "ngeq",
  "ngeqq",
  "ngeqslant",
  "ngtr",
  "ni",
  "nleftarrow",
  "nleftrightarrow",
  "nleq",
  "nleqq",
  "nleqslant",
  "nless",
  "nmid",
  "nobreak",
  "nobreakspace",
  "noexpand",
  "nolimits",
  "nonumber",
  "normalfont",
  "normalsize",
  "not",
  "notag",
  "notin",
  "notni",
  "nparallel",
  "nprec",
  "npreceq",
  "nrightarrow",
  "nshortmid",
  "nshortparallel",
  "nsim",
  "nsubseteq",
  "nsubseteqq",
  "nsucc",
  "nsucceq",
  "nsupseteq",
  "nsupseteqq",
  "ntriangleleft",
  "ntrianglelefteq",
  "ntriangleright",
  "ntrianglerighteq",
  "nu",
  "nvDash",
  "nvdash",
  "nwarrow",
  "o",
  "odot",
  "oe",
  "officialeuro",
  "oiiint",
  "oiint",
  "oint",
  "oldstyle",
  "omega",
  "omicron",
  "ominus",
  "operatorname",
  "operatornamewithlimits",
  "oplus",
  "or",
  "origof",
  "oslash",
  "otimes",
  "over",
  "overbrace",
  "overbracket",
  "overgroup",
  "overleftarrow",
  "overleftharpoon",
  "overleftrightarrow",
  "overline",
  "overlinesegment",
  "overparen",
  "overrightarrow",
  "overrightharpoon",
  "overset",
  "overwithdelims",
  "owns",
  "pagecolor",
  "parallel",
  "part",
  "partial",
  "perp",
  "phantom",
  "phase",
  "phi",
  "pi",
  "pitchfork",
  "plim",
  "plusmn",
  "pm",
  "pmatrix",
  "pmb",
  "pmod",
  "pod",
  "pounds",
  "prec",
  "precapprox",
  "preccurlyeq",
  "preceq",
  "precnapprox",
  "precneqq",
  "precnsim",
  "precsim",
  "prime",
  "prod",
  "projlim",
  "propto",
  "providecommand",
  "psi",
  "pu",
  "qquad",
  "quad",
  "r",
  "rArr",
  "rBrace",
  "rVert",
  "raise",
  "raisebox",
  "rang",
  "rangle",
  "rarr",
  "ratio",
  "rbrace",
  "rbrack",
  "rceil",
  "real",
  "reals",
  "ref",
  "relax",
  "renewcommand",
  "renewenvironment",
  "require",
  "restriction",
  "rfloor",
  "rgroup",
  "rhd",
  "rho",
  "right",
  "rightarrow",
  "rightarrowtail",
  "rightharpoondown",
  "rightharpoonup",
  "rightleftarrows",
  "rightleftharpoons",
  "rightrightarrows",
  "rightsquigarrow",
  "rightthreetimes",
  "risingdotseq",
  "rlap",
  "rm",
  "rmoustache",
  "root",
  "rotatebox",
  "rparen",
  "rq",
  "rrbracket",
  "rtimes",
  "rule",
  "rvert",
  "sampi",
  "sc",
  "scalebox",
  "scr",
  "scriptscriptstyle",
  "scriptsize",
  "scriptstyle",
  "sdot",
  "searrow",
  "sec",
  "sect",
  "setlength",
  "setminus",
  "sf",
  "sh",
  "sharp",
  "shortmid",
  "shortparallel",
  "shoveleft",
  "shoveright",
  "sideset",
  "sigma",
  "sim",
  "simcolon",
  "simcoloncolon",
  "simeq",
  "sin",
  "sinh",
  "sixptsize",
  "skew",
  "skip",
  "sl",
  "small",
  "smallfrown",
  "smallint",
  "smallsetminus",
  "smallsmile",
  "smash",
  "smile",
  "smiley",
  "sout",
  "space",
  "spades",
  "spadesuit",
  "sphericalangle",
  "sqcap",
  "sqcup",
  "sqrt",
  "sqsubset",
  "sqsubseteq",
  "sqsupset",
  "sqsupseteq",
  "square",
  "ss",
  "stackrel",
  "star",
  "stigma",
  "strut",
  "style",
  "sub",
  "sube",
  "subset",
  "subseteq",
  "subseteqq",
  "subsetneq",
  "subsetneqq",
  "substack",
  "succ",
  "succapprox",
  "succcurlyeq",
  "succeq",
  "succnapprox",
  "succneqq",
  "succnsim",
  "succsim",
  "sum",
  "sup",
  "supe",
  "supset",
  "supseteq",
  "supseteqq",
  "supsetneq",
  "supsetneqq",
  "surd",
  "swarrow",
  "tag",
  "tan",
  "tanh",
  "tau",
  "tbinom",
  "text",
  "textasciicircum",
  "textasciitilde",
  "textbackslash",
  "textbar",
  "textbardbl",
  "textbf",
  "textbraceleft",
  "textbraceright",
  "textcircled",
  "textcolor",
  "textdagger",
  "textdaggerdbl",
  "textdegree",
  "textdollar",
  "textellipsis",
  "textemdash",
  "textendash",
  "textgreater",
  "textit",
  "textless",
  "textmd",
  "textnormal",
  "textquotedblleft",
  "textquotedblright",
  "textquoteleft",
  "textquoteright",
  "textregistered",
  "textrm",
  "textsc",
  "textsf",
  "textsl",
  "textsterling",
  "textstyle",
  "texttip",
  "texttt",
  "textunderscore",
  "textup",
  "textvisiblespace",
  "tfrac",
  "tg",
  "th",
  "therefore",
  "theta",
  "thetasym",
  "thickapprox",
  "thicksim",
  "thickspace",
  "thinspace",
  "tilde",
  "times",
  "tiny",
  "to",
  "toggle",
  "top",
  "triangle",
  "triangledown",
  "triangleleft",
  "trianglelefteq",
  "triangleq",
  "triangleright",
  "trianglerighteq",
  "tt",
  "twoheadleftarrow",
  "twoheadrightarrow",
  "u",
  "uArr",
  "uarr",
  "ulcorner",
  "underbar",
  "underbrace",
  "underbracket",
  "undergroup",
  "underleftarrow",
  "underleftrightarrow",
  "underline",
  "underlinesegment",
  "underparen",
  "underrightarrow",
  "underset",
  "unicode",
  "unlhd",
  "unrhd",
  "up",
  "uparrow",
  "updownarrow",
  "upharpoonleft",
  "upharpoonright",
  "uplus",
  "uproot",
  "upshape",
  "upsilon",
  "upuparrows",
  "urcorner",
  "url",
  "utilde",
  "v",
  "vDash",
  "varDelta",
  "varGamma",
  "varLambda",
  "varOmega",
  "varPhi",
  "varPi",
  "varPsi",
  "varSigma",
  "varTheta",
  "varUpsilon",
  "varXi",
  "varcoppa",
  "varepsilon",
  "varinjlim",
  "varkappa",
  "varliminf",
  "varlimsup",
  "varnothing",
  "varphi",
  "varpi",
  "varprojlim",
  "varpropto",
  "varrho",
  "varsigma",
  "varstigma",
  "varsubsetneq",
  "varsubsetneqq",
  "varsupsetneq",
  "varsupsetneqq",
  "vartheta",
  "vartriangle",
  "vartriangleleft",
  "vartriangleright",
  "vcentcolon",
  "vcenter",
  "vdash",
  "vdots",
  "vec",
  "vee",
  "veebar",
  "vert",
  "vfil",
  "vfill",
  "vline",
  "vphantom",
  "wedge",
  "weierp",
  "widecheck",
  "widehat",
  "wideparen",
  "widetilde",
  "wp",
  "wr",
  "xLeftarrow",
  "xLeftrightarrow",
  "xRightarrow",
  "xcancel",
  "xdef",
  "xhookleftarrow",
  "xhookrightarrow",
  "xi",
  "xleftarrow",
  "xleftharpoondown",
  "xleftharpoonup",
  "xleftrightarrow",
  "xleftrightharpoons",
  "xlongequal",
  "xmapsto",
  "xrightarrow",
  "xrightharpoondown",
  "xrightharpoonup",
  "xrightleftharpoons",
  "xtofrom",
  "xtwoheadleftarrow",
  "xtwoheadrightarrow",
  "yen",
  "zeta",
  "{",
  "|",
  "}",
  "~"
];
const KATEX_ENVIRONMENTS = [
  "align",
  "align*",
  "alignat",
  "alignat*",
  "aligned",
  "alignedat",
  "array",
  "Bmatrix",
  "bmatrix",
  "Bmatrix*",
  "bmatrix*",
  "cases",
  "CD",
  "darray",
  "dcases",
  "drcases",
  "equation",
  "equation*",
  "gather",
  "gathered",
  "matrix",
  "matrix*",
  "pmatrix",
  "pmatrix*",
  "rcases",
  "smallmatrix",
  "split",
  "Vmatrix",
  "vmatrix",
  "Vmatrix*",
  "vmatrix*"
];
const KATEX_SUPPORT_LIST = {
  KATEX_MACROS,
  KATEX_ENVIRONMENTS
};
const LEFT = { type: "macro", content: "left" };
const RIGHT = { type: "macro", content: "right" };
const DEFAULT_LEFT_DELIM = { type: "macro", content: "{" };
const DEFAULT_RIGHT_DELIM = { type: "string", content: "." };
const katexSpecificMacroReplacements = {
  systeme: (node) => {
    var _a, _b;
    try {
      const args = unifiedLatexUtilArguments.getArgsContent(node);
      const whitelistedVariables = args[1] || void 0;
      const equations = args[3] || [];
      const ret = systeme.systemeContentsToArray(equations, {
        properSpacing: false,
        whitelistedVariables
      });
      if ((_a = node == null ? void 0 : node._renderInfo) == null ? void 0 : _a.sysdelims) {
        const [frontDelim, backDelim] = (_b = node._renderInfo) == null ? void 0 : _b.sysdelims;
        return [
          LEFT,
          ...frontDelim || [],
          ret,
          RIGHT,
          ...backDelim || []
        ];
      }
      return [LEFT, DEFAULT_LEFT_DELIM, ret, RIGHT, DEFAULT_RIGHT_DELIM];
    } catch (e) {
      return node;
    }
  },
  sysdelim: () => []
};
function wrapInDisplayMath(ast) {
  const content = Array.isArray(ast) ? ast : [ast];
  return { type: "displaymath", content };
}
const katexSpecificEnvironmentReplacements = {
  // katex supports the align environments, but it will only render them
  // if you are already in math mode. Warning: these will produce invalid latex!
  align: wrapInDisplayMath,
  "align*": wrapInDisplayMath,
  alignat: wrapInDisplayMath,
  "alignat*": wrapInDisplayMath,
  equation: wrapInDisplayMath,
  "equation*": wrapInDisplayMath
};
function attachNeededRenderInfo(ast) {
  systeme.attachSystemeSettingsAsRenderInfo(ast);
}
const KATEX_SUPPORT = {
  macros: KATEX_SUPPORT_LIST["KATEX_MACROS"],
  environments: KATEX_SUPPORT_LIST["KATEX_ENVIRONMENTS"]
};
function factory$1(tag, attributes) {
  return (macro) => {
    if (!macro.args) {
      throw new Error(
        `Found macro to replace but couldn't find content ${unifiedLatexUtilPrintRaw.printRaw(
          macro
        )}`
      );
    }
    const args = unifiedLatexUtilArguments.getArgsContent(macro);
    const content = args[args.length - 1] || [];
    return unifiedLatexUtilHtmlLike.htmlLike({ tag, content, attributes });
  };
}
function createHeading(tag, attrs = {}) {
  return (macro) => {
    const args = unifiedLatexUtilArguments.getArgsContent(macro);
    const starred = !!args[0];
    const attributes = starred ? { className: "starred" } : {};
    if (attrs) {
      Object.assign(attributes, attrs);
    }
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag,
      content: args[args.length - 1] || [],
      attributes
    });
  };
}
const macroReplacements = {
  emph: factory$1("em", { className: "emph" }),
  textrm: factory$1("span", { className: "textrm" }),
  textsf: factory$1("span", { className: "textsf" }),
  texttt: factory$1("span", { className: "texttt" }),
  textsl: factory$1("span", { className: "textsl" }),
  textit: factory$1("i", { className: "textit" }),
  textbf: factory$1("b", { className: "textbf" }),
  underline: factory$1("u", { className: "underline" }),
  mbox: factory$1("span", { className: "mbox" }),
  phantom: factory$1("span", { className: "phantom" }),
  part: createHeading("h1"),
  chapter: createHeading("h2"),
  section: createHeading("h3"),
  subsection: createHeading("h4"),
  subsubsection: createHeading("h5"),
  paragraph: createHeading("h6", { className: "section-paragraph" }),
  subparagraph: createHeading("h6", {
    className: "section-subparagraph"
  }),
  appendix: createHeading("h2"),
  smallskip: () => unifiedLatexUtilHtmlLike.htmlLike({
    tag: "br",
    attributes: { className: "smallskip" }
  }),
  medskip: () => unifiedLatexUtilHtmlLike.htmlLike({
    tag: "br",
    attributes: { className: "medskip" }
  }),
  bigskip: () => unifiedLatexUtilHtmlLike.htmlLike({
    tag: "br",
    attributes: { className: "bigskip" }
  }),
  "\n": () => unifiedLatexUtilHtmlLike.htmlLike({
    tag: "br",
    attributes: { className: "literal-newline" }
  }),
  url: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const url = unifiedLatexUtilPrintRaw.printRaw(args[0] || "#");
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "a",
      attributes: {
        className: "url",
        href: url
      },
      content: [{ type: "string", content: url }]
    });
  },
  href: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const url = unifiedLatexUtilPrintRaw.printRaw(args[1] || "#");
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "a",
      attributes: {
        className: "href",
        href: url
      },
      content: args[2] || []
    });
  },
  hyperref: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const url = "#" + unifiedLatexUtilPrintRaw.printRaw(args[0] || "");
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "a",
      attributes: {
        className: "href",
        href: url
      },
      content: args[1] || []
    });
  },
  "\\": () => unifiedLatexUtilHtmlLike.htmlLike({
    tag: "br",
    attributes: { className: "linebreak" }
  }),
  vspace: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "div",
      attributes: {
        className: "vspace",
        "data-amount": unifiedLatexUtilPrintRaw.printRaw(args[1] || [])
      },
      content: []
    });
  },
  hspace: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "span",
      attributes: {
        className: "vspace",
        "data-amount": unifiedLatexUtilPrintRaw.printRaw(args[1] || [])
      },
      content: []
    });
  },
  textcolor: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const computedColor = xcolor.xcolorMacroToHex(node);
    const color = computedColor.hex;
    if (color) {
      return unifiedLatexUtilHtmlLike.htmlLike({
        tag: "span",
        attributes: { style: `color: ${color};` },
        content: args[2] || []
      });
    } else {
      return unifiedLatexUtilHtmlLike.htmlLike({
        tag: "span",
        attributes: {
          style: `color: var(${computedColor.cssVarName});`
        },
        content: args[2] || []
      });
    }
  },
  textsize: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const textSize = unifiedLatexUtilPrintRaw.printRaw(args[0] || []);
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "span",
      attributes: {
        className: `textsize-${textSize}`
      },
      content: args[1] || []
    });
  },
  makebox: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "span",
      attributes: {
        className: `latex-box`,
        style: "display: inline-block;"
      },
      content: args[3] || []
    });
  },
  noindent: () => ({ type: "string", content: "" }),
  includegraphics: (node) => {
    const args = unifiedLatexUtilArguments.getArgsContent(node);
    const src = unifiedLatexUtilPrintRaw.printRaw(args[args.length - 1] || []);
    return unifiedLatexUtilHtmlLike.htmlLike({
      tag: "img",
      attributes: {
        className: "includegraphics",
        src
      },
      content: []
    });
  }
};
function factory(macroName, ...boundArgs) {
  return (content, originalCommand) => {
    return unifiedLatexBuilder.m(macroName, boundArgs.map((a) => unifiedLatexBuilder.arg(a)).concat(unifiedLatexBuilder.arg(content)));
  };
}
const streamingMacroReplacements = {
  color: xcolor.colorToTextcolorMacro,
  bfseries: factory("textbf"),
  itshape: factory("textit"),
  rmfamily: factory("textrm"),
  scshape: factory("textsc"),
  sffamily: factory("textsf"),
  slshape: factory("textsl"),
  ttfamily: factory("texttt"),
  Huge: factory("textsize", "Huge"),
  huge: factory("textsize", "huge"),
  LARGE: factory("textsize", "LARGE"),
  Large: factory("textsize", "Large"),
  large: factory("textsize", "large"),
  normalsize: factory("textsize", "normalsize"),
  small: factory("textsize", "small"),
  footnotesize: factory("textsize", "footnotesize"),
  scriptsize: factory("textsize", "scriptsize"),
  tiny: factory("textsize", "tiny")
};
const unifiedLatexWrapPars = function unifiedLatexWrapPars2(options) {
  const { macrosThatBreakPars, environmentsThatDontBreakPars } = options || {};
  return (tree) => {
    let hasDocumentEnv = false;
    unifiedLatexUtilVisit.visit(
      tree,
      (env) => {
        if (unifiedLatexUtilMatch.match.environment(env, "document")) {
          hasDocumentEnv = true;
          env.content = wrapPars(env.content, {
            macrosThatBreakPars,
            environmentsThatDontBreakPars
          });
          return unifiedLatexUtilVisit.EXIT;
        }
      },
      { test: unifiedLatexUtilMatch.match.anyEnvironment }
    );
    if (!hasDocumentEnv) {
      tree.content = wrapPars(tree.content, {
        macrosThatBreakPars,
        environmentsThatDontBreakPars
      });
    }
  };
};
const unifiedLatexToHtmlLike = function unifiedLatexToHtmlLike2(options) {
  const macroReplacements$1 = Object.assign(
    {},
    macroReplacements,
    (options == null ? void 0 : options.macroReplacements) || {}
  );
  const environmentReplacements$1 = Object.assign(
    {},
    environmentReplacements,
    (options == null ? void 0 : options.environmentReplacements) || {}
  );
  const isReplaceableMacro = unifiedLatexUtilMatch.match.createMacroMatcher(macroReplacements$1);
  const isReplaceableEnvironment = unifiedLatexUtilMatch.match.createEnvironmentMatcher(
    environmentReplacements$1
  );
  const isKatexMacro = unifiedLatexUtilMatch.match.createMacroMatcher(
    katexSpecificMacroReplacements
  );
  const isKatexEnvironment = unifiedLatexUtilMatch.match.createEnvironmentMatcher(
    katexSpecificEnvironmentReplacements
  );
  return (tree) => {
    const originalTree = tree;
    unifiedLatexUtilComments.deleteComments(tree);
    let processor = unified().use(unifiedLatexLintNoTexFontShapingCommands.unifiedLatexLintNoTexFontShapingCommands, { fix: true }).use(unifiedLatexUtilReplace.unifiedLatexReplaceStreamingCommands, {
      replacers: streamingMacroReplacements
    });
    if (shouldBeWrappedInPars(tree)) {
      processor = processor.use(unifiedLatexWrapPars);
    }
    tree = processor.runSync(tree);
    unifiedLatexUtilReplace.replaceNode(tree, (node, info) => {
      if (info.context.hasMathModeAncestor) {
        return;
      }
      if (isReplaceableEnvironment(node)) {
        return environmentReplacements$1[unifiedLatexUtilPrintRaw.printRaw(node.env)](node, info);
      }
    });
    unifiedLatexUtilReplace.replaceNode(tree, (node, info) => {
      if (info.context.hasMathModeAncestor) {
        return;
      }
      if (isReplaceableMacro(node)) {
        const replacement = macroReplacements$1[node.content](node, info);
        return replacement;
      }
    });
    attachNeededRenderInfo(tree);
    unifiedLatexUtilReplace.replaceNode(tree, (node) => {
      if (isKatexMacro(node)) {
        return katexSpecificMacroReplacements[node.content](node);
      }
      if (isKatexEnvironment(node)) {
        return katexSpecificEnvironmentReplacements[unifiedLatexUtilPrintRaw.printRaw(node.env)](
          node
        );
      }
    });
    originalTree.content = tree.content;
  };
};
function shouldBeWrappedInPars(tree) {
  let content = tree.content;
  unifiedLatexUtilVisit.visit(
    tree,
    (env) => {
      if (unifiedLatexUtilMatch.match.anyEnvironment(env)) {
        content = env.content;
        return unifiedLatexUtilVisit.EXIT;
      }
    },
    { test: (node) => unifiedLatexUtilMatch.match.environment(node, "document") }
  );
  return content.some(
    (node) => unifiedLatexUtilMatch.match.parbreak(node) || unifiedLatexUtilMatch.match.macro(node, "par")
  );
}
const unifiedLatexToHast = function unifiedLatexAttachMacroArguments(options) {
  const { skipHtmlValidation = false } = options || {};
  return (tree, file) => {
    unified().use(unifiedLatexToHtmlLike, options).run(tree);
    unifiedLatexUtilLigatures.expandUnicodeLigatures(tree);
    let content = tree.content;
    unifiedLatexUtilVisit.visit(
      tree,
      (env) => {
        content = env.content;
        return unifiedLatexUtilVisit.EXIT;
      },
      {
        test: (node) => unifiedLatexUtilMatch.match.environment(
          node,
          "document"
        )
      }
    );
    const toHast = toHastWithLoggerFactory(file.message.bind(file));
    let converted = toHast({ type: "root", content });
    if (!Array.isArray(converted)) {
      converted = [converted];
    }
    let ret = hastscript.h();
    ret.children = converted;
    if (!skipHtmlValidation) {
      ret = unified().use(rehypeRaw).runSync(ret);
    }
    return ret;
  };
};
function rehypeStringify(config) {
  const processorSettings = (
    /** @type {Options} */
    this.data("settings")
  );
  const settings = Object.assign({}, processorSettings, config);
  Object.assign(this, { Compiler: compiler });
  function compiler(tree) {
    return hastUtilToHtml.toHtml(tree, settings);
  }
}
const _processor = unifiedLatex.processLatexViaUnified().use(unifiedLatexToHast).use(rehypeStringify);
function convertToHtml(tree, options) {
  let processor = _processor;
  if (!Array.isArray(tree) && tree.type !== "root") {
    tree = { type: "root", content: [tree] };
  }
  if (Array.isArray(tree)) {
    tree = { type: "root", content: tree };
  }
  if (options) {
    processor = _processor.use(unifiedLatexToHast, options);
  }
  const hast = processor.runSync(tree);
  return processor.stringify(hast);
}
exports.KATEX_SUPPORT = KATEX_SUPPORT;
exports.attachNeededRenderInfo = attachNeededRenderInfo;
exports.convertToHtml = convertToHtml;
exports.katexSpecificEnvironmentReplacements = katexSpecificEnvironmentReplacements;
exports.katexSpecificMacroReplacements = katexSpecificMacroReplacements;
exports.unifiedLatexToHast = unifiedLatexToHast;
exports.unifiedLatexWrapPars = unifiedLatexWrapPars;
exports.wrapPars = wrapPars;
//# sourceMappingURL=index.cjs.map
